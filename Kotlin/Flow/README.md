# Flow

**Kotlin Flow란 무엇인가?**

Kotlin Flow(`kotlinx.coroutines.flow.Flow`)는 **비동기적으로(asynchronously)** 계산될 수 있는 **값의 시퀀스(sequence of values)** 를 나타내는 타입입니다. 즉, 시간이 지남에 따라 0개 이상의 값을 **순차적으로 방출(emit)** 할 수 있는 데이터 스트림입니다. Kotlin Coroutines 라이브러리의 일부로, 코루틴을 기반으로 동작하며 비동기 프로그래밍을 위한 강력하고 유연한 도구를 제공합니다.

**주요 특징:**

1.  **비동기(Asynchronous):** 네트워크 요청, 데이터베이스 쿼리, 센서 데이터 등 시간이 걸리거나 연속적으로 발생하는 데이터를 처리하는 데 적합합니다.
2.  **Cold Stream (기본 동작):** 기본적으로 Flow는 "차가운(Cold)" 스트림입니다. 이는 구독자(Collector)가 `collect`와 같은 종단 연산자(Terminal Operator)를 호출하여 데이터 수집을 시작하기 전까지는 Flow 빌더(`flow { ... }`) 내부의 데이터 생산 코드가 실행되지 않음을 의미합니다. 각 구독자는 자신만의 독립적인 Flow 실행을 갖게 됩니다. (`StateFlow`, `SharedFlow`는 예외적인 Hot Stream입니다.)
3.  **코루틴 기반 (Coroutine-based):** 코루틴의 `suspend` 함수를 활용하여 데이터를 비동기적으로 생성하고 방출합니다. 이를 통해 스레드를 차단하지 않고(non-blocking) 효율적인 비동기 처리가 가능합니다.
4.  **구조화된 동시성 (Structured Concurrency):** 코루틴 스코프(`CoroutineScope`) 내에서 실행되며, 스코프가 취소되면 Flow의 실행도 자동으로 취소되어 리소스 누수를 방지하고 생명주기를 안전하게 관리할 수 있습니다.
5.  **연산자 (Operators):** `map`, `filter`, `flatMapLatest`, `debounce`, `zip`, `combine`, `catch` 등 풍부한 중간 연산자(intermediate operators)를 제공하여 데이터 스트림을 선언적이고 함수형 스타일로 변환, 필터링, 결합, 처리할 수 있습니다.

**Flow를 사용하는 이유:**

* **비동기 데이터 스트림 처리의 표준화:** 시간이 지남에 따라 여러 개의 값을 반환해야 하는 비동기 작업을 위한 Kotlin의 표준적이고 일관된 방법을 제공합니다.
* **Non-Blocking 코드:** 코루틴 기반이므로 스레드를 차단하지 않고 비동기 작업을 수행하여, 특히 UI 스레드의 응답성을 유지하는 것이 중요한 Android 개발에 매우 유리합니다.
* **구조화된 동시성 활용:** 코루틴 스코프와 통합되어 취소(Cancellation) 및 예외(Exception) 처리가 용이하고 안전합니다. `viewModelScope`, `lifecycleScope` 등과 함께 사용하여 생명주기를 고려한 안전한 비동기 처리가 가능합니다.
* **선언적 프로그래밍:** 다양한 연산자를 통해 복잡한 비동기 데이터 처리 로직을 간결하고 읽기 쉽게 표현할 수 있습니다.
* **Backpressure 처리:** 생산자(Producer)와 소비자(Collector) 간의 속도 차이(Backpressure)를 `suspend` 함수를 통해 자연스럽게 처리하며, `buffer`, `conflate`, `collectLatest` 등의 연산자로 세밀하게 제어할 수 있습니다.

**Flow가 해결하는 문제 (등장 배경):**

Flow는 기존의 비동기 처리 방식들이 가졌던 몇 가지 문제점들을 해결하기 위해 등장했습니다.

1.  **콜백 지옥 (Callback Hell):** 전통적인 콜백 기반 비동기 방식은 작업이 중첩될수록 코드가 깊어지고 읽고 관리하기 어려워지는 "콜백 지옥" 문제를 야기했습니다.
    * **Flow 해결:** `suspend` 함수와 연산자를 통해 비동기 코드를 순차적인 코드처럼 작성할 수 있게 하여 가독성을 크게 향상시킵니다.
2.  **스레드 차단 (Blocking) 문제:** 동기적인 방식으로 네트워크나 디스크 I/O를 수행하면 해당 스레드가 차단되어 앱 성능 저하나 ANR(Application Not Responding)을 유발할 수 있었습니다. `AsyncTask` 등 과거의 방식은 사용이 복잡하고 문제가 있었습니다.
    * **Flow 해결:** Coroutine 기반으로 Non-blocking I/O를 쉽게 구현할 수 있으며, `flowOn` 연산자를 통해 특정 작업의 실행 스레드를 쉽게 변경할 수 있습니다.
3.  **다중/스트리밍 데이터 처리의 어려움:** 단일 결과를 비동기적으로 반환하는 것은 `suspend` 함수나 `Future`/`Promise` 등으로 가능했지만, 시간이 지남에 따라 **여러 개의 값**을 반환하거나 **지속적인 데이터 스트림**(예: 위치 업데이트, DB 변경 감지)을 표현하고 처리하는 표준적인 방법이 부족했습니다.
    * **Flow 해결:** Flow는 0개 이상의 값을 비동기적으로 방출하는 스트림을 표현하는 데 최적화되어 있어 이러한 시나리오를 자연스럽게 모델링할 수 있습니다.
4.  **자원 관리 및 취소의 복잡성:** 비동기 작업이 시작된 후, 관련 UI 컴포넌트(Activity 등)가 파괴될 때 해당 작업을 안전하게 취소하고 리소스를 해제하는 것은 개발자가 직접 신경 써야 하는 복잡하고 오류 발생 가능성이 높은 작업이었습니다.
    * **Flow 해결:** 구조화된 동시성 덕분에, Flow가 수집되는 `CoroutineScope`(예: `viewModelScope`)가 취소되면 Flow의 실행도 **자동으로 함께 취소**되어 리소스 누수를 방지하고 코드를 안전하게 만듭니다.
5.  **RxJava와의 비교:** RxJava는 강력한 반응형 프로그래밍 라이브러리이지만, 학습 곡선이 다소 높고 코루틴과는 별개의 생태계를 가지고 있습니다.
    * **Flow 해결:** Kotlin 언어 및 코루틴과 더 긴밀하게 통합되어, 많은 경우 더 간결하고 Kotlin 친화적인 코드로 유사한 반응형 프로그래밍 패턴을 구현할 수 있게 해줍니다.

**주요 사용 사례 (Android):**

* 네트워크 API 호출 결과 처리
* Room 데이터베이스의 변경 사항 관찰 (`Flow<List<Entity>>` 반환)
* DataStore의 데이터 읽기/쓰기
* 사용자 입력 이벤트 스트림 처리 (예: 검색어 입력 `debounce`)
* 백그라운드 작업의 진행률 업데이트
* 센서 데이터나 위치 업데이트 수신

**결론:**

Kotlin Flow는 코루틴을 기반으로 하는 현대적인 비동기 데이터 스트림 처리 방식입니다. Non-blocking, 구조화된 동시성, 풍부한 연산자 등을 통해 기존 비동기 처리 방식의 문제점들을 해결하고, 더 안전하고 간결하며 읽기 쉬운 코드로 반응형 애플리케이션을 구축할 수 있도록 돕는 강력한 도구입니다.

--- 

**Kotlin Flow 주요 연산자 정리**

| 카테고리 (Category) | 연산 (Operator) | 주요 용도 (Primary Use Case) | 설명  (Description) |
| :--- | :--- | :--- | :--- |
| **변환 (Transformation)** | `map { ... }`                          | 각 항목을 다른 값으로 **변환** | Flow에서 방출되는 각 항목에 대해 주어진 변환 람다를 적용하여 새로운 값으로 매핑된 Flow를 반환합니다. (예: `Int` Flow -\> `String` Flow)                               |
|                         | `mapNotNull { ... }`                   | 각 항목을 다른 값으로 변환하되, 결과가 **null이면 제외** | `map`과 유사하지만, 변환 람다 결과가 `null`인 경우는 결과 Flow에서 제외됩니다.                                                                      |
|                         | `transform { ... }`                    | 더 **유연한 변환** (여러 값 방출, 필터링 등 가능)                       | 각 항목에 대해 주어진 람다를 실행합니다. 람다 내에서 `emit()`을 여러 번 호출하거나 호출하지 않음으로써 1:N 변환이나 필터링 효과를 낼 수 있는 저수준 변환 연산자입니다. |
| **필터링 (Filtering)** | `filter { ... }`                       | 특정 **조건을 만족**하는 항목만 통과                                  | 주어진 술어(predicate) 람다를 만족하는(결과가 true인) 항목만 포함하는 Flow를 반환합니다.                                                               |
|                         | `filterNot { ... }`                    | 특정 조건을 **만족하지 않는** 항목만 통과                               | `filter`와 반대로, 술어를 만족하지 않는(결과가 false인) 항목만 포함하는 Flow를 반환합니다.                                                           |
|                         | `filterNotNull()`                      | **null이 아닌** 항목만 통과                                         | Flow\<T?\> 타입에서 null 값을 제외하고 Flow\<T\> 타입으로 변환합니다.                                                                               |
|                         | `distinctUntilChanged()`               | **연속된 중복 항목** 제거                                           | 바로 이전에 방출된 항목과 동일한(equals) 항목은 방출하지 않습니다. 상태 변화 등 중복 업데이트를 방지하는 데 유용합니다.                                          |
| **결합 (Combining)** | `combine(otherFlow) { a, b -> ... }` | 여러 Flow의 **최신 값들을 조합**하여 새 값 생성                       | 여러 Flow 중 **어느 하나라도 새 값을 방출**하면, 다른 Flow들의 **가장 최근 값**들과 함께 조합 람다를 실행하여 새로운 값을 방출합니다. (예: 로그인 폼의 ID/PW 유효성 동시 체크) |
|                         | `zip(otherFlow) { a, b -> ... }`       | 여러 Flow의 항목들을 **순서대로 짝지어** 새 값 생성                     | 모든 Flow가 같은 인덱스의 값을 방출할 때까지 기다렸다가, 각 Flow의 해당 인덱스 값들을 짝지어 조합 람다를 실행하고 새 값을 방출합니다. 한쪽 Flow가 먼저 끝나면 zip도 종료됩니다. |
| **평탄화 (Flattening)** | `flatMapLatest { ... -> flow }`      | 최신 항목에 대한 **새 Flow로 전환** (이전 Flow는 취소)                 | 업스트림에서 새 항목이 방출되면, 변환 람다를 통해 생성된 **최신 내부 Flow만 구독**하고 이전 내부 Flow 구독은 취소합니다. (예: 검색어 변경 시 이전 검색 결과 Flow 취소) |
|                         | `flatMapConcat { ... -> flow }`      | 여러 Flow를 **순차적으로 이어붙임** | 업스트림 항목마다 생성된 내부 Flow들을 순서대로 하나씩 구독하고 완료될 때까지 기다립니다.                                                              |
|                         | `flatMapMerge { ... -> flow }`       | 여러 Flow를 **동시에 병합** (순서 보장 안됨)                         | 업스트림 항목마다 생성된 내부 Flow들을 동시에 구독하고, 각 Flow에서 방출되는 값들을 순서에 상관없이 병합하여 방출합니다. (동시성 제어 가능)                        |
| **크기 제한 (Size Limiting)** | `take(count)`                          | **처음 N개** 항목만 통과                                          | 지정된 개수(`count`)만큼의 항목만 방출하고 Flow를 완료시킵니다.                                                                               |
|                         | `takeWhile { ... }`                    | 특정 조건을 **만족하는 동안**만 항목 통과                             | 주어진 술어(predicate) 람다를 만족하는 동안만 항목을 방출하고, 처음으로 만족하지 않는 항목이 나타나면 Flow를 완료시킵니다.                                    |
| **에러 처리 (Error Handling)**| `catch { throwable -> ... }`           | 업스트림 Flow에서 발생한 **예외 처리** | `catch` 연산자보다 앞에 있는(업스트림) 연산자나 Flow 빌더에서 예외가 발생하면 이를 잡아서 처리하는 람다를 실행합니다. 람다 내에서 대체 값을 `emit`하거나 예외를 로깅할 수 있습니다. |
| **컨텍스트 변경 (Context)** | `flowOn(context)`                      | 업스트림 Flow 실행 **컨텍스트(Dispatcher) 변경** | `flowOn` 앞에 있는(업스트림) 연산자들의 실행 스레드(Dispatcher)를 지정된 `context`로 변경합니다. (예: 네트워크/DB 작업은 IO 스레드에서, 수집은 Main 스레드에서)  |
| **버퍼링/조절 (Buffering)** | `buffer(capacity)`                   | 생산자-소비자 간 **버퍼** 추가                                      | Flow 방출(emit)과 수집(collect) 사이에 버퍼를 두어 생산자와 소비자가 독립적으로 실행될 수 있게 합니다. 처리량 향상에 도움이 될 수 있습니다.                     |
|                         | `conflate()`                           | 소비자가 느릴 때 **중간 값 누락시키고 최신 값만 처리** | 소비자가 값을 처리하는 동안 생산자가 여러 값을 방출하면, 소비자는 중간 값들을 건너뛰고 가장 마지막(최신) 값만 받아서 처리합니다.                                |
|                         | `debounce(timeoutMillis)`              | 지정된 시간 동안 새 값이 없으면 **마지막 값 방출** | 값이 방출된 후, 지정된 `timeoutMillis` 동안 새로운 값이 방출되지 않으면 해당 값을 다운스트림으로 전달합니다. (예: 검색어 입력 시 타이핑 멈춘 후 검색 실행)        |
|                         | `sample(periodMillis)`                 | 지정된 주기마다 **가장 최근 값 샘플링** | 지정된 시간(`periodMillis`) 간격으로 Flow의 가장 최근 값을 주기적으로 샘플링하여 방출합니다. (예: 위치 업데이트 빈도 조절)                                 |
| **기타 (Side Effects)** | `onEach { ... }`                       | 각 항목 방출 시 **부수 효과(Side Effect)** 실행                      | Flow 스트림 자체를 변경하지 않고, 각 항목이 방출될 때마다 로깅, UI 업데이트 트리거 등 부가적인 작업을 수행합니다.                                          |
|                         | `onStart { ... }`                      | Flow **수집 시작 전** 작업 수행                                     | `collect`가 호출되어 Flow 실행이 시작되기 직전에 주어진 람다를 실행합니다. (예: 로딩 상태 표시 시작)                                                     |
|                         | `onCompletion { cause -> ... }`        | Flow **완료 또는 취소 시** 작업 수행                                 | Flow가 정상적으로 완료되거나 예외로 인해 취소되었을 때 주어진 람다를 실행합니다. `cause` 파라미터로 종료 원인(예외 또는 null)을 알 수 있습니다. (예: 로딩 상태 숨김) |
| **상태 변환 (State)** | `stateIn(...)`                         | Cold Flow를 **`StateFlow`** 로 변환 (Hot, 공유, 상태 저장)             | ViewModel 등에서 UI 상태를 나타내기 위해 Cold Flow를 Hot StateFlow로 변환할 때 사용합니다. `SharingStarted` 전략으로 공유 생명주기를 관리합니다.         |
|                         | `shareIn(...)`                         | Cold Flow를 **`SharedFlow`** 로 변환 (Hot, 공유, 이벤트/데이터 브로드캐스팅) | 여러 구독자에게 이벤트나 데이터를 브로드캐스팅하기 위해 Cold Flow를 Hot SharedFlow로 변환할 때 사용합니다. `replay`, 버퍼 등을 설정할 수 있습니다.             |

**참고:** 종단 연산자 (Terminal Operators): collect, first, single, toList, toSet, count, fold, reduce, launchIn 등은 Flow의 실행을 실제로 시작하고 결과를 반환하거나 특정 동작을 수행하는 연산자입니다. 이들은 표의 중간 연산자들과는 다른 분류입니다.
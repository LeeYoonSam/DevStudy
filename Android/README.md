# Android

## [Core Android](./CoreAndroid)

- [Asynchronous IO](./CoreAndroid/#asynchronous-io)
- [ViewBinding 과 DataBinding 차이점](./CoreAndroid/#viewbinding-과-databinding-차이점)
- [ViewModel 과 SharedViewModel 의 차이와 구현 방법](./CoreAndroid/#viewmodel-과-sharedviewmodel-의-차이와-구현-방법)
- [Android Jetpack이란](./CoreAndroid/#android-jetpack이란)
- [Android 애플리케이션의 성능을 최적화하기 위한 전략](./CoreAndroid/#android-애플리케이션의-성능을-최적화하기-위한-전략)
- [안드로이드에서 비동기 처리가 필요한 이유에 및 Rxjava, Coroutine 의 특징과 차이점, 장단점](./CoreAndroid/#안드로이드에서-비동기-처리가-필요한-이유에-및-rxjava-coroutine-의-특징과-차이점-장단점)
- [안드로이드에서 의존성 주입이란?](./CoreAndroid/#안드로이드에서-의존성-주입이란)
- [Android에서 Parcelable 인터페이스의 목적은 무엇이며 Serializable 사용성 차이](./CoreAndroid#android에서-parcelable-인터페이스의-목적은-무엇이며-serializable-사용성-차이)
- [Android의 콘텐츠 제공자는 무엇이며 주요 목적](./CoreAndroid/#android의-콘텐츠-제공자는-무엇이며-주요-목적은-무엇인가요-콘텐츠-제공자가-유용할-수-있는-예시-시나리오를-제공)
- [안드로이드 어플리케이션 컴포넌트](./CoreAndroid#안드로이드-어플리케이션-컴포넌트)
- [매니페스트 파일](./CoreAndroid#매니페스트-파일)
- [안드로이드 어플리케이션의 프로젝트 구조](./CoreAndroid#안드로이드-어플리케이션의-프로젝트-구조)
- [Android Context](./CoreAndroid#android-context)
- [What is requireActivity?](./CoreAndroid#what-is-requireactivity)
- [Pro-guard 의 용도는?](./CoreAndroid#pro-guard-의-용도는)
- [Pending Intent 를 사용해서 액티비티를 시작하는 방법은?](./CoreAndroid#pending-intent-를-사용해서-액티비티를-시작하는-방법은)
- [안드로이드 앱 프로세스 분리하기](./CoreAndroid#안드로이드-앱-프로세스-분리하기)
- [서비스와 액티비티 간에 활용할 수 있는 IPC](./CoreAndroid#서비스와-액티비티-간에-활용할-수-있는-ipc)
- [Navigation Component](./CoreAndroid#navigation-component)
- [Lifecycle](./CoreAndroid#lifecycle)
- [LifecycleOwner](./CoreAndroid#lifecycleowner)
- [LiveData vs ObservableField](./CoreAndroid#livedata-vs-observablefield)

## [Activity and Fragment](./ActivityAndFragment)

- [Activity 생명주기](./ActivityAndFragment#activity-생명주기)
- [onSavedInstanceState onRestoreInstanceState](./ActivityAndFragment#onsavedinstancestate-onrestoreinstancestate)
- [프래그먼트 생명주기](./ActivityAndFragment#프래그먼트-생명주기)
- [Fragment 사용하는 이유](./ActivityAndFragment#fragment-사용하는-이유)
- [언제 Activity가 아닌 Fragment를 사용 하는지?](./ActivityAndFragment#언제-activity가-아닌-fragment를-사용-하는지)
- [FragmentPagerAdapter와 FragmentStatePagerAdapter의 차이점](./ActivityAndFragment#fragmentpageradapter와-fragmentstatepageradapter의-차이점)
- [Fragment 백스택에서 Add, Replace 차이점](./ActivityAndFragment#fragment-백스택에서-add-replace-차이점)
- [기본 생성자만 사용하여 fragment 를 만드는것이 권장되는 이유](./ActivityAndFragment#기본-생성자만-사용하여-fragment-를-만드는것이-권장되는-이유)
- [두 fragment 간 데이터 전달 방법](./ActivityAndFragment#두-fragment-간-데이터-전달-방법)
- [retained Fragment 란?](./ActivityAndFragment#retained-fragment-란)
- [Fragment transaction 을 커밋하는 동안 addToBackStack()의 목적은?](./ActivityAndFragment#fragment-transaction-을-커밋하는-동안-addtobackstack의-목적은)
- [액티비티 launchMode 설명](./ActivityAndFragment#액티비티-launchmode-설명)


## [Android UI](./Ui)

- [안드로이드에서 View 란?](./Ui#안드로이드에서-view-란)
- [Custom View 만들기](./Ui#custom-view-만들기)
- [ViewGroups 이란 무엇이며 View와 어떻게 다른지?](./Ui#viewgroups-이란-무엇이며-view와-어떻게-다른지)
- [ConstraintLayout 이란?](./Ui#constraintlayout-이란)
- [ViewTreeObserver가 무엇인지?](./Ui#viewtreeobserver가-무엇인지)
- [include, merge, ViewStub 차이](./Ui#include-merge-viewstub-차이)
- [FragmentContainerView 란?](./Ui#fragmentcontainerview-란)
- [Glide 에서 리사이즈를 처리하지 않게 하는 방법 2가지](./Ui#glide-에서-리사이즈를-처리하지-않게-하는-방법-2가지)
- [Bitmap-prepareToDraw](./Ui#bitmap-preparetodraw)

## [Android Compose](./Compose/)
- [Jetpack Compose란 무엇이며 Android 앱 개발을 위한 주요 기능과 이점](./Compose/#jetpack-compose란-무엇이며-android-앱-개발을-위한-주요-기능과-이점)

## [Displaying Lists of Content](./RecyclerView)
- [RecyclerView](./RecyclerView#recyclerview)
- [ListView 와 RecyclerView 의 차이점](./RecyclerView#listview-와-recyclerview-의-차이점)
- [ViewHolder 패턴을 사용하는 이유](./RecyclerView#viewholder-패턴을-사용하는-이유)
- [RecyclerView 최적화 방법](./RecyclerView#recyclerview-최적화-방법)
- [SnapHelper](./RecyclerView#snaphelper)

## [Intent](./Intent)

- [Intent란?](./Intent#intent란)


## [Long-running Operations](./LongRunningOperations)

- [ANR 이 무엇이며 어떻게 방지할 수 있는지?](./LongRunningOperations#anr-이-무엇이며-어떻게-방지할-수-있는지)
- [AsyncTask 의 생명 주기와 액티비티의 관계 및 발생할수 있는 문제](./LongRunningOperations#asynctask-의-생명-주기와-액티비티의-관계-및-발생할수-있는-문제)
- [Looper, Handler and HandlerThread](./LongRunningOperations#looper-handler-and-handlerthread)


## [Architecture](./Architecture)

- [Architecture 란?](./Architecture#architecture-란)
- [아키텍처 패턴](./Architecture#아키텍처-패턴)
- [MVVM Architecture](./Architecture#mvvm-architecture)
- [MVP Architecture](./Architecture#mvp-architecture)
- [MVC Architecture](./Architecture#mvc-architecture)
- [MVI Architecture](./Architecture#mvi-architecture)
- [Clean Architecture](./Architecture#clean-architecture)
- [모바일 클린 아키텍처](./Architecture#모바일-클린-아키텍처)
- [Clean Code](./Architecture#clean-code)


## [ImageGraphic](./ImageGraphic)

- [비트맵 처리](./ImageGraphic/README.md#비트맵-처리)


## [Library](./Library)

- [Dagger Hilt Koin 비교](./Library/README.md#dagger-hilt-koin-비교)
- [RxJava](./Library/README.md#rxjava)
- [RxJava Hot, Cold Observable](./Library/README.md#rxjava-hot-cold-observable)
- [RxJava Backpressure(배압)](./Library/README.md#rxjava-backpressure배압)
- [Glide](./Library/README.md#glide)

## [Performance](./Performance)

- [앱 크기 줄이기](./Performance/README.md#앱-크기-줄이기)

## 인터뷰 질문

### 안드로이드에서 Dependency Injection(DI)을 사용하는 이유와 Hilt를 활용한 DI의 장점에 대해 설명해주세요.

의존성 주입(DI)이란?
DI(Dependency Injection)는 객체 생성을 외부에서 담당하여 클래스 간의 의존성을 줄이고 유지보수성을 높이는 기법입니다.

	DI가 필요한 이유 (예시: ViewModel)
ViewModel 내부에서 UseCase, Repository, DataStore, Logging 등의 객체를 직접 생성한다면:
	•	객체가 변경될 때마다 ViewModel도 수정해야 하므로 유지보수가 어려움
	•	의존성 때문에 단위 테스트가 어려움 (Mock 객체를 사용하기 힘듦)
	•	코드가 복잡해지고 재사용성이 낮아짐

	따라서 DI를 사용하면:
	•	객체 생성을 분리하여 ViewModel이 직접 의존성을 관리하지 않도록 함
	•	객체를 주입받아 테스트가 쉬워짐 (Mock 객체 활용 가능)
	•	코드 재사용성이 증가하고 유지보수가 쉬워짐

	Hilt의 특징 및 장점
Hilt는 Dagger 기반의 DI 라이브러리로, 어노테이션을 통해 간편하게 의존성 주입을 설정할 수 있습니다.

	주요 어노테이션 및 역할
	•	@HiltAndroidApp → 애플리케이션 클래스에 선언하여 Hilt 사용을 활성화
	•	@Module → 의존성 객체를 제공하는 클래스
	•	@Provides → 객체 생성 메서드 (팩토리 패턴 역할)
	•	@InstallIn → 객체의 생명주기 범위 지정 (ex: Singleton, ActivityScoped 등)
	•	@AndroidEntryPoint → Activity, Fragment, Service에서 의존성 자동 주입 가능
	•	@HiltViewModel → ViewModel에서 의존성을 주입할 때 사용
	•	@Inject → 생성자 또는 필드에 의존성을 주입할 때 사용

	Hilt의 장점
	•	@AndroidEntryPoint를 활용하면 Activity, Fragment에서도 DI를 쉽게 사용 가능
	•	@HiltViewModel을 통해 ViewModel에 Repository, UseCase 등을 쉽게 주입
	•	@Singleton을 사용하여 애플리케이션 전역에서 하나의 객체만 유지 가능
	•	기존 Dagger에 비해 코드가 간결하고, 보일러플레이트 코드가 줄어듦


## 안드로이드에서 데이터 저장 방식에는 어떤 것들이 있으며, 각각의 특징과 언제 사용하면 좋은지 설명해주세요.
안드로이드에서 데이터를 저장하는 방법은 여러 가지가 있으며, 대표적으로 SharedPreferences, SQLite(Room), DataStore 등이 있습니다.

	1. SharedPreferences
	•	Key-Value 형태로 간단한 데이터를 저장하는 방식입니다.
	•	사용 사례: 사용자 설정(다크 모드 여부, 언어 설정 등), 간단한 플래그 저장.
	•	단점: 데이터 구조화가 어렵고, 동기 처리 방식이기 때문에 성능 문제 발생 가능.

	2. SQLite & Room
	•	SQLite는 관계형 데이터베이스로 강력한 데이터 저장이 가능하지만, 직접 SQL을 작성해야 합니다.
	•	Room을 사용하면 Entity, DAO, Database 클래스를 통해 손쉽게 데이터 관리 가능
	•	사용 사례: 앱 내에서 일정, 유저 데이터, 대량의 구조화된 데이터를 저장할 때 유용.

	3. DataStore (SharedPreferences 대체재)
	•	SharedPreferences의 단점을 보완한 방식으로, 비동기 처리와 데이터 구조화가 가능.
	•	사용 사례: 사용자 설정 데이터 저장, 간단한 key-value 저장.

	4. 기타 데이터베이스 (Realm, ObjectBox 등)
	•	SQLite보다 빠르고 NoSQL 기반이기 때문에 오브젝트 기반 데이터 저장에 적합.
	•	사용 사례: 대량의 오브젝트 데이터를 관리할 때.

## 안드로이드에서 멀티스레딩을 사용하는 주요 방법
	1.	Thread (Java 기본 스레드)
	•	Thread 클래스를 상속받아 run() 메서드를 오버라이드하여 실행합니다.
	•	하지만 UI 업데이트를 하려면 Handler를 사용해야 하는 번거로움이 있습니다.

class MyThread : Thread() {
    override fun run() {
        // 백그라운드 작업 수행
        Log.d("Thread", "Running in background")
    }
}
MyThread().start() // 스레드 시작

2.	HandlerThread
	•	HandlerThread는 기본 Thread와 다르게 Looper를 가지고 있어 여러 개의 작업을 순차적으로 처리할 수 있습니다.
	•	장점: UI 스레드와 분리된 자체 메시지 큐를 관리할 수 있음.
	•	단점: Handler를 통해서만 작업을 전달할 수 있음.

val handlerThread = HandlerThread("MyHandlerThread").apply { start() }
val handler = Handler(handlerThread.looper)
handler.post {
    Log.d("HandlerThread", "Background task running")
}

3.	AsyncTask (Deprecated)
	•	과거에는 AsyncTask를 많이 사용했지만, 메모리 누수 및 예측하기 어려운 동작 때문에 공식적으로 deprecated 되었습니다.

	4.	Executors (권장)
	•	Executors.newSingleThreadExecutor() 같은 API를 이용하여 쉽게 백그라운드 작업을 실행할 수 있습니다.
	•	장점: 스레드 풀을 관리하여 여러 개의 스레드를 효과적으로 사용할 수 있음.
	•	단점: 직접 스레드 풀을 관리해야 함.

val executor = Executors.newSingleThreadExecutor()
executor.execute {
    Log.d("Executors", "Background task running")
}

5.	Coroutine (가장 권장)
	•	Kotlin에서 가장 권장되는 방식이며, suspend 키워드를 사용하여 비동기 작업을 쉽게 처리할 수 있습니다.
	•	장점: 가독성이 뛰어나고 UI와의 연동이 용이함.
	•	단점: CoroutineScope를 적절히 관리하지 않으면 메모리 누수가 발생할 수 있음.

lifecycleScope.launch(Dispatchers.IO) {
    val data = fetchData() // 네트워크 요청
    withContext(Dispatchers.Main) {
        textView.text = data // UI 업데이트
    }
}


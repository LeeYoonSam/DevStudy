# 사이드 이펙트 소개 (Introducing side effects)

첫 번째 장에서 Composable 함수의 속성을 학습하면서 **사이드 이펙트**에 대하여 다룬 적이 있습니다. 우리는 사이드 이펙트가 함수를 **비결정적(non-deterministic)** 으로 만들며, 개발자가 코드를 추론하기 어렵게 한다는 것을 배웠습니다.

## 사이드 이펙트란?

본질적으로 사이드 이펙트는 **함수의 제어 및 범위를 벗어나는 모든 것**을 의미합니다.

### 순수 함수 (Pure Function)

두 정수를 덧셈하는 함수를 살펴보겠습니다:

```kotlin
fun add(a: Int, b: Int) = a + b
```

이 함수는 주어진 입력값만을 사용하여 결과를 계산하기 때문에 **"순수 함수(pure function)"** 로 자주 언급됩니다. 

**순수 함수의 특징:**
- 같은 입력값에 대해 결과는 절대 변하지 않음
- 함수가 하는 일은 단지 입력값들을 더하는 것뿐
- 결정적(deterministic)이며, 쉽게 추론 가능

### 사이드 이펙트가 있는 함수

이제 몇 가지 부수적인 작업을 추가해 봅시다:

```kotlin
fun add(a: Int, b: Int) =
  calculationsCache.get(a, b) ?: 
    (a + b).also { calculationsCache.store(a, b, it) }
```

위 코드는 이미 계산된 결과를 저장함으로써 수행 시간을 절약하기 위해 `캐시`를 도입하였습니다. 

**문제점:**
- 이 캐시는 함수의 제어를 벗어남
- 캐시로부터 읽은 값이 마지막 실행 이후 수정되었는지 여부를 알 수 없음
- 다른 스레드에서 동시에 캐시를 업데이트하는 경우, 예측 불가능한 결과 발생

## 비결정적 동작의 예시

동일한 입력값에 대해 `get(a, b)`를 연속해서 두 번 호출하면, 두 가지의 다른 결과가 반환될 수 있습니다:

```kotlin
fun main() {
  add(1, 2) // 3
  // Another thread calls: cache.store(1, 2, res = 4)
  add(1, 2) // 4
}
```

> `add` 함수는 같은 입력에 대해 다른 값을 반환하므로 더 이상 **결정적이지 않습니다**.

### 더 복잡한 시나리오

캐시가 메모리 내에 있지 않고 **데이터베이스**에 의존한다고 상상해 보세요:
- 데이터베이스 연결이 끊어진 경우 `get` 및 `store` 호출에서 예외 발생 가능
- `add` 함수의 호출이 예상치 못한 상황에서 실패할 수 있음

## 사이드 이펙트의 영향

사이드 이펙트는 **함수의 호출자가 기대한 것과 다른 동작**을 발생시키고, **함수의 동작을 변경**할 수 있습니다.

**사이드 이펙트의 부정적 영향:**
- 개발자가 코드에 대해 추론하기 어렵게 만듦
- 테스트 가능성을 감소시킴
- 결함이 발생할 가능성을 높임

## 사이드 이펙트의 다양한 예시

| 분류 | 예시 |
|------|------|
| **상태 변경** | 전역 변수 쓰기/읽기 |
| **캐시 작업** | 메모리 캐시 접근 |
| **영속성** | 데이터베이스 작업, 파일 읽기/쓰기 |
| **네트워크** | 네트워크 쿼리 수행 |
| **UI** | 화면에 무언가 표시하기 |

## 요약

- **사이드 이펙트**는 함수의 제어 및 범위를 벗어나는 모든 동작을 의미합니다.
- **순수 함수**는 같은 입력에 대해 항상 같은 결과를 반환하며, 사이드 이펙트가 없습니다.
- 사이드 이펙트가 있는 함수는 **비결정적**이며, 예측 불가능한 동작을 초래할 수 있습니다.
- 캐시, 데이터베이스, 네트워크 등 외부 상태에 의존하는 작업은 모두 사이드 이펙트입니다.
- 사이드 이펙트는 코드의 **추론 가능성, 테스트 가능성, 안정성**을 저하시킵니다.
- Jetpack Compose에서는 사이드 이펙트를 제어하기 위한 특별한 메커니즘(이펙트 핸들러)이 필요합니다.

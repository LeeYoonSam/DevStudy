# Compose 어노테이션들 (Compose annotations)

Compose의 작업 순서를 되짚어보면, 우리가 먼저 살펴봐야 할 것은 Compose Compiler가 필요한 요소를 스캔하고 마법을 부릴 수 있도록 어노테이션을 어떻게 활용하느냐 입니다. 사용 가능한 Compose 어노테이션을 살펴보는 것으로 시작해봅시다.


**컴파일러 플러그인**이 어노테이션 프로세서보다 훨씬 더 많은 것을 할 수 있지만, 둘 사이에는 공통점이 몇 가지 있습니다. 그 공통점 중 하나는 정적 분석과 검증에 자주 사용되는 프론트엔드 단계입니다.


`Compose Compiler`는 Kotlin 컴파일러의 프론트엔드에서 후크 및 확장점을 활용하여 강제하고자 하는 제약 사항이 충족되고 있는지, 타입 시스템이 Composable 함수나 선언 및 표현식을 적절히 일반적인(Composable 함수가 아닌) 함수들과는 다르게 처리하고 있는지를 확인합니다.


그 외에도, Compose는 특정 상황에서 추가적인 검사와 다양한 런타임 최적화 또는 `숏컷`을 활성화하기 위해 추가적인 어노테이션들을 제공합니다. 모든 Compose 어노테이션들은 `Compose Runtime 라이브러리`에 의해 제공됩니다.


> 모든 Compose 어노테이션들은 Compose Runtime에 의해 제공되는데, Compose Compiler와 Runtime 모듈이 이를 함께 잘 활용하기 위함입니다.

## 요약
* Jetpack Compose에서 **어노테이션**은 **Compose 컴파일러**가 코드를 스캔하고 변환 작업을 시작하는 **진입점** 역할을 합니다. 📌
* 컴파일러 플러그인은 어노테이션을 통해 코틀린 컴파일러의 **프론트엔드 단계에서 코드를 정적으로 분석**하고, `@Composable` 함수에만 적용되는 특별한 제약 조건들이 지켜지는지 확인합니다.
* `@Composable` 외에도, Compose는 **추가적인 검사나 런타임 최적화를 활성화**하기 위한 다양한 보조 어노테이션들을 제공합니다.
* 모든 Compose 관련 어노테이션은 **`Compose Runtime` 라이브러리**에 포함되어 있으며, 이는 컴파일러와 런타임이 긴밀하게 협력하여 작동하도록 설계되었기 때문입니다.
# Compose 컴파일러 (The Compose compiler)

Jetpack Compose는 코드 생성에 다소 의존합니다. Kotlin과 JVM 진영에서는 보통 `kapt`를 통한 어노테이션 프로세서(annotation processor)를 사용하는 것이 일반적이지만, Jetpack Compose는 다릅니다. **Compose Compiler는 실제의 Kotlin 컴파일러 플러그인**입니다. 이는 라이브러리가 **Kotlin 컴파일 단계 내에서 진행되는 컴파일 타임 작업을 수반할 수 있게 하여, 코드의 형태에 있어 보다 관련성 있는 정보에 접근하고 전체 프로세스를 가속화**할 수 있습니다. kapt는 컴파일 이전에 실행해야 하지만, **컴파일러 플러그인은 컴파일 과정에 직접 내장**되어 있습니다.

`Kotlin 컴파일러 플러그인`이라는 것은 **컴파일러의 프론트엔드 단계에서 진단을 보고할 수 있는 기회를 제공하며, 이는 매우 빠른 피드백 루프**로 이어집니다. 그러나, 이러한 진단은 IDEA가 플러그인과 직접적으로 통합되어 있지 않기 때문에 IDE에게 보고되지 않습니다. 지금 Compose에서 찾을 수 있는 IDEA 수준의 검사는 Compose Compiler 플러그인과 코드를 공유하지 않는 별도의 IDEA 플러그인을 통해 추가되었습니다. 그 말인 즉, **컴파일 버튼을 누르자마자 프론트엔드쪽으로 진단이 보고**됩니다. **Kotlin 컴파일러의 프론트엔드 단계에서 정적 분석을 통한 피드백 루프를 개선한 것은 궁극적인 장점이며, Compose Compiler는 해당 이점을 잘 활용**하고 있습니다.

Kotlin에서 컴파일러 플러그인은 밝은 미래를 가지고 있습니다. 현재 알려진 많은 어노테이션 프로세서들이 점차적으로 컴파일러 플러그인이나 `KSP(Kotlin Symbol Processing 라이브러리)`를 통한 **경량 컴파일러 플러그인으로 전환**될 가능성이 높습니다.


> Kotlin 컴파일러 플러그인에 관심이 있으시다면, Kapt의 대체재로 Google이 제안하는 `KSP(Kotlin Symbol Processing)`를 확인해보실 것을 적극 권장드립니다. KSP는 **메타프로그래밍을 위해 모든 라이브러리가 의존할 수 있는 “경량 컴파일러 플러그인 작성“을 위한 표준화된 DSL을 제안**합니다. GitHub에서 KSP 리파지토리의 `Why KSP` 섹션을 참고하시길 바랍니다. 또한, `Compose Compiler`는 `IR 변환`에 많이 의존하고 있으며, 이는 다른 메타프로그래밍과 함께 널리 사용될 경우 위험할 수 있습니다. 모든 어노테이션 프로세서들이 컴파일러 플러그인으로 전환된다면, 너무 많은 IR 변환이 발생할 수 있고, 결과적으로 언어를 불안정하게 만들 수 있습니다. 언어를 조정하거나 확장하는 것은 항상 위험을 동반합니다. 그래서 전반적으로 KSP가 더 나은 선택일 수 있습니다.

## 요약
* Jetpack Compose의 컴파일러는 `kapt`를 사용하는 일반적인 어노테이션 처리기가 아니라, **코틀린 컴파일 단계에 직접 내장되는 실제 컴파일러 플러그인**입니다.
* 컴파일러 플러그인 방식은 컴파일 과정에서 더 많은 코드 정보에 접근할 수 있어, **코드 변환 및 최적화를 더 효율적으로 수행**하고 개발자에게 **더 빠른 피드백**을 제공하는 장점이 있습니다.
* 이와 유사한 차세대 도구로 **KSP(Kotlin Symbol Processing)** 가 있으며, 이는 라이브러리들이 메타프로그래밍을 위해 사용할 수 있는 "경량 컴파일러 플러그인"을 작성하기 위한 표준화된 방법을 제공합니다.
* 다만, Compose 컴파일러가 사용하는 강력한 IR(중간 표현) 변환은 여러 라이브-러리에서 남용될 경우 언어의 안정성을 해칠 수 있어, 범용적인 메타프로그래밍에는 KSP가 더 안전한 선택일 수 있습니다.

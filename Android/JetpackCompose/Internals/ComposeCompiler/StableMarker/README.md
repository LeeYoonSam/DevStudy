# @StableMarker

**Compose Runtime**은 타입의 **안정성(stability)** 을 나타내기 위해 몇 가지 어노테이션을 제공합니다. 대표적으로 **메타 어노테이션인 `@StableMarker`**, 그리고 대상 타입에 직접 부착되는 **`@Immutable`**, **`@Stable`** 이 있습니다. 여기서는 `@StableMarker`를 중심으로 살펴봅니다.

## `@StableMarker`란 무엇인가
`@StableMarker`는 `@Immutable`이나 `@Stable`에 사용되는 **메타 어노테이션**입니다. 즉, "어노테이션을 위한 어노테이션"으로, **재사용**을 통해 안정성 개념을 다른 어노테이션에 부여합니다.

## 안정성 요구 사항
`@StableMarker`가 부여된 어노테이션(`@Immutable`, `@Stable`)로 **마킹된 타입**은 다음 요구 사항을 만족해야 합니다.

- **동치성 보장**: `equals` 함수의 호출 결과는 동일한 두 인스턴스에 대해 항상 동일합니다.
- **변경 통지**: 어노테이션이 적용된 **public 프로퍼티**에 변경이 발생하면 해당 사실을 **컴포지션(composition)** 에 알립니다.
- **프로퍼티 안정성**: 어노테이션이 적용된 모든 **public 프로퍼티는 안정적(stable)** 이라고 간주합니다.

따라서 **`@Immutable` 또는 `@Stable`로 마킹된 모든 타입은 위 요구 사항을 충족**해야 합니다. 두 어노테이션 모두 **안정성 마커(`@StableMarker`)** 로서 동작하기 때문입니다.

### 컴파일러와의 약속, 그리고 추론
이는 **컴파일러에 대한 약속(contract)** 이며, 컴파일러가 소스 코드를 처리할 때 **추론**에 활용됩니다. 다만 컴파일 시점에 이 약속을 **강제 검증하지는 않습니다**. 결국 요구 사항 충족 여부를 보장하는 책임은 **개발자**에게 있습니다.

Compose Compiler는 가능한 경우 **어노테이션 없이도 타입의 안정성을 추론**해 안정적으로 취급하려고 시도합니다. 실무에서는 대개 이 **추론만으로 충분**하지만, 다음의 경우에는 개발자가 직접 어노테이션을 부착하는 것이 좋습니다.

## 어노테이션이 필요한 대표 사례
- **계약 강제(인터페이스/추상 클래스)**: 인터페이스 또는 추상 클래스에서 **필수적으로 구현해야 하는 계약/요구 사항**을 명시할 때. 이때 어노테이션은 컴파일러와의 약속이자 **구현을 위한 요구 사항**이 됩니다. (단, 선언 자체가 자동 검증되지는 않습니다.)
- **가변 구현이지만 안정적으로 취급하고 싶은 경우**: 구현체가 내부적으로 **캐시** 등을 가져 값이 변할 수 있으나, **public API가 캐시 상태와 독립적**이라 외부에서 볼 때는 안정적으로 동작한다고 판단되는 경우.

## 간단 예시
다음은 `@Immutable`과 `@Stable`의 전형적인 사용 예시입니다.

```kotlin
  import androidx.compose.runtime.Immutable
  import androidx.compose.runtime.Stable
  import androidx.compose.runtime.getValue
  import androidx.compose.runtime.mutableStateOf
  import androidx.compose.runtime.setValue

  @Immutable
  data class UiUser(
    val id: String,
    val name: String
  )

  @Stable
  class Counter {
    // state 변경은 컴포지션에 안전하게 통지됨
    var value by mutableStateOf(0)
      private set

    fun increment() { value++ }
  }
```

## 어노테이션 비교
다음 표는 관련 어노테이션의 **역할과 적용 대상**을 비교합니다.

| 어노테이션 | 성격 | 주된 목적 | 적용 대상 | 비고 |
|---|---|---|---|---|
| `@StableMarker` | 메타 | 안정성 의미를 다른 어노테이션에 부여 | 어노테이션 | 직접 타입에 붙지 않음 |
| `@Immutable` | 타입 | 불변(immutable) 모델 정의 | 클래스/데이터 클래스 | 모든 public 프로퍼티가 불변/안정 |
| `@Stable` | 타입 | 안정적이지만 내부적으로는 변할 수 있음 | 클래스 | 변경은 컴포지션에 통지되어 재구성이 안전 |

## 안정성 추론 흐름도
컴파일러 관점에서의 간략한 **안정성 판단 흐름**입니다.

```mermaid
  flowchart TD
  A[타입 분석 시작] --> B{`@Immutable`인가?}
  B -- 예 --> C[안정적 처리]
  B -- 아니오 --> D{`@Stable`인가?}
  D -- 예 --> C
  D -- 아니오 --> E{구조/프로퍼티로 추론 가능한가?}
  E -- 예 --> C
  E -- 아니오 --> F[비안정 또는 불명확]
```

## 주의 사항
- 위 요구 사항은 **강제 검증되지 않으므로**, 개발자가 **의도와 계약을 지키는 설계/구현**이 중요합니다.
- `@Stable`을 남용하면 실제로는 비안정적인 타입을 안정적이라고 **오인**할 수 있습니다. 외부 가시성 기준의 **불변성/독립성**을 신중히 판단하세요.

## 요약
- **`@StableMarker`**: 안정성을 부여하는 **메타 어노테이션**으로 `@Immutable`, `@Stable`의 근간.
- **요구 사항**: 동치성 유지, public 프로퍼티 변경 통지, public 프로퍼티 안정성 보장.
- **컴파일러**: 가능한 경우 **어노테이션 없이도 안정성 추론**. 다만 **검증은 강제되지 않음**.
- **언제 쓰나**: 계약을 강제하고 싶을 때, 내부는 변하지만 **외부적으로 안정**인 타입을 명시하고 싶을 때.
# @Composable

`Composable 어노테이션`은 이미 1장에서 깊이 다루었습니다. 그럼에도 불구하고, 가장 중요한 어노테이션이라는 사실은 분명하기 때문에 별도의 섹션에서 다룰 필요가 있습니다. 어노테이션 목록의 첫 번째로 소개되는 이유이기도 합니다.


`Compose Compiler`와 `어노테이션 프로세서`의 가장 큰 차이점은, **Compose의 경우 실제로 어노테이션이 붙어있는 선언이나 표현식을 변형**한다는 것입니다. 대부분의 어노테이션 프로세서는 표현식을 변형하는 행위 등은 할 수 없으며, 추가적이거나 동등한 선언만을 제공할 수 있습니다. 그렇기 때문에 `Compose Compiler`는 **IR 변환**을 사용합니다. `@Composable 어노테이션`은 실제로 **어노테이션이 붙은 대상의 타입을 변경하며, 컴파일러 플러그인은 프론트엔드에서 Composable 타입이 일반적인(Composable이 아닌) 함수들과 동일한 취급을 받지 않도록 모든 종류의 규칙을 강제하는 데 활용**됩니다.


`@Composable`을 통해 선언이나 표현식의 타입을 변경하는 것은 대상에게 `메모리`를 부여하는 것을 의미합니다. **즉, remember를 호출하고 Composer 및 슬롯 테이블을 활용할 수 있는 능력을 의미**합니다. 또한, Composable의 본문 내에서 구동된 이펙트들(effects)이 준수할 수 있는 라이프사이클을 제공합니다. (가령, recomposition이 수행되어도 기존 작업 유지하기 등) **Composable 함수들은 메모리에 보존 될 수 있도록 각각의 정체성(ID 값)을 할당받고, 완성된 트리에서 위치(앞에서 다룬 위치 기억법과 연관됨)가 지정**됩니다. **즉, Composable 함수들은 노드를 composition으로 방출하고 CompositionLocals를 처리할 수 있습니다.**

> 요약: Composable 함수는 실행 시 트리에 내보내지는 노드로 데이터를 매핑하는 것을 나타냅니다. 이 노드는 UI 노드일 수도 있고, 우리가 Compose Runtime을 사용하여 소비하는 라이브러리에 따라 다른 성격의 노드일 수도 있습니다. Compose Runtime은 특정 사용 사례나 의미론에 묶이지 않은 일반적인 유형의 노드로서 동작합니다. 이 주제는 Compose에 대한 여러분들의 이해가 더 풍부해질 때쯤 책의 끝 부분에서 자세히 다룰 예정입니다.


## 요약
* `@Composable` 어노테이션은 단순한 표식이 아니라, Compose 컴파일러에 의해 함수의 **타입 자체를 변경하는 변환**을 일으킵니다. 이는 새로운 파일만 생성하는 일반적인 어노테이션 처리기와 근본적으로 다릅니다.
* 타입이 변경된 컴포저블 함수는 **"메모리"를 부여받아**, `remember`를 사용하여 값을 기억하고 `Composer` 및 슬롯 테이블을 활용할 수 있는 능력을 얻게 됩니다.
* 또한, 이 변환은 컴포저블에 **고유한 정체성(ID)과 위치**를 부여하고, 부작용(side-effects)이 따를 수 있는 **생명주기**를 제공하며, UI 트리에 **노드를 방출(emit)** 할 수 있게 합니다.
* 궁극적으로 `@Composable` 함수는 입력된 **데이터를 UI 트리(또는 다른 종류의 트리)에 포함될 노드로 매핑(mapping)** 하는 역할을 수행합니다.
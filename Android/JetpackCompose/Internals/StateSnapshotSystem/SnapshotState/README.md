# 스냅샷 상태란 (What snapshot state is)

## 개요

**스냅샷 상태**(Snapshot State)는 **변경 사항을 기억하고 관찰할 수 있는 분리된 상태**를 의미합니다. 스냅샷 상태는 다음과 같은 함수를 호출할 때 얻게 됩니다:

- `mutableStateOf`
- `mutableStateListOf`
- `mutableStateMapOf`
- `derivedStateOf`
- `produceState`
- `collectAsState`

이런 모든 호출은 `State` 타입을 반환하며, 개발자들은 이를 흔히 **스냅샷 상태**라고 부릅니다.

## 상태 스냅샷 시스템

스냅샷 상태는 **Compose Runtime**에 의해 정의된 **상태 스냅샷 시스템**(State Snapshot System)의 일부이기 때문에 이와 같은 이름이 지어졌습니다. 이 시스템은 다음을 담당합니다:

- 상태 변경 모델링
- 변경 전파 조정

이는 독립적인 형태로 작성되어 있어, 이론적으로 관찰 가능한 상태에 의존하고자 하는 다른 라이브러리에서도 사용될 수 있습니다.

## 자동 추적 메커니즘

변경 전파와 관련하여 중요한 점은 **모든 Composable 함수의 선언과 표현식이 Jetpack Compose 컴파일러에 의해 래핑되어 본문 내에서 모든 스냅샷 상태 읽기를 자동으로 추적**한다는 것입니다.

```mermaid
graph LR
  A[Composable 함수] --> B[상태 읽기]
  B --> C[컴파일러 추적]
  C --> D[상태 변경 감지]
  D --> E[RecomposeScope 무효화]
  E --> F[Recomposition 트리거]
```

이것이 스냅샷 상태가 자동으로 관찰되는 방식입니다. 목표는 Composable이 읽는 상태가 달라질 때마다, 런타임이 Composable의 `RecomposeScope`를 **무효화**(invalidation)하여 다음 recomposition에서 다시 실행되도록 하는 것입니다.

이는 Compose에서 제공하는 인프라 코드이므로 클라이언트 코드베이스에는 필요하지 않습니다. Compose UI와 같은 런타임 클라이언트는 무효화 및 상태 전파가 수행되는 방식이나 recomposition이 트리거되는 방식에 대해 완전히 독립적일 수 있으며, 해당 상태와 함께 작동하는 구성 요소인 Composable 함수를 제공하는 데에만 집중할 수 있습니다.

## 상태 격리 (State Isolation)

그러나 스냅샷 상태는 recomposition을 트리거하기 위해 변경 사항을 자동으로 알리는 것만 하는 것은 아닙니다. **스냅샷**이라는 단어는 **상태 격리**(State Isolation)라는 매우 중요한 이유의 일부를 나타내는 이름입니다. 이것은 **동시성의 맥락에서 우리가 적용하는 격리 수준**을 의미합니다.

### 동시성 문제

스레드 간에 가변 상태를 처리하는 것을 상상해 보세요. 이는 금세 혼란스러움을 유발할 수 있습니다. 상태의 무결성을 보장하기 위해 엄격한 조정과 동기화가 필요한데, 그 이유는 동시에 다른 스레드에서 상태를 읽거나 수정할 수 있기 때문입니다. 이것은 다음과 같은 문제를 유발합니다:

- 충돌
- 감지하기 어려운 버그
- **경쟁 상태**(Race Condition)

### 전통적인 해결 방법

| 접근 방식 | 설명 | 특징 |
|---------|------|------|
| **불변성** | 생성된 후에는 수정할 수 없는 데이터 | 동시성 시나리오에서 완전히 안전 |
| **행위자 시스템** (Actor System) | 스레드 간 상태 격리에 중점 | 자신의 상태 사본을 보관하고 메시지를 통해 통신 |

전통적으로 프로그래밍 언어는 이를 다양한 방식으로 처리해 왔으며 그중 하나가 **불변성**이었습니다. 불변 데이터는 생성된 후에는 수정할 수 없으므로 동시성 시나리오에서 완전히 안전합니다.

또 다른 유효한 접근 방식은 **행위자 시스템**(Actor System)이 될 수 있습니다. 이 시스템은 **스레드 간 상태 격리**에 중점을 둡니다. 행위자는 자신의 상태 사본을 보관하고 메시지를 통해 통신 및 조정이 이루어집니다. 이 상태가 가변적인 경우 전역 프로그램 상태를 일관되게 유지하려면 일부 조정이 필요합니다.

> **Compose 스냅샷 시스템은 행위자 시스템을 기반으로 하지 않지만, 실제로는 이 접근 방식에 더 가깝습니다.**

## Compose의 가변 상태 처리

**Jetpack Compose는 가변적인 상태를 활용**하므로 Composable 함수가 상태 업데이트에 자동으로 반응할 수 있습니다. 라이브러리는 불변 상태만으로는 의미가 없습니다. 이는 여러 스레드에서 구성이 가능하기 때문에 동시성 시나리오에서 상태 공유 문제를 해결해야 함을 의미합니다.

이에 대한 Compose의 접근 방식은 **상태 스냅샷 시스템을 활용**하는 것이며, 다음을 기반으로 합니다:

- 상태 격리
- 변경 사항 전파

이를 통해 **스레드 전체에서 가변적인 상태로 안전하게 작업**할 수 있습니다.

## 동시성 제어 시스템

스냅샷 상태 시스템은 안전한 방식으로 스레드 전체에서 상태를 조정해야 하기 때문에 [동시성 제어 시스템](https://en.wikipedia.org/wiki/Concurrency_control)을 사용하여 모델링됩니다. 동시 환경에서 공유가 가능한 가변적인 상태 관리는 쉬운 일이 아니며, 라이브러리의 실질적인 사용 사례와는 관계없이 일반적인 문제입니다.

## State 인터페이스

이번 장의 소개를 완료하기 전에, 모든 스냅샷 상태 객체가 구체화하는 `State` 인터페이스를 살펴보는 것이 많은 도움이 됩니다.

### State 인터페이스 코드

```kotlin
@Stable
interface State<out T> {
  val value: T
}
```

### @Stable 어노테이션의 의미

**Jetpack Compose는 설계상 안정적인 구현체만 제공하고 사용하므로**, 이 인터페이스는 `@Stable` 어노테이션으로 마킹되어 있습니다. 간단히 요약하자면, 이는 이 인터페이스의 구현체가 반드시 아래 조건들을 보장해야 함을 의미합니다:

1. **일관된 equals 결과**
   - 두 State 사이의 equals 결과는 일관성이 있어야 합니다
   - 동일한 두 인스턴스를 비교할 때 항상 동일한 결과를 반환합니다

2. **변경 알림**
   - 해당 타입의 public 프로퍼티(`value`)가 변경되면 composition이 해당 사실을 전달받습니다

3. **안정적인 프로퍼티 타입**
   - 모든 public 프로퍼티 타입 또한 안정적이어야 합니다(`value`)

이러한 프로퍼티는 실제로 스냅샷 상태가 무엇인지 나타냅니다. 다음 섹션에서는 언급된 규칙 중 하나에 따라 스냅샷 상태 객체가 작성(수정)될 때마다 composition에 해당 사실을 어떻게 알리는지에 대하여 살펴봅니다.

## 참고 자료

이에 대한 아이디어 중 일부를 소개하는 [Zach Klipp의 게시물](https://dev.to/zachklipp/a-historical-introduction-to-the-compose-reactive-state-model-19j8)을 읽어보시기를 적극 추천드립니다.

## 다음 단계

이제 동시성 제어 시스템에 대해 배워보겠습니다. Jetpack Compose 상태 스냅샷 시스템이 왜 이런 방법으로 모델링되었는지 이해하시는 데 많은 도움이 될 것입니다.

---

## 요약

- **스냅샷 상태**는 변경 사항을 기억하고 관찰할 수 있는 분리된 상태로, `mutableStateOf` 등의 함수를 통해 생성됩니다
- **Compose Runtime**의 상태 스냅샷 시스템은 상태 변경과 변경 전파를 모델링하고 조정하는 독립적인 시스템입니다
- Composable 함수는 **컴파일러에 의해 자동으로 래핑**되어 스냅샷 상태 읽기를 추적하며, 상태 변경 시 `RecomposeScope`를 무효화하여 recomposition을 트리거합니다
- **상태 격리**는 동시성 환경에서 여러 스레드가 가변 상태를 안전하게 처리할 수 있도록 하는 핵심 개념입니다
- Compose는 **가변 상태를 활용**하면서도 동시성 제어 시스템을 통해 스레드 간 상태 충돌과 경쟁 상태를 방지합니다
- `State` 인터페이스는 `@Stable` 어노테이션으로 마킹되어 있으며, 일관된 equals 결과, 변경 알림, 안정적인 프로퍼티 타입을 보장해야 합니다
- 전통적인 동시성 처리 방법(불변성, 행위자 시스템)과 달리, Compose는 상태 격리와 변경 전파를 기반으로 한 독자적인 접근 방식을 사용합니다
# Composable 함수의 색깔 (The color of Composable functions)

Composable 함수는 표준 함수(Composable이 아닌 함수)와는 다른 제약과 기능을 가집니다. Composable 함수들은 다른 타입을 가지며(이에 대해서는 나중에 더 자세히 다룰 예정입니다), 매우 구체적인 관심사를 모델링합니다. **표준 함수와 Composable 함수는 서로 어떻게든 별개의 기능 범주를 나타낸다는 점**에서 `함수 컬러링`이라는 개념으로 차이점을 이해할 수 있습니다.


`함수 컬러링`은 **Google의 Dart 팀, Bob Nystrom이 2015년에 작성한 “What color is your function?”이라는 블로그 포스트에서 소개된 개념**입니다. Bob은 비동기(async)와 동기(sync) 함수가 잘 결합(compose)되지 않는다고 설명했는데, 동기 함수에서 비동기 함수를 호출할 수 없기 때문입니다. **이를 해결하기 위해 일부 라이브러리와 언어에서는 Promise와 async/await를 도입했습니다. 이는 함수의 결합을 다시 가져오려는 시도였으며, Bob은 이 두 가지 함수 범주를 다른 “함수 색상(function coloring)”으로 묘사**했습니다.


Kotlin에서 suspend는 비동기 함수와 동기 함수의 결합 문제를 해결하려고 합니다. 그러나 **suspend 함수 역시 채색된(colored)** 것으로 간주됩니다. 왜냐하면 **suspend 함수는 다른 suspend 함수에서만 호출될 수 있기 때문**입니다. 표준 함수와 suspend 함수를 혼합하여 프로그램을 작성하는 것은 ad-hoc 통합 메커니즘(가령, 코루틴의 시작점)이 필요하며, 이러한 함수의 혼합은 개발자에게 투명하게 다가오지 않습니다.


이런 제약은 예상된 것입니다. 우리는 본질적으로 매우 다른 개념을 나타내는 두 범주의 함수를 모델링하고 있습니다. 이는 두 가지 언어를 동시에 사용하는 것과 같습니다. **즉각적인 결과를 계산하기 위한 연산(동기)**과 **결과를 제공하기 까지 시간이 좀 더 걸리는 연산(비동기)**이 있습니다,


Jetpack Compose에서 Composable 함수의 경우도 비슷합니다. 우리는 **표준 함수에서 Composable 함수를 호출할 수 없습니다. 그렇게 하려면 통합점이 필요합니다(예를들어 Composition.setContent 함수와 같은).** Composable 함수는 표준 함수와 완전히 다른 목표를 가지고 있습니다. **Composable 함수는 프로그램 로직을 작성하기 위해 설계된 것이 아니라 노드 트리의 변경사항을 기술하기 위한 것**입니다.


Composable 함수의 장점 중 하나는 논리적으로 UI를 작성할 수 있다는 것입니다. 이 말은 즉, 표준 함수에서 Composable 함수를 호출해야하는 경우도 있다는 뜻입니다. 가령, 아래의 예시를 살펴볼 수 있습니다.

```kotlin
@Composable
fun SpeakerList(speakers: List<Speaker>) {
  Column {
    speakers.forEach {
      Speaker(it)
    }
  }
}
```

Speaker Composable 함수는 forEach 람다에서 호출되는데, 컴파일에 전혀 문제가 없습니다. 어떻게 다른 색상의 함수를 혼용할 수 있을까요?

그 이유는 바로 `인라인(inline)` 때문입니다. **컬렉션 연산자는 인라인으로 선언되어 있기 때문에 호출한 부분에 람다식을 inline 시켜 마치 간접 호출이 없는 것처럼 효과적으로 만듭니다.** 위의 예시에서 `Speaker` Composable 함수의 호출은 `SpeakerList` 본문 내 인라인 되며, 둘 다 Composable 함수이기에 이는 허용됩니다. **inline을 활용하여, 우리는 “함수 컬러링” 문제를 우회하고 Composable 로직을 작성할 수 있게 됩니다. 이로써, 트리는 오직 Composable 함수들로만 구성**됩니다.


### 그런데, `함수 컬러링`은 정말 문제가 될까요?


만약 우리가 두 유형을 결합하는데 있어 계속하여 한 유형에서 다른 유형으로 넘나들어야 한다면 문제가 될 수 있습니다. 그러나 suspend나 @Composable에는 이런 문제가 해당되지 않습니다. **두 메커니즘 모두 통합점을 요구하며, 해당 지점 이후에는 완전히 채색된 콜 스택을 얻게 됩니다. 이는 컴파일러와 런타임이 채색된 함수를 다르게 처리하고, 표준 함수로는 불가능했던 고급 언어 기능을 활성화할 수 있다는 점에서 이득을 취할 수 있습니다.**


Kotlin에서 `suspend 수정자`를 함수에 추가함으로써 **매우 관용적이고 풍부한 방식으로 비동기 non-blocking 프로그램을 모델링**할 수 있습니다. 반면, `@Composable 어노테이션`은 **표준함수가 재시작할 수 있는(restartable), 생략할 수 있는(skippable), 그리고 반응형(reactive)과 같이 Kotlin의 표준함수에는 없는 기능**을 가지도록 만듭니다.


## 요약
* **함수 컬러링(Function Coloring)** 은 서로 다른 종류의 함수(예: 동기/비동기)가 직접적으로 호출될 수 없는 별개의 "색깔"을 갖는다는 개념입니다.
* 코틀린의 **`suspend` 함수**와 **`@Composable` 함수**는 모두 이러한 "색깔"을 가진 함수입니다. 각각은 같은 종류의 함수 내에서만 호출될 수 있으며, 일반 함수와 연결되기 위해서는 `launch`나 `setContent`와 같은 진입점(bridge)이 필요합니다.
* `forEach`와 같은 **`inline` 함수**의 람다 내에서 컴포저블을 호출할 수 있는 이유는, `inline` 특성으로 인해 코드가 호출 지점에 삽입되어 결과적으로 같은 "색깔"의 컨텍스트를 유지하기 때문입니다.
* 이러한 "컬러링"은 문제가 아니라 **장점**입니다. 컴파일러가 "색깔"이 있는 함수들을 특별하게 취급하여, `suspend` 함수에는 **비동기 논블로킹** 특성을, `@Composable` 함수에는 **재시작(restartable) 및 건너뛰기(skippable)** 와 같은 강력한 기능을 부여할 수 있게 합니다.
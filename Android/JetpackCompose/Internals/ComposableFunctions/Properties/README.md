# Composable 함수의 속성 (Properties of Composable functions)

함수에 @Composable 어노테이션을 추가하는 것은 여러가지 의미를 내포하고 있습니다. @Composable 어노테이션은 해당 어노테이션이 적용된 함수나 표현식의 타입을 효과적으로 변경하며, 다른 타입과 마찬가지로 해당 타입에 일부 제약 사항이나 특성을 부여합니다. 이러한 특성들은 Jetpack Compose와 고도로 밀접한 관련이 있으며, Compose의 라이브러리들이 제 기능을 하도록 하는 데 아주 중요한 역할을 합니다.


**Compose Runtime**은 Composable 함수가 사전에 정의된 특성을 준수하도록 가정하기 때문에, 병렬적인 Composition, 우선순위에 따른 임의의 Composition 정렬, 스마트 Recomposition, 또는 위치 기억법(positional memoization) 등과 같은 다양한 런타임 최적화 기법을 포함하고 있습니다. 

> 일반적으로 런타임 최적화는 런타임이 실행해야 하는 코드에 대해 어느 정도 ‘확실성’을 가질 수 있을 때만 가능하므로, 런타임은 사전에 특정 조건 및 동작을 추론할 수 있습니다. 이를 통해 방금 이야기한 ‘확실성’을 활용하여 다양한 실행 전략(execution strategies) 또는 평가 기법(evaluation techniques)에 따라 Composable 함수를 실행하거나 다른 말로 “소비“할 수 있는 기회가 열립니다. <br/> 이러한 ‘확실성’의 예는 Composable 함수 내에서 다른 요소들 간의 관계가 될 수 있습니다. 각 요소들이 서로 종속적인가요 아니면 독립적인가요? 이들을 병렬로 실행하거나 서로 다른 순서로 실행해도 프로그램 결과에 영향을 미치지 않을까요? 우리는 각각의 최소 단위의 논리를 완전히 고립된 단위(unit)로 해석할 수 있을까요?

## 요약
* `@Composable` 어노테이션은 함수에 특별한 속성과 제약을 부여하여 타입을 변경하며, 이는 Compose 시스템이 올바르게 작동하기 위한 필수 조건입니다.
* **Compose 런타임**은 컴포저블 함수가 이러한 **정의된 속성을 준수한다고 가정**하고, 이 가정을 바탕으로 **다양한 런타임 최적화**를 수행합니다.
* 이러한 최적화에는 **스마트 리컴포지션(Smart Recomposition)**, **위치 기억법(positional memoization)**, 그리고 향후 가능할 **병렬 실행** 등이 포함됩니다.
* 런타임이 최적화를 수행할 수 있는 근본적인 이유는, 컴포저블 함수들이 서로에게 영향을 주지 않는 **독립적인 단위처럼 동작할 것이라는 '확실성'** 을 가질 수 있기 때문입니다.
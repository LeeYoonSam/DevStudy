# 네트워크에서 이미지를 로드하는 방법

Jetpack Compose는 네트워크 이미지 로딩을 위한 내장 지원을 제공하지 않지만, **Coil**, **Glide**, **Landscapist**와 같은 서드파티(타사) 라이브러리를 사용하여 URL로부터 이미지를 효율적으로 로드하고 표시할 수 있습니다. 이러한 라이브러리들은 Jetpack Compose 또는 코틀린 멀티플랫폼과 잘 통합되며 캐싱 및 플레이스홀더 처리와 같은 최적화 기능을 제공합니다.

사용자 정의 이미지 로딩 시스템을 구현하는 것도 가능하지만, 여기에는 네트워크에서 이미지 다운로드, 리사이징, 캐싱, 렌더링, 효율적인 메모리 관리와 같은 여러 복잡한 작업을 처리하는 것이 포함됩니다. 이러한 측면들은 부드러운 성능과 최소한의 리소스 소비를 보장하기 위해 신중한 최적화가 필요합니다. 이러한 어려움 때문에, 캐싱, 변환, 비동기 로딩에 대한 내장 지원을 갖춘 잘 최적화되고 기능이 풍부한 솔루션을 제공하는 기존 이미지 로딩 라이브러리를 사용하는 것이 일반적으로 권장됩니다.

-----

## Coil

[**Coil**](https://github.com/coil-kt/coil)은 Jetpack Compose와 코틀린 멀티플랫폼에 최적화된 이미지 로딩 라이브러리입니다. 완전히 코틀린으로 작성되었으며, 노출된 API는 코틀린 친화적입니다. 주목할 만한 점은 Coil이 OkHttp 및 코루틴과 같이 이미 안드로이드 프로젝트에서 널리 사용되는 다른 라이브러리를 활용하기 때문에 대안들보다 더 가볍다는 것입니다. Coil은 또한 Jetpack Compose를 지원하며, 변환, GIF 애니메이션 지원, SVG 지원, 비디오 프레임 지원과 같은 유용한 기능들을 제공합니다.

```kotlin
AsyncImage(
    model = "https://example.com/image.jpg",
    contentDescription = null,
)
```

-----

## Glide

[**Glide**](https://github.com/bumptech/glide)는 안드로이드에서 널리 사용되는 이미지 로딩 라이브러리입니다. Compose를 지원하지만, 2023년 9월 기준으로 Compose 통합은 베타 상태에 머물러 있으며 추가 업데이트를 받지 못했습니다. Glide는 GIF 애니메이션 지원, 플레이스홀더, 변환, 캐싱 및 효율적인 리소스 재사용과 같은 유용한 기능들을 제공하여 안드로이드 애플리케이션에서 이미지를 처리하는 데 있어 견고한 선택지입니다.

```kotlin
GlideImage(
  model = myUrl,
  contentDescription = getString(R.id.picture_of_cat),
  modifier = Modifier.padding(padding).clickable(onClick = onClick).fillParentMaxSize(),
)
```

> 💡 **재미있는 사실:** Glide는 이전에 Google에서 근무했던 단 한 명의 엔지니어에 의해 유지보수되었습니다. 그러나 해당 유지보수자가 다른 회사로 이직한 이후, 라이브러리는 2023년 9월 이래로 최소한의 유지보수만 이루어지고 새로운 릴리스가 없습니다.

-----

## Landscapist

[**Landscapist**](https://github.com/skydoves/landscapist)는 Glide, Coil 또는 Fresco의 코어를 사용하여 네트워크나 로컬 소스로부터 이미지를 효율적으로 가져오고 표시하도록 설계된 Jetpack Compose 및 코틀린 멀티플랫폼 이미지 로딩 라이브러리입니다. 리컴포지션 오버헤드를 줄이는 데 신중한 고려를 기울여 Jetpack Compose에서의 성능에 최적화되어 있습니다. 대부분의 컴포저블 함수는 **Restartable** 및 **Skippable**하여, Compose 컴파일러 메트릭에서 관찰된 바와 같이 향상된 리컴포지션 성능을 제공합니다.

또한, Landscapist는 **베이스라인 프로필**을 통해 성능을 향상시켜 더 빠른 시작 시간과 최적화된 런타임 실행을 보장합니다. 이 라이브러리는 `ImageOptions`, 상태 리스너, 사용자 정의 컴포저블 지원, 안드로이드 스튜디오 미리보기 호환성, 그리고 `ImageComponent` 및 `ImagePlugin`과 같은 모듈식 컴포넌트를 포함한 광범위한 사용자 정의 옵션을 제공합니다. 또한 플레이스홀더, 애니메이션(원형 노출, 크로스페이드), 변환(블러), 색상 팔레트 추출과 같은 고급 기능을 지원하여 Jetpack Compose에서 이미지 로딩을 위한 유연하고 효율적인 솔루션입니다.

```kotlin
GlideImage( // 또는 CoilImage, FrescoImage
    imageModel = { imageUrl },
    modifier = modifier,
    component = rememberImageComponent {
        // 이미지를 로드할 때 반짝이는 효과(shimmer)를 보여줍니다.
        +ShimmerPlugin(
            Shimmer.Flash(
                baseColor = Color.White,
                highlightColor = Color.LightGray,
            ),
        )
    },
    // 요청 실패 시 오류 텍스트 메시지를 보여줍니다.
    failure = {
        Text(text = "이미지 요청 실패.")
    }
)
```

💡 **재미있는 사실:** Landscapist는 이 책의 저자인 **skydoves (Jaewoong)** 에 의해 만들어졌고 활발하게 유지보수되고 있습니다. 이 라이브러리는 Jetpack Compose의 초기 개발자 프리뷰 단계였던 2020년에 처음 소개되어, Compose를 위해 특별히 설계된 가장 초기 이미지 로딩 솔루션 중 하나입니다.

-----

## 요약

각 라이브러리는 고유한 장점을 제공합니다.

  * **Glide**는 다재다능하며 네트워크 이미지를 쉽게 처리하는 데 널리 사용됩니다. Jetpack Compose를 지원하지만 몇 년 동안 베타 상태입니다.
  * **Coil**은 코틀린 중심적이고 가벼우며, 현대적인 안드로이드 개발 관행과 원활하게 통합됩니다. Compose와 코틀린 멀티플랫폼을 지원합니다.
  * **Fresco**는 메모리 집약적인 시나리오에 적합하며, 점진적 이미지 로딩, 이미지 파이프라인 및 더 복잡한 작업과 같은 고급 기능을 제공합니다.

프로젝트 요구 사항에 따라 라이브러리를 선택하되, 부드러운 사용자 경험을 제공하기 위해 항상 적절한 캐싱, 오류 처리 및 리소스 관리를 보장해야 합니다.

-----

## Q. Jetpack Compose에서 이미지를 로드하기 위해 어떤 서드파티(타사) 라이브러리를 사용해 보았으며, 그들 사이의 장단점(trade-offs)은 무엇인가요?

Jetpack Compose에서 이미지 로딩을 위해 주로 **Coil**과 **Glide**를 사용해 보았으며, 이 둘이 가장 널리 쓰이는 선택지입니다. **Coil**은 **코틀린 우선(Kotlin-first) 및 Compose와의 완벽한 통합**에서 장점을 가지는 반면, **Glide**는 **오랜 기간 검증된 안정성과 방대한 사용자층**을 자랑합니다. 어떤 라이브러리를 선택할지는 프로젝트의 기술 스택(코틀린 중심인지), 필요한 기능, 그리고 라이브러리의 현재 유지보수 상태에 따른 트레이드오프를 고려하여 결정합니다.

---
## 1. 주요 이미지 로딩 라이브러리 및 선택

Jetpack Compose에서 네트워크 이미지를 로드하기 위해 사용해 본 주요 서드파티 라이브러리는 **Coil**, **Glide**, 그리고 **Landscapist**입니다. 이들은 각각 뚜렷한 장단점을 가지고 있어 프로젝트의 요구사항에 따라 선택이 달라집니다.

* **Coil** 🚀: 현대적인 코틀린 및 Compose 프로젝트를 위한 첫 번째 선택지.
* **Glide** 🦅: 오랜 기간 검증된 안정성이 중요한 대규모 프로젝트의 선택지.
* **Landscapist** 🎨: 고도의 UI 커스터마이징과 성능 최적화가 필요할 때 고려하는 선택지.

---
## 2. 라이브러리별 장단점(Trade-offs) 비교

### 🚀 Coil (Image-loading for Kotlin's Coroutines)

#### 장점
* **코틀린 우선(Kotlin-first):** 코루틴을 기반으로 구축되어 비동기 처리가 매우 자연스럽고, 코틀린 확장 함수(extension functions)를 통해 API가 간결하고 직관적입니다.
* **가벼움:** OkHttp, 코루틴 등 이미 많은 안드로이드 프로젝트에서 사용 중인 라이브러리들을 재활용하므로, 라이브러리 자체의 용량이 비교적 가볍습니다.
* **최신 기술 지원:** Jetpack Compose, 코틀린 멀티플랫폼(KMP) 등 최신 안드로이드 기술 스택을 가장 적극적으로 지원하며 활발하게 유지보수되고 있습니다.
* **성능:** 현대적인 아키텍처를 기반으로 하여 일반적으로 매우 빠르고 효율적인 성능을 보여줍니다.

#### 단점
* **상대적으로 짧은 역사:** Glide에 비해 커뮤니티 규모나 프로덕션 환경에서 검증된 기간이 상대적으로 짧을 수 있습니다. (하지만 현재는 사실상 많은 현대 앱에서 표준으로 자리 잡고 있습니다.)

### 🦅 Glide

#### 장점
* **안정성 및 신뢰성:** 수많은 대규모 프로덕션 앱에서 오랜 기간 사용되며 안정성과 신뢰성이 검증되었습니다.
* **방대한 기능 및 문서:** GIF 및 비디오 썸네일 지원, 정교한 캐싱 전략, 리소스 풀링 등 매우 다양한 기능을 제공하며 관련 자료와 커뮤니티의 지원이 풍부합니다.
* **성숙한 API:** API가 오랫동안 안정적으로 유지되어 왔으며, 기존 뷰 시스템과의 통합 경험이 많습니다.

#### 단점
* **유지보수 상태:** 이전 정보에 따르면, 주 유지보수자의 이직 이후 업데이트가 더뎌져 미래 기술 지원에 대한 우려가 있을 수 있습니다.
* **Compose 통합:** 공식적인 Compose 지원 라이브러리가 오랫동안 베타(beta) 상태에 머물러 있습니다.
* **상대적 무거움:** 자바 기반으로 시작하여, 코틀린 중심의 Coil에 비해 다소 무겁거나 보일러플레이트 코드가 더 필요하게 느껴질 수 있습니다.

### 🎨 Landscapist

#### 장점
* **유연성 및 추상화:** 이미지 로딩의 핵심 엔진으로 **Glide, Coil, 또는 Fresco 중 하나를 선택**하여 사용할 수 있는 독특한 구조를 가집니다. 이를 통해 프로젝트에 맞는 로딩 엔진을 사용하면서 Landscapist의 추가적인 기능을 활용할 수 있습니다.
* **Compose 최적화:** 리컴포지션 최적화(대부분의 컴포저블이 Skippable/Restartable)나 베이스라인 프로필 적용 등 처음부터 **Compose 성능에 매우 집중**하여 설계되었습니다.
* **풍부한 UI 효과:** 이미지 로딩 상태(로딩 중, 실패, 성공)에 따라 Shimmer 효과, 크로스페이드 애니메이션, 플레이스홀더 등을 플러그인 형태로 매우 쉽게 추가할 수 있어 UI 커스터마이징이 강력합니다.

#### 단점
* **추가적인 학습 곡선:** Glide나 Coil 위에 한 단계의 추상화 계층이 더 있는 것이므로, 라이브러리 자체의 고유한 사용법(예: `ImageComponent`, `ImagePlugin`)을 추가로 익혀야 합니다.
* **커뮤니티 규모:** 다른 두 라이브러리에 비해 사용자층이 상대적으로 작아 관련 자료를 찾기 어려울 수 있습니다.

---
## 3. 요약: 어떤 라이브러리를 선택해야 할까?

* **새로운 코틀린 및 Jetpack Compose 프로젝트라면, `Coil`을 가장 먼저 추천합니다.** 현대적인 기술 스택과 가장 잘 맞고, 가볍고, 성능이 우수하며, 가장 활발하게 유지보수되고 있기 때문입니다.
* **기존에 `Glide`를 깊게 사용하고 있는 대규모 레거시 프로젝트를 마이그레이션하는 경우,** 즉시 전환하는 대신 `Glide`의 Compose 버전을 사용하여 점진적으로 전환하는 것이 안정적인 방법일 수 있습니다.
* **이미지 로딩 상태에 따른 매우 정교한 UI 제어(예: Shimmer 로딩 효과, 상세한 에러 처리)가 디자인의 핵심 요구사항이라면, `Landscapist`** 가 강력한 옵션이 될 수 있습니다.

결론적으로, 각 라이브러리의 장단점을 이해하고 프로젝트의 특성과 요구사항에 가장 부합하는 것을 선택하는 것이 중요합니다.
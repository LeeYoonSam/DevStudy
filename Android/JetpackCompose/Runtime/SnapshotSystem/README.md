# 스냅샷 시스템(Snapshot System)의 목적은 무엇인가요?

Jetpack Compose에서 상태 관리는 **스냅샷 시스템**에 의해 구동되며, 이는 특정 시점의 애플리케이션 내 모든 관찰 가능한(observable) 객체의 상태를 캡처합니다. **`Snapshot.takeSnapshot()`** 은 현재 상태의 **읽기 전용 스냅샷**을 만드는 방법을 제공하여, 값을 수정하지 않고 캡처된 값을 검사하거나 임시적으로 사용할 수 있게 합니다. 이 접근 방식은 상태 의존적인 기능을 디버깅하거나 구현할 때 안전성과 일관성을 보장합니다.

Compose의 스냅샷은 게임의 '저장 지점'과 같습니다. 특정 순간의 모든 관찰 가능한 데이터의 현재 상태를 나타냅니다. 스냅샷을 찍으면 모든 `MutableState` 객체의 상태가 고정되며, 프로그램의 다른 부분에서 발생하는 변경에 대해 걱정할 필요 없이 안전하게 그 값들을 읽을 수 있습니다.

## `Snapshot.takeSnapshot()` 사용하는 이유

`Snapshot.takeSnapshot()`의 주요 목적은 현재 상태의 읽기 전용 뷰를 만드는 것입니다. 이는 다음과 같은 경우에 특히 유용합니다.

  * 값을 변경하지 않고 현재 상태를 **디버깅하거나 분석**할 때.
  * 현재 상태를 기반으로 **계산이나 임시 작업을 수행**할 때.
  * 멀티스레드 환경에서 **스레드 안전하게 상태 값을 읽어야** 할 때.

## 예시: `Snapshot.takeSnapshot()` 사용하기

`MutableState`를 사용하는 `name` 프로퍼티를 가진 `User` 클래스를 만드는 예제를 살펴보겠습니다. 현재 상태의 스냅샷을 찍고, 그것이 어떻게 일관된, 읽기 전용 데이터 뷰를 제공하는지 보여드리겠습니다.

```kotlin
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.snapshots.Snapshot

class User {
    var name: MutableState<String> = mutableStateOf("")
}

fun main() {
    val user = User()

    // 초기 이름 설정
    user.name.value = "skydoves"

    // 현재 상태의 읽기 전용 스냅샷 찍기
    val snapshot = Snapshot.takeSnapshot()

    // 스냅샷을 찍은 후 상태 수정
    user.name.value = "Android"

    println("Current name: ${user.name.value}") // 출력: Android

    // 스냅샷에 진입하여 캡처된 값 읽기
    snapshot.enter {
        println("Snapshot name: ${user.name.value}") // 출력: skydoves
    }

    // 사용 후 스냅샷을 폐기하여 리소스 해제
    snapshot.dispose()
}
```

### 예시 설명

1.  **초기 상태:** `User` 클래스는 `MutableState`를 사용하는 `name` 프로퍼티를 가집니다. 초기값은 "skydoves"로 설정됩니다.
2.  **스냅샷 찍기:** `Snapshot.takeSnapshot()`을 사용하여 스냅샷을 찍습니다. 이 순간, `name` 값은 "skydoves"로 고정됩니다.
3.  **상태 수정:** 스냅샷을 찍은 후, `name`은 "Android"로 업데이트됩니다. 이 변경은 스냅샷에 영향을 주지 않습니다.
4.  **스냅샷 진입:** `enter` 함수는 그 블록 내에서 캡처된 상태를 일시적으로 복원합니다. 블록 안에서 `name`은 여전히 "skydoves"입니다.
5.  **스냅샷 폐기:** 리소스를 해제하기 위해 스냅샷을 폐기합니다.

## `Snapshot.takeSnapshot()`의 주요 특징

  * **읽기 전용 (Read-Only):** `Snapshot.takeSnapshot()`을 사용하여 찍은 스냅샷은 엄격하게 읽기 전용입니다. 스냅샷 내부에서 상태를 수정하려고 시도하면 `IllegalStateException`이 발생합니다.
  * **스레드 안전성 (Thread Safety):** 상태를 고정함으로써, 스냅샷은 동시 수정에 대한 걱정 없이 안전하게 값을 읽을 수 있도록 보장합니다.
  * **격리 (Isolation):** 스냅샷 외부에서 이루어진 상태 변경은 캡처된 상태에 영향을 주지 않습니다. 마찬가지로, 스냅샷은 프로그램의 현재 상태에 영향을 주지 않습니다.

## 읽기 전용 스냅샷 사용의 이점

  * **디버깅:** 스냅샷은 디버깅 목적으로 일관된 상태 뷰를 제공하여 문제 분석을 더 쉽게 만듭니다.
  * **일관성:** 스냅샷은 읽기 전용이므로, 검사하는 동안 실수로 상태를 수정하지 않도록 보장합니다.
  * **단순성:** 상태를 격리함으로써, 개발 중 의도치 않은 부작용을 유발할 위험을 줄입니다.

## 요약

`Snapshot.takeSnapshot()`은 특정 순간에 앱 상태의 읽기 전용 뷰를 만드는 강력한 도구입니다. 이는 디버깅, 상태 분석, 또는 실시간 상태에 영향을 주지 않고 일관된 데이터 스냅샷이 필요한 작업을 수행하는 데 특히 유용합니다. 이 API를 이해하고 활용함으로써 Jetpack Compose에서 더 안전하고 예측 가능한 애플리케이션을 구축할 수 있습니다. 스냅샷 시스템에 대한 더 깊은 이해를 원한다면, Zach Klippenstein의 [Introduction to the Compose Snapshot System](https://blog.zachklipp.com/introduction-to-the-compose-snapshot-system/) (영문)을 확인해 보세요.

-----

## 💡 프로 팁: 변경 가능한(mutable) 스냅샷은 어떻게 만드나요?

변경 가능한 스냅샷은 **`Snapshot.takeMutableSnapshot()`** API를 사용하여 만듭니다. 이 API는 **전역 상태에 즉시 영향을 주지 않고 안전하게 상태 값을 수정**할 수 있는 격리된 상태를 만들 수 있게 해줍니다. 이러한 변경 사항들은 `apply()` 함수를 사용하여 명시적으로 적용될 때까지 스냅샷에 로컬로 남아 있습니다. 이 메커니즘은 상태에 대한 변경 사항을 테스트, 실험 또는 임시적으로 적용할 때 특히 유용합니다.

변경 가능한 스냅샷은 애플리케이션 상태의 격리된 복사본입니다. 이를 통해 다음을 할 수 있습니다.

  * 전역 상태에 영향을 주지 않고 **로컬에서 상태를 수정**합니다.
  * 변경 사항을 커밋하기 전에 **안전하게 테스트하거나 유효성을 검사**합니다.
  * 필요한 경우 **원치 않는 변경 사항을 폐기**합니다.

`apply()`를 사용하여 스냅샷을 적용하면, 그 변경 사항이 전역 상태로 전파됩니다. 여러 스냅샷이 동일한 상태를 수정하는 경우, 시스템은 미리 정의된 또는 사용자 정의 충돌 해결 정책을 사용하여 충돌을 처리합니다.

## 예시: 변경 가능한 스냅샷 생성 및 사용

아래는 변경 가능한 스냅샷을 만들고 그 안에서 상태를 수정하는 예시입니다.

```kotlin
// 이전과 동일한 User 클래스 가정
class User {
    var name: MutableState<String> = mutableStateOf("")
}

fun main() {
    val user = User()
    user.name.value = "skydoves" // value로 접근해야 함
    println("Initial name: ${user.name.value}") // 출력: skydoves

    // 변경 가능한 스냅샷 생성
    val mutableSnapshot = Snapshot.takeMutableSnapshot()

    // 스냅샷 내부에서 상태 수정
    mutableSnapshot.enter {
        user.name.value = "Android"
        println("Inside snapshot: ${user.name.value}") // 출력: Android
    }

    // 전역 상태는 아직 영향을 받지 않음
    println("After snapshot but before apply: ${user.name.value}") // 출력: skydoves

    // 스냅샷을 적용하여 변경 사항을 전역 상태로 전파
    mutableSnapshot.apply()
    println("After applying snapshot: ${user.name.value}") // 출력: Android

    // 사용 후 스냅샷을 폐기하여 리소스 해제
    mutableSnapshot.dispose()
}
```

### 예시의 단계

1.  **초기 상태:** `User` 객체가 "skydoves"라는 초기 이름으로 생성됩니다.
2.  **스냅샷 생성:** `Snapshot.takeMutableSnapshot()`을 사용하여 변경 가능한 스냅샷이 생성됩니다.
3.  **스냅샷에서 상태 수정:** 스냅샷의 `enter` 블록 내에서 `name` 프로퍼티가 "Android"로 업데이트됩니다. 이 변경 사항은 스냅샷에 로컬이며 전역 상태에 영향을 주지 않습니다.
4.  **적용 전 상태 확인:** `enter` 블록을 빠져나온 후, 전역 상태는 변경되지 않은 채("skydoves") 남아 있습니다.
5.  **스냅샷 적용:** `apply()` 함수가 호출되어 스냅샷의 변경 사항을 전역 상태에 커밋합니다.

### 주요 요점

  * **격리:** 스냅샷 내에서 이루어진 변경은 적용될 때까지 로컬이며 격리됩니다.
  * **명시적 적용:** 변경 사항을 전역 상태에 커밋하려면 `apply()` 함수가 필요합니다.
  * **안전성:** 스냅샷을 적용하지 않기로 결정하면, 스냅샷이 폐기될 때 변경 사항도 함께 폐기됩니다.

### 변경 가능한 스냅샷의 장점

  * **상태 실험:** 실제 애플리케이션 상태에 영향을 주지 않고 안전하게 상태를 수정할 수 있습니다.
  * **되돌릴 수 있는 성질:** 스냅샷을 적용하지 않음으로써 원치 않는 변경 사항을 간단히 폐기할 수 있습니다.
  * **충돌 해결:** 여러 스냅샷이 동일한 상태를 수정할 때 충돌을 처리하기 위해 사용자 정의 정책을 사용할 수 있습니다.

### 언제 변경 가능한 스냅샷을 사용하나요?

  * 즉시 커밋하지 않고 상태 변경을 안전하게 테스트하고 싶을 때.
  * 실행 취소/다시 실행 기능과 같은 시나리오에서 임시 상태 수정을 관리할 때.
  * 격리 및 유효성 검사가 필요한 고급 상태 조작 기능을 작업할 때.

### 요약

`Snapshot.takeMutableSnapshot()`으로 변경 가능한 스냅샷을 생성하면 Jetpack Compose에서 상태 관리를 세밀하게 제어할 수 있습니다. 상태 변경을 격리함으로써, 전역 상태에 적용하기 전에 수정 사항을 실험, 테스트 및 유효성 검사할 수 있습니다. 이는 복잡한 상태 상호작용을 관리할 때 안전성, 유연성 및 일관성을 보장합니다.

-----

## Q. 어떤 시나리오에서 컴포저블에서 상태를 직접 관찰하는 대신 스냅샷(`Snapshot.takeSnapshot()`)을 찍는 것을 선호하겠습니까?

컴포저블에서 상태를 직접 관찰하는 것은 **상태 변경에 반응하여 UI를 자동으로 업데이트(리컴포지션)하기 위함**인 반면, `Snapshot.takeSnapshot()`은 **특정 시점의 상태를 '얼려서' 일관된 읽기 전용 복사본을 만들어**, 리컴포지션을 유발하지 않고 안전하게 데이터를 분석하거나 계산하는 데 사용됩니다.

---
### 1. 직접 관찰과의 핵심 차이: 반응성 vs. 일회성 읽기

* **직접 관찰 (`val state by ...`):**
    이 방식은 컴포저블과 상태 객체 간의 **지속적인 구독(subscription)** 관계를 만듭니다. 주된 목적은 상태가 변경될 때마다 **리컴포지션을 트리거**하여 UI를 최신 상태로 유지하는 것입니다. 이는 Jetpack Compose의 핵심적인 반응형(reactive) UI 구축 방식입니다.

* **`Snapshot.takeSnapshot()`:**
    이 함수는 특정 순간의 **일회성 스냅샷(snapshot)** 을 생성합니다. 이는 상태 변경을 구독하지 않으므로, 이 스냅샷을 사용한다고 해서 리컴포지션이 트리거되지 않습니다. 주된 목적은 여러 상태 값이 동시에 변경될 수 있는 상황에서 **특정 한 시점의 일관된 데이터 세트**를 안전하게 읽는 것입니다.

---
### 2. `Snapshot.takeSnapshot()` 사용이 선호되는 시나리오

컴포저블 내에서 상태를 직접 관찰하는 것이 일반적이지만, 다음과 같은 특별한 시나리오에서는 `Snapshot.takeSnapshot()`을 사용하는 것이 더 적합합니다.

#### 2.1. 복잡하고 일관성이 중요한 일회성 계산 🧮
* **시나리오:** 사용자가 "리포트 생성" 버튼을 클릭했을 때, 앱 전반에 흩어져 있는 여러 `State` 객체들의 현재 값을 모두 읽어와 하나의 리포트를 생성해야 하는 경우.
* **사용 이유:** `Snapshot.takeSnapshot()` 없이 여러 상태 값을 순차적으로 읽는 동안, 다른 스레드나 비동기 작업에 의해 일부 상태 값이 변경될 수 있습니다. 이는 일관성이 깨진 데이터(예: 일부는 이전 값, 일부는 새 값)로 리포트가 생성되는 결과를 낳을 수 있습니다.
* **해결책:** `Snapshot.takeSnapshot()`을 호출하면, 호출된 바로 그 시점의 모든 상태 값이 "고정"된 읽기 전용 복사본이 만들어집니다. `snapshot.enter { ... }` 블록 내에서 상태 값들을 읽으면, 외부에서 상태가 변경되더라도 항상 스냅샷을 찍었던 시점의 일관된 값을 안전하게 가져올 수 있습니다.

#### 2.2. 디버깅 및 상태 로깅 🐞
* **시나리오:** 특정 오류가 발생했거나 사용자가 버그를 신고했을 때, 문제의 원인을 파악하기 위해 그 순간의 애플리케이션 상태 전체를 캡처하여 로그로 남기고 싶을 때.
* **사용 이유:** `Snapshot.takeSnapshot()`을 사용하면 상태가 계속 변경되는 중에도 특정 한 순간의 데이터를 정확하게 포착하여 로깅하거나 분석할 수 있습니다. 이는 재현하기 어려운 버그를 디버깅하는 데 매우 유용합니다.

#### 2.3. (고급) 백그라운드 스레드에서의 안전한 상태 읽기 🧵
* **시나리오:** 백그라운드 스레드에서 현재 UI 상태 값을 참조하여 어떤 계산을 수행해야 할 때.
* **사용 이유:** Compose의 상태 객체는 메인 스레드에서 변경되는 것이 일반적입니다. 백그라운드 스레드에서 이 상태를 직접 읽으려고 하면, 읽는 도중에 메인 스레드에서 값이 변경되어 데이터 경쟁(race condition)이나 불일치 문제가 발생할 수 있습니다.
* **해결책:** 백그라운드 스레드에서 `Snapshot.takeSnapshot()`을 사용하면, 메인 스레드의 변경에 영향을 받지 않는, 특정 시점의 스레드 안전한(thread-safe) 읽기 전용 상태 복사본을 얻을 수 있습니다.

---
### 3. 결론

두 방식의 선택 기준은 명확합니다.

* **UI가 상태 변화에 따라 자동으로 업데이트되기를 원할 때**는 `val state by viewModel.myState.collectAsState()`와 같이 **상태를 직접 관찰**하는 방식을 사용합니다. 이것이 Compose UI를 만드는 99%의 경우에 해당하는 표준적인 방법입니다.
* **리컴포지션을 트리거하지 않으면서**, **특정 한 순간의 일관된 상태 값들**을 읽어서 계산, 분석, 또는 로깅과 같은 일회성 작업을 수행해야 할 때는 `Snapshot.takeSnapshot()`을 사용합니다.
# 상태(State)란 무엇이며 어떻게 관리하나요?

Jetpack Compose에서 [**상태(State)**](https://developer.android.com/develop/ui/compose/state) 는 **시간이 지남에 따라 변할 수 있는 모든 값**을 의미하며, 앱 UI의 동적인 측면을 나타냅니다. 앱에서의 상태 예시로는 네트워크 오류에 대한 스낵바 메시지, 양식의 사용자 입력, 또는 상호작용에 의해 트리거되는 애니메이션 등이 있습니다. 상태는 UI 업데이트를 직접적으로 구동하기 때문에 Compose와 같은 선언형 프레임워크에서 매우 중요합니다. Compose는 현재 상태를 기반으로 컴포저블을 평가하여 UI를 렌더링하고, 상태가 변경되면 해당 컴포저블을 다시 평가합니다.

-----

## 상태(State)와 컴포지션(Composition)

Jetpack Compose는 선언적 UI 접근 방식을 따릅니다. 이는 UI 업데이트가 오직 업데이트된 인수를 사용하여 컴포저블이 호출될 때만 발생한다는 것을 의미합니다. 이 동작은 컴포지션 생명주기와 긴밀하게 연결되어 있습니다.

  * **초기 컴포지션 (Initial Composition):** 컴포저블을 실행하여 UI 트리가 처음 생성되고 렌더링되는 과정입니다.
  * **리컴포지션 (Recomposition):** 상태가 변경될 때 트리거되며, 관련 컴포저블을 업데이트하여 새로운 상태를 반영하는 과정입니다.

Compose 런타임은 상태 변경을 자동으로 추적하고 UI를 업데이트하므로, 전통적인 안드로이드 뷰 시스템처럼 수동으로 `View.invalidate()`를 호출할 필요가 없습니다. 리컴포지션은 업데이트된 상태를 반영해야 하는 컴포저블 함수에 대해서만 트리거됩니다. 아래 예시는 상태 변경이 UI에 어떻게 자동으로 적용되는지 보여줍니다.

```kotlin
@Composable
fun HelloContent() {
    Column(modifier = Modifier.padding(16.dp)) {
        // remember와 mutableStateOf를 사용하여 상태를 선언하고 리컴포지션 간에 유지
        var name by remember { mutableStateOf("") }

        // name 상태가 비어있지 않을 때만 Text 표시
        if (name.isNotEmpty()) {
            Text(
                text = "Hello, $name!",
                modifier = Modifier.padding(bottom = 8.dp)
            )
        }

        // TextField는 name 상태를 표시하고, 값이 변경되면 onValueChange를 통해 name 상태를 업데이트
        TextField(
            value = name,
            onValueChange = { name = it },
            label = { Text("Name") }
        )
    }
}
```

여기서 `name` 상태가 변경되면(사용자가 `TextField`에 입력하면), `Text`와 `TextField` 컴포저블이 자동으로 업데이트되어 UI가 최신 상태와 동기화된 상태를 유지합니다.

-----

## Compose에서 상태 관리하기

Jetpack Compose는 상태를 효과적으로 관리하기 위한 여러 도구를 제공합니다.

### 1\. remember

초기 컴포지션 중에 객체를 메모리에 저장하고 리컴포지션 중에 이를 검색(기억)합니다.

```kotlin
var count by remember { mutableStateOf(0) }
```

### 2\. rememberSaveable

화면 회전과 같은 **구성 변경(configuration change) 시에도 상태를 유지**합니다. `Bundle`에 저장될 수 있는 타입과 함께 작동하며, 다른 타입의 경우 사용자 정의 saver 객체를 사용할 수 있습니다.

### 3\. mutableStateOf

값이 변경될 때 리컴포지션을 트리거하는 **관찰 가능한(observable) 상태 객체**를 만듭니다.

```kotlin
// 1. State 객체로 직접 사용
val mutableState = remember { mutableStateOf("") }
// 사용 시: mutableState.value

// 2. 위임된 프로퍼티로 사용 (가장 일반적)
var value by remember { mutableStateOf("") }
// 사용 시: value

// 3. 구조 분해 선언으로 사용
val (value, setValue) = remember { mutableStateOf("") }
// 사용 시: value, setValue(newValue)
```

-----

## 요약

상태(State)는 UI가 데이터 변경과 동기화된 상태를 유지하도록 자동 리컴포지션을 가능하게 하는 Jetpack Compose의 초석입니다. `State`가 효율적으로 리컴포지션을 트리거하기 때문에, 개발자는 수동으로 UI 계층 구조를 업데이트하고 다시 렌더링할 필요가 없습니다. 그러나 의도치 않은 리컴포지션이 발생하여 잠재적으로 성능을 저하시킬 수 있습니다. `State`가 어떻게 작동하는지 이해하는 것은 효율적이고 성능이 좋은 Compose 애플리케이션을 구축하는 데 매우 중요합니다.

-----

## Q. 상태는 리컴포지션과 어떻게 관련되며, 리컴포지션 중에는 어떤 일이 발생하나요?

Jetpack Compose에서 **상태(State)** 와 **리컴포지션(Recomposition)** 은 서로 뗄 수 없는, **"원인과 결과"** 의 관계에 있습니다. 간단히 말해, **상태의 변경이 리컴포지션을 유발하는 '원인(트리거)'** 이 되며, **리컴포지션은 그 변경된 상태를 UI에 반영하는 '결과'** 입니다.

---
### 1. 상태와 리컴포지션의 관계: "원인과 결과"

#### 1.1. 상태는 리컴포지션의 '트리거'입니다
Compose의 핵심 원칙은 **`UI = f(State)`** 입니다. 즉, UI는 현재 상태를 함수에 넣어 도출한 결과물입니다. 따라서 UI를 변경하는 유일한 방법은 상태를 변경하는 것이며, 상태가 변경되면 UI가 이를 반영하기 위해 리컴포지션이 발생합니다.

#### 1.2. 구독(Subscription) 모델: 상태 읽기와 종속성 기록
* **상태 읽기(구독):** `@Composable` 함수 내에서 `State<T>` 객체의 `.value` 속성을 읽는 순간, Compose 런타임은 해당 컴포저블이 이 `State` 객체에 **의존(subscribe)**하고 있음을 기록합니다.
* **종속성 추적:** 런타임은 어떤 컴포저블이 어떤 `State`를 읽었는지 모두 추적하여 종속성 그래프를 만듭니다.

#### 1.3. 알림(Notification) 모델: 상태 변경과 무효화
* **상태 쓰기(변경):** `State<T>` 객체의 `.value`에 새로운 값이 할당되면, `State` 객체는 자신을 구독하고 있는 모든 컴포저블에게 "내 값이 변경되었다"고 알립니다.
* **무효화(Invalidation):** 이 알림을 받은 Compose 런타임은 해당 컴포저블들을 "무효화"시킵니다. 이는 "이 컴포저블은 이제 오래된(stale) UI 정보를 가지고 있으므로 업데이트가 필요하다"고 표시하는 것과 같습니다.

---
### 2. 리컴포지션 중에 발생하는 일

리컴포지션은 단순히 UI 전체를 처음부터 다시 그리는 비효율적인 과정이 아닙니다. 매우 지능적이고 최적화된 방식으로 진행됩니다.

#### 2.1. 선택적이고 지능적인 재실행
리컴포지션의 가장 큰 특징은 **전체 UI 트리를 다시 빌드하는 것이 아니라, 오직 상태 변경의 영향을 받는 컴포저블만 선택적으로 다시 실행**한다는 것입니다.

#### 2.2. 리컴포지션 과정 (단계별)

1.  **리컴포지션 예약(Scheduling):**
    상태 변경으로 인해 무효화된 컴포저블들은 즉시 재실행되지 않습니다. Compose 런타임은 안드로이드의 `Choreographer`를 통해 다음 프레임을 그릴 시점에 리컴포지션을 실행하도록 **예약**합니다. 이는 짧은 시간 동안 여러 상태가 변경되더라도 단 한 번의 UI 업데이트로 묶어서 처리하여 효율성을 높입니다.

2.  **무효화된 컴포저블 재실행:**
    예약된 시점이 되면, 런타임은 무효화된 컴포저블 함수들을 다시 호출합니다. 이 함수들은 새로운 상태 값을 사용하여 UI의 일부를 다시 기술합니다.

3.  **불필요한 컴포저블 건너뛰기(Skipping):**
    리컴포지션 과정에서 Compose는 강력한 최적화를 수행합니다. 재실행 대상으로 고려되는 컴포저블이라도, **해당 함수에 전달되는 모든 파라미터가 이전 컴포지션 때와 동일하고 안정적(stable)이라면, Compose 런타임은 이 함수의 실행 자체를 건너뛰고** 이전 결과를 재사용합니다. 이것이 바로 '스마트 리컴포지션(Smart Recomposition)'의 핵심입니다.

4.  **UI 트리(컴포지션) 업데이트:**
    재실행된 컴포저블들은 UI 트리의 해당 부분을 새로운 정보로 업데이트합니다. 건너뛴 부분은 그대로 유지됩니다.

#### 2.3. 이후 단계로 전달
이렇게 리컴포지션(컴포지션 단계의 재실행)을 통해 업데이트된 UI 트리는 다음 단계인 **레이아웃(Layout)** 과 **그리기(Drawing)** 단계로 전달되어, 변경된 부분의 크기와 위치를 다시 계산하고 최종적으로 화면에 그리게 됩니다.

---
### 3. 결론: 효율적인 UI 업데이트 메커니즘

요약하자면, **상태와 리컴포지션의 관계**는 다음과 같습니다.

> **상태가 변경**되면 → 이 상태를 **구독(읽고 있던)** 하던 컴포저블들이 **무효화**되고 → 다음 프레임에 **리컴포지션이 예약**됩니다. → 리컴포지션 중에는 **오직 무효화된 컴포저블들만 재실행**되며(이마저도 입력값이 동일하면 건너뛸 수 있음) → 그 결과로 **UI 트리가 업데이트**되어 화면이 최신 상태를 반영하게 됩니다.

이러한 메커니즘은 UI가 항상 데이터 상태와 일관성을 유지하도록 보장하면서도, 불필요한 작업을 최소화하여 부드럽고 반응성이 뛰어난 사용자 경험을 제공하는 Jetpack Compose의 핵심적인 강점입니다.
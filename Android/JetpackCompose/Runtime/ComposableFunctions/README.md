# 컴포저블 함수의 생명주기 단계

컴포저블 함수는 **초기 컴포지션(Initial Composition), 리컴포지션(Recomposition), 그리고 컴포지션을 벗어남(Leaving the Composition)** 이라는 세 가지 주요 단계를 따르는 생명주기를 가집니다. 이는 Compose 런타임에 의해 관리되며, 상태 변경에 따라 UI를 효율적으로 생성, 업데이트, 그리고 정리하는 과정을 포함합니다.

컴포저블 함수는 안드로이드의 전통적인 뷰(View)나 액티비티(Activity)와 같은 전통적인 생명주기를 갖지 않습니다. 대신, Compose 런타임에 의해 구동되는 **컴포지션을 인식하는(composition-aware) 생명주기**를 따릅니다.

*(역자 주: 원문에 포함된 그림(Figure 27)은 컴포저블의 생명주기를 시각적으로 나타냅니다. 엔트리 -> 컴포지션/리컴포지션 -> 종료)*

이 생명주기는 컴포저블 함수가 UI 상태 변경에 따라 효율적으로 호출되고, 리컴포지션되며, 폐기되도록 보장합니다. 아래는 컴포저블 함수 생명주기의 주요 단계에 대한 설명입니다.

### 1. 초기 컴포지션 (Initial Composition) ➡️

이것은 컴포저블 함수가 처음 실행되는 단계입니다. 이 단계에서는 다음 작업이 수행됩니다.

  * 함수는 주어진 상태를 기반으로 **초기 UI 요소를 생성**합니다.
  * `LaunchedEffect`나 `remember`와 같은 **부작용(side-effect)들이 초기화**되고 향후 리컴포지션을 위해 기억됩니다.
  * **UI 계층 구조가 구축**되고 컴포지션 트리에 추가됩니다.

예를 들어, 다음 `Greeting` 함수는 주어진 `name` 파라미터 값에 대한 초기 컴포지션을 구성합니다.

```kotlin
@Composable
fun Greeting(name: String) {
    Text(text = "Hello, $name!")
}
```

### 2. 리컴포지션 (Recomposition) 🔄

리컴포지션은 컴포저블 함수가 의존하는 **상태가 변경될 때 발생**합니다. 리컴포지션 중에는 다음 작업이 수행됩니다.

  * 컴포지션 트리에서 **영향을 받는 부분만 리컴포지션**됩니다 (스마트 리컴포지션, Smart Recomposition).
  * Compose는 업데이트가 필요 없는 UI 트리의 부분은 **건너뛰는(skipping)** 방식으로 프로세스를 최적화합니다.
  * `remember`에 의해 관리되는 것과 같은 부작용들은 리컴포지션 간에 **유지**됩니다.

예를 들어, `count`가 변경되면 버튼 내의 `Text`만 리컴포지션됩니다.

```kotlin
@Composable
fun Counter() {
    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text(text = "Clicked $count times")
    }
}
```

### 3. 컴포지션을 벗어남 (Leaving the Composition) ⬅️

컴포저블 함수가 컴포지션에서 제거될 때(예를 들어, 다른 화면으로 이동할 때) 컴포지션을 벗어납니다. 이 단계에서는 다음 작업이 수행됩니다.

  * 컴포저블과 관련된 **모든 리소스가 자동으로 정리**됩니다.
  * `DisposableEffect`와 같은 부작용은 리소스를 **폐기(dispose)**합니다.
  * `rememberCoroutineScope`는 실행 중인 모든 코루틴 작업을 **안전하게 취소**합니다.

예를 들어, `DisposableEffect` 내에서 컴포저블이 컴포지션을 벗어날 때 `onDispose` 블록이 호출됩니다.

```kotlin
@Composable
fun DisposableExample() {
    DisposableEffect(Unit) {
        println("컴포지션 진입")
        onDispose {
            println("컴포지션 벗어남")
        }
    }
    Text(text = "사용 중인 컴포저블")
}
```

-----

## 컴포지션 생명주기의 핵심 요점

  * **컴포지션의 단계:** 컴포지션 생명주기는 초기 컴포지션, 리컴포지션, 폐기라는 세 가지 주요 단계로 구성됩니다. 첫 컴포지션은 컴포저블 함수가 컴포지션 트리에 진입할 때 발생하며, 리컴포지션은 상태 변경이 특정 UI 요소의 업데이트를 트리거할 때 발생합니다.
  * **건너뛰기와 최적화:** Compose는 변경되지 않은 함수들의 리컴포지션을 지능적으로 건너뛰어 불필요한 UI 업데이트를 줄입니다. 이는 `remember`, `derivedStateOf`, 안정적인 상태 관리와 같은 메커니즘을 통해 성능을 향상시키는 방식으로 달성됩니다.
  * **폐기와 정리:** 컴포저블 함수가 컴포지션을 벗어나면 UI 트리에서 제거됩니다. `LaunchedEffect`의 코루틴이나 `DisposableEffect`의 구독과 같이 부작용이 시작되었다면, 또는 `remember`를 사용하여 상태가 생성되었다면, 메모리 누수를 피하기 위해 컴포지션을 인식하여 적절히 정리되어야 합니다.

-----

## 요약

컴포저블 함수의 생명주기는 **초기 컴포지션**, **리컴포지션**, **컴포지션을 벗어남**이라는 세 가지 주요 단계로 구성됩니다. 각 단계는 효율적인 렌더링, 반응형 업데이트, 그리고 적절한 리소스 정리를 보장하는 데 중요한 역할을 합니다. 액티비티, 프래그먼트, ViewModel과 같은 전통적인 안드로이드 컴포넌트의 생명주기를 이해하는 것이 필수적인 것처럼, 컴포저블 함수의 생명주기를 올바르게 파악하는 것이 효율적인 UI 컴포넌트를 설계하는 핵심입니다.

-----

## Q. 컴포저블 함수의 생명주기 단계를 설명하고, 상태가 변경될 때 Compose가 리컴포지션을 어떻게 처리하는지 설명해주세요.

컴포저블 함수의 생명주기는 **초기 컴포지션**, **리컴포지션**, **컴포지션을 벗어남**이라는 세 가지 주요 단계로 구성됩니다. 상태가 변경되면, Compose는 해당 상태를 구독하던 컴포저블만 **선택적으로 다시 실행(리컴포지션)** 하여 UI를 효율적으로 업데이트합니다.

컴포저블 함수는 액티비티나 뷰와 달리 전통적인 생명주기 콜백(`onCreate`, `onStart` 등)을 갖지 않습니다. 대신, 컴포지션 트리에 추가되고, 업데이트되며, 제거되는 과정을 따릅니다.

### 1. 초기 컴포지션 (Initial Composition) ➡️
이것은 컴포저블 함수가 처음으로 호출되어 UI 트리에 추가되는 단계입니다.
* **실행:** 컴포저블 함수가 실행되고, 그 안의 UI 요소(Text, Button 등)들이 UI 트리에 노드로 추가됩니다.
* **상태 초기화:** `remember`나 `rememberSaveable`을 통해 상태가 초기화되고 메모리에 저장됩니다.
* **부작용 시작:** `LaunchedEffect`나 `DisposableEffect`와 같은 부작용 핸들러가 처음으로 실행됩니다.

### 2. 리컴포지션 (Recomposition) 🔄
컴포저블이 의존하는 **상태(`State`) 객체의 값이 변경될 때** 발생하는 업데이트 단계입니다.
* **재실행:** Compose 런타임은 상태 변경을 감지하고, 해당 상태를 구독(읽고 있던)하는 컴포저블 함수만 다시 호출합니다.
* **지능적 업데이트:** Compose는 변경이 필요한 부분만 다시 그리고, 입력값이 변경되지 않은 컴포저블은 실행을 건너뛰어(skip) 성능을 최적화합니다.
* **상태 유지:** `remember`로 저장된 상태는 리컴포지션 과정에서 그대로 유지됩니다.

### 3. 컴포지션을 벗어남 (Leaving the Composition) ⬅️
컴포저블이 더 이상 UI 트리에 포함되지 않을 때(예: 조건부 UI에서 조건이 `false`가 되거나 다른 화면으로 이동할 때) 발생하는 정리 단계입니다.
* **정리(Cleanup):** 컴포저블과 관련된 모든 리소스가 정리됩니다.
* **부작용 종료:** `LaunchedEffect`에서 실행 중이던 코루틴은 취소되고, `DisposableEffect`의 `onDispose` 블록이 호출되어 리스너 해제와 같은 정리 작업이 수행됩니다.

---
## 상태 변경 시 리컴포지션 처리 방식

Compose가 상태 변경에 따라 리컴포지션을 처리하는 과정은 매우 효율적이며, 다음과 같은 단계로 이루어집니다.

1.  **상태 구독 (State Subscription):**
    컴포저블 함수 내에서 `State` 객체의 `.value`를 읽는 순간, Compose 런타임은 해당 컴포저블이 그 상태를 **구독**하고 있음을 기록합니다. 즉, 어떤 컴포저블이 어떤 상태에 의존하는지 추적합니다.

2.  **상태 변경 및 무효화 (State Change and Invalidation):**
    `State` 객체의 `.value`가 새로운 값으로 업데이트되면, 런타임은 이 상태를 구독하고 있던 모든 컴포저블을 **"무효화(invalidate)"**시킵니다. 이는 "이 컴포저블들은 이제 오래된 정보를 가지고 있으므로 다음 프레임에 업데이트가 필요하다"고 표시하는 것과 같습니다.

3.  **선택적 리컴포지션 (Selective Recomposition):**
    다음 UI 업데이트 시점(다음 프레임)에, Compose 런타임은 무효화된 컴포저블들만 다시 실행합니다. 이때 **스마트 리컴포지션(Smart Recomposition)** 이라는 강력한 최적화가 적용됩니다.
    * **영향 범위 최소화:** 오직 상태를 직접 구독하던 컴포저블과 그 자식들만이 리컴포지션의 대상이 됩니다. 상태와 관련 없는 다른 부분은 전혀 영향을 받지 않습니다.
    * **건너뛰기 (Skipping):** 리컴포지션 대상이 된 컴포저블이라도, 함수에 전달되는 모든 파라미터가 이전과 동일하고 **안정적(stable)** 이라면, Compose는 해당 함수의 실행 자체를 건너뛰고 이전 결과를 재사용합니다.

이러한 과정을 통해 Compose는 UI가 항상 최신 상태를 반영하도록 보장하면서도, 불필요한 계산과 렌더링을 최소화하여 높은 성능을 유지합니다.
# Jetpack Compose의 안정성(Stability)과 성능의 관계

Jetpack Compose에서 **안정성(Stability)** 은 특정 클래스나 타입이 **동일한 입력에 대해 항상 일관된 결과를 생성**함을 보장하는 속성을 의미합니다. 안정적인 클래스나 함수는 리컴포지션(recomposition) 중에 여러 번 사용되더라도 예기치 않게 동작이 변경되지 않음을 보장합니다. 이러한 특성은 Jetpack Compose가 중복(불필요한) 리컴포지션 없이 UI 업데이트를 효율적으로 처리할 수 있도록 보장하는 데 매우 중요합니다.

리컴포지션은 이미 렌더링된 UI를 업데이트하기 위해 다양한 메커니즘을 통해 트리거됩니다. 이 중에서도, 컴포저블 함수의 파라미터 안정성은 Compose 런타임과 컴파일러가 리컴포지션이 필요한 시점을 결정하는 방식의 핵심 부분을 형성합니다.

Compose 컴파일러는 컴포저블 함수의 파라미터를 평가하여 **안정적(stable)** 또는 **불안정(unstable)** 으로 분류합니다. 이 분류는 Compose 런타임이 입력값의 변경에 따라 컴포저블 함수를 다시 렌더링해야 할지 결정하는 데 이 정보를 사용하므로, 리컴포지션을 효율적으로 관리하는 데 매우 중요합니다.

-----

## 안정적인(Stable) 타입과 불안정한(Unstable) 타입 이해하기

파라미터가 어떻게 안정적인지 또는 불안정한지로 분류되는지 궁금할 수 있습니다. 이 분류는 Compose 컴파일러에 의해 처리되며, 컴파일러는 컴포저블 함수의 파라미터 타입을 평가하고 다음 기준에 따라 안정성을 결정합니다.

### 안정적인 타입의 기준

  * `String`을 포함한 **기본(원시) 타입**은 예기치 않게 변경되지 않으므로 본질적으로 안정적입니다.
  * 외부 값을 캡처하지 않는 **함수 타입**(예: 람다 표현식, `(Int) -> String`) 또한 예측 가능한 동작으로 인해 안정적인 것으로 간주됩니다.
  * **불변(immutable)하고 안정적인 public 프로퍼티**로만 구성된 클래스, 특히 데이터 클래스는 안정적인 것으로 간주됩니다. 또한, `@Stable` 또는 `@Immutable`과 같은 안정성 어노테이션으로 명시적으로 표시된 클래스는 안정적인 것으로 인식됩니다. 이러한 어노테이션과 그 영향의 구체적인 내용은 다음 섹션에서 탐색할 것입니다.

예를 들어, 아래의 데이터 클래스를 상상해 볼 수 있습니다.

```kotlin
data class User(
    val id: Int,
    val name: String,
)
```

불변의 기본 프로퍼티로 구성된 `User` 데이터 클래스는 Compose 컴파일러에 의해 안정적인 것으로 인식됩니다.

-----

### 불안정한 타입의 기준

반면에, Compose 컴파일러는 다음 기준에 따라 특정 파라미터 타입을 불안정한 것으로 식별합니다.

  * **인터페이스 및 추상 클래스:** `List`, `Map` 또는 `Any`와 같은 타입은 컴파일 시점에 그 구현을 보장할 수 없기 때문에 불안정한 것으로 간주됩니다. 이 분류에 대한 근거는 나중에 섹션에서 자세히 설명할 것입니다.
  * **변경 가능한(Mutable) 프로퍼티를 가진 클래스:** 하나 이상의 변경 가능하거나 본질적으로 불안정한 public 프로퍼티를 포함하는 데이터 클래스는 불안정한 것으로 분류됩니다.

예를 들어, 다음 데이터 클래스를 고려해 보세요.

```kotlin
data class MutableUser(
    val id: Int,
    var name: String // 변경 가능한 프로퍼티가 이 클래스를 불안정하게 만듦
)
```

이 예에서 `MutableUser` 클래스는 변경 가능한 프로퍼티(`name`)의 존재로 인해 불안정한 것으로 간주됩니다.

> (역자 주: 원문 예시의 클래스 이름이 `User`로 되어 있으나 문맥상 `MutableUser`가 적합하여 수정하였습니다.)

비록 `MutableUser` 데이터 클래스가 주로 기본 프로퍼티를 포함하더라도, 변경 가능한 `name` 프로퍼티의 존재는 Compose 컴파일러가 이를 불안정한 것으로 분류하게 만듭니다. 이러한 분류는 클래스의 안정성이 모든 프로퍼티의 안정성을 총체적으로 평가하여 결정되기 때문에 발생합니다. 결과적으로, 단 하나의 변경 가능한 프로퍼티가 전체 클래스를 불안정하게 만들 수 있습니다.

-----

## 컴포저블 함수 추론

또 다른 중요한 개념인, 컴파일러가 컴포저블 함수 타입을 어떻게 추론하고 최적화하는지 탐색하는 것이 필수적입니다. 코틀린 컴파일러 플러그인으로서 Compose 컴파일러는 컴파일 타임에 개발자가 작성한 소스 코드를 분석합니다. 분석을 넘어, 효율적인 실행을 위해 컴포저블 함수의 고유한 요구 사항에 맞춰 원본 소스 코드를 수정합니다.

성능을 최적화하기 위해 컴파일러는 컴포저블 함수를 **Restartable**, **Skippable**, **Moveable**, **Replaceable**과 같은 분류로 나눕니다. 이 중에서 `Restartable`과 `Skippable` 타입은 리컴포지션에서 매우 중요하며, 이 토론에서는 그 역할들을 자세히 탐색할 것입니다.

  * **Restartable (재시작 가능):** `Restartable` 함수는 Compose 컴파일러에 의해 결정되는 컴포저블의 한 유형으로, 리컴포지션 과정의 기초를 형성합니다. 입력이나 상태가 변경될 때, Compose 런타임은 UI를 업데이트하기 위해 이러한 함수들을 다시 호출합니다. 대부분의 컴포저블 함수는 기본적으로 재시작 가능으로 간주되어, 런타임이 필요할 때마다 리컴포지션을 트리거할 수 있게 합니다.

  * **Skippable (건너뛰기 가능):** `Skippable` 함수는 **스마트 리컴포지션**에 의해 활성화되는 특정 조건 하에서 리컴포지션을 건너뛸 수 있습니다. 이 최적화는 특히 큰 함수 계층의 최상단에 있는 루트 컴포저블의 성능을 향상시키는 데 중요하며, 이들의 리컴포지션을 건너뛰면 하위 함수들의 호출을 피할 수 있습니다. 주목할 점은, 함수가 재시작 가능하면서 동시에 건너뛰기 가능할 수 있다는 것이며, 이는 필요할 때는 리컴포지션을 겪지만 조건이 허락할 때는 건너뛸 수 있음을 의미합니다.

-----

## 요약

Jetpack Compose의 안정성은 성능과 신뢰성에 직접적인 영향을 미치는 기초적인 개념입니다. 안정적인 타입을 사용하고 부작용을 피하도록 컴포저블 함수를 설계함으로써, 더 부드러운 리컴포지션과 최적화된 UI 경험을 보장할 수 있습니다. 안정성을 수용하면 Compose 런타임의 효율성을 최대한 활용하고 애플리케이션의 미래 호환성을 확보할 수 있습니다.

-----

## 💡 프로 팁: 스마트 리컴포지션(Smart Recomposition)이란?

안정성의 원칙과 Compose 컴파일러가 안정적인 타입과 불안정한 타입을 어떻게 구별하는지 탐색했으므로, 이러한 분류가 리컴포지션에 어떻게 영향을 미치는지 이해하는 것이 중요해집니다. Compose 컴파일러는 컴포저블 함수에 전달되는 파라미터의 안정성을 평가하며, Compose 런타임은 이 정보를 효율적인 리컴포지션 관리에 사용합니다.

클래스의 안정성이 결정되면, Compose 런타임은 **스마트 리컴포지션**이라는 메커니즘을 통해 이 정보를 활용합니다. 스마트 리컴포지션은 컴파일러가 제공한 안정성 데이터를 바탕으로 불필요한 업데이트를 선택적으로 건너뛰어 UI 성능과 반응성을 최적화합니다.

### 스마트 리컴포지션 작동 방식

새로운 입력이 컴포저블 함수에 전달될 때마다, Compose는 클래스의 `equals()` 메서드를 사용하여 이전 값과 비교합니다.

  * **안정적인 파라미터, 변경 없음:** 파라미터가 안정적이고 그 값이 변경되지 않았다면(`equals()`가 `true` 반환), Compose는 해당 UI 컴포넌트의 리컴포지션을 **건너뜁니다.**
  * **안정적인 파라미터, 값 변경:** 안정적인 파라미터의 값이 변경되었다면(`equals()`가 `false` 반환), 런타임은 리컴포지션을 트리거하여 UI가 업데이트된 상태를 반영하도록 보장합니다.
  * **불안정한 파라미터:** 파라미터가 불안정하다면, Compose는 값 변경 여부와 **관계없이 항상 리컴포지션을 트리거**합니다.

### 왜 불필요한 리컴포지션을 피해야 하는가?

중복 리컴포지션을 건너뛰는 것은 함수를 재실행하고 UI 요소를 다시 그리는 데 필요한 연산 오버헤드를 줄여 UI 성능을 향상시킵니다. 불필요한 리컴포지션은 특히 여러 상태 의존적인 컴포넌트가 있는 복잡한 UI 계층 구조에서 성능을 저하시킬 수 있습니다.

### 요약

비록 Jetpack Compose가 본질적으로 스마트 리컴포지션을 지원하지만, 개발자는 안정적인 클래스를 설계하고 가능할 때마다 리컴포지션을 최소화하는 방법을 이해해야 합니다. 안정성 원칙을 이해하고 적용함으로써, 개발자는 더 효율적이고 확장 가능한 Compose UI를 구축할 수 있습니다.

-----

## 💡 프로 팁: 어떤 안정성 어노테이션이 있으며, 어떻게 다른가요?

안정성 어노테이션은 개발자가 클래스의 안정성을 명시적으로 나타내어 Compose 컴파일러가 리컴포지션을 최적화하는 데 도움을 줄 수 있게 합니다. `compose-runtime` 라이브러리에서 제공하는 두 가지 주요 어노테이션은 **`@Immutable`** 과 **`@Stable`** 입니다. 이 어노테이션들은 별개의 목적을 가지며 어노테이션이 붙는 클래스의 특성에 따라 적용됩니다.

### @Immutable

`@Immutable` 어노테이션은 클래스가 **완전히 불변(immutable)** 임을 표시하여, 단순히 `val`이나 다른 읽기 전용 제약 조건을 사용하는 것보다 더 강력한 보장을 Compose 컴파일러에 제공합니다. 이는 클래스 내의 모든 프로퍼티가 컴파일러에 의해 불변으로 처리되도록 보장합니다. 클래스에 `@Immutable` 어노테이션이 붙으면, Compose 컴파일러는 그 값이 절대 변경되지 않을 것이라고 가정하여, 이 클래스에 의존하는 함수들의 리컴포지션을 안전하게 건너뛰어 성능을 향상시킬 수 있습니다.

**주요 특징:**

  * 클래스의 모든 프로퍼티가 불변으로 간주되어야 함을 보장합니다.
  * 변경 가능한 프로퍼티가 없는 데이터 클래스나 모델(읽기 전용 또는 이미 불변)에 일반적으로 사용됩니다.
  * 클래스 내 상태 변경이 없음을 보장하여 최적화를 단순화합니다.

**예시:**

```kotlin
@Immutable
data class User(val id: Int, val items: List<String>)
```

위 예시에서 `id` 프로퍼티는 기본 타입이므로 안정적이지만, `items` 프로퍼티는 `List`이므로 불안정한 데이터 타입으로 간주됩니다. 결과적으로 전체 `User` 클래스는 불안정한 것으로 처리됩니다. 그러나 개발자가 런타임에 이러한 프로퍼티들이 논리적으로 변경되지 않을 것임을 안다면, 클래스에 `@Immutable`을 표시하여 안정적인 것으로 명시적으로 선언할 수 있습니다.

### @Stable

`@Stable` 어노테이션은 프로퍼티가 불변이거나 리컴포지션에 영향을 주지 않는 **제어된 가변성(controlled mutability)** 을 가진 클래스에 사용됩니다. `@Immutable` 어노테이션에 비해 약간 덜 엄격하지만 강력한 보장을 Compose 컴파일러에 나타냅니다. 이는 클래스 자체가 안정적인 것으로 간주되지만, 그 프로퍼티는 여전히 변경될 수 있음을 의미합니다. 단, 그 변경이 Compose 런타임에 안전한, 제어되고 예측 가능한 방식이어야 합니다.

따라서 `@Stable` 어노테이션은 클래스 자체가 완전히 안정적으로 규정되지 않더라도 public 프로퍼티가 불변인 클래스에 가장 적합합니다. 예를 들어, Jetpack Compose에서 [`State`](https://developer.android.com/reference/kotlin/androidx/compose/runtime/State) 인터페이스는 불변의 `value` 프로퍼티를 노출하지만, 그 기저의 값은 일반적으로 [`MutableState`](https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState) 인스턴스를 사용하여 `setValue` 함수를 통해 수정될 수 있습니다.

**주요 특징:**

  * 일부 변경 가능한 프로퍼티를 허용하지만 클래스의 전반적인 안정성을 보장합니다.
  * 특정 가변성이 내부적으로 관리되는 클래스에 적합합니다.
  * 완전한 불변성이 실용적이지 않은 경우에 유연성을 제공합니다.

**예시:**

```kotlin
@Stable
interface State<out T> {
    val value: T
}

@Stable
interface MutableState<T> : State<T> {
    override var value: T
    operator fun component1(): T
    operator fun component2(): (T) -> Unit
}
```

`State`와 `MutableState`에서 볼 수 있듯이, `MutableState`에 의해 생성된 `State` 인스턴스는 `setValue`를 사용하여 동일한 값을 설정할 때 `getValue` 함수(`value` 프로퍼티의 getter)에서 항상 동일한 값을 반환하여 일관된 결과를 보장합니다. 위 코드 조각에서 `State`와 `MutableState` 인터페이스 모두 `@Stable` 어노테이션으로 표시되어 있습니다.

경우에 따라, 아래 예시와 같이 특정 함수가 `@Stable`로 표시된 것을 볼 수 있습니다. 이는 해당 함수가 반환하는 값이 Compose 컴파일러에 의해 안정적인 것으로 간주될 것을 보장하여 효율적인 리컴포지션을 보장함을 나타냅니다.

```kotlin
@Stable
fun Modifier.clipScrollableContainer(orientation: Orientation) =
    then(
        if (orientation == Orientation.Vertical) {
            Modifier.clip(VerticalScrollableClipShape)
        } else {
            Modifier.clip(HorizontalScrollableClipShape)
        }
    )
```

### @Immutable과 @Stable의 차이점

`@Immutable`과 `@Stable` 어노테이션의 구별은 처음에는 혼란스러울 수 있지만, 매우 간단합니다. `@Immutable` 어노테이션은 클래스의 모든 public 프로퍼티가 완전히 불변으로 간주되어야 함을 보장하며, 이는 객체가 생성된 후에는 상태가 변경될 수 없음을 의미합니다. 반대로, `@Stable` 어노테이션은 객체가 동일한 입력에 대해 일관되고 예측 가능한 결과를 생성하는 한, 변경 가능한 프로퍼티를 가진 객체에 적합합니다. 이러한 차이점으로 인해 개발자는 클래스의 안정성과 가변성에 따라 적절한 어노테이션을 선택할 수 있습니다.

| 구분 | @Immutable | @Stable |
| --- | --- | --- |
| **불변성 요구사항** | 모든 프로퍼티가 불변으로 간주되어야 함. | 일부 프로퍼티에 대해 제어된 가변성을 허용함. |
| **사용 사례** | 불변으로 간주되어야 하는 데이터 모델이나 설정. | 제어된 가변성을 가진 클래스, 예: UI 상태. |
| **리컴포지션 동작** | 동일한 파라미터를 가진 의존 컴포저블의 리컴포지션을 완전히 건너뜀. | 변경 가능한 프로퍼티가 변경되면 리컴포지션을 트리거할 수 있음. |

`@Immutable` 어노테이션은 일반적으로 I/O 작업(네트워크 응답 또는 데이터베이스 엔티티 등)에서 비롯되고 수정될 의도가 없는 도메인 모델에 적용되며, 특히 코틀린 데이터 클래스를 사용할 때 그렇습니다. 이러한 모델들은 인터페이스나 불안정한 클래스에 대한 참조를 포함하면 불안정한 것으로 간주될 수 있습니다. `@Immutable`으로 표시함으로써, Compose 컴파일러는 클래스를 불변으로 취급하여 안정성을 보장하고 리컴포지션을 최적화합니다. 예시:

```kotlin
@Immutable
public data class User(
    public val id: String,
    public val nickname: String,
    public val profileImages: List<String>,
)
```

반면에, `@Stable` 어노테이션은 일반적으로 다양한 구현을 허용하고 내부적인 변경 가능 상태를 포함할 수 있는 인터페이스에 사용됩니다. 다음 예시는 이 어노테이션이 어떻게 효과적으로 적용될 수 있는지 보여줍니다.

```kotlin
@Stable
interface UiState<T : Result<T>> {
    val value: T?
    val exception: Throwable?

    val hasSuccess: Boolean
        get() = exception == null
}
```

`@Stable` 어노테이션을 사용하면 `UiState` 클래스가 안정적인 것으로 표시되어, Jetpack Compose가 최적화된 리컴포지션과 지능적인 건너뛰기를 활용할 수 있게 합니다. 이는 불필요한 리컴포지션을 최소화하여 UI 업데이트의 효율성을 향상시킵니다.

### 요약

적절한 안정성 어노테이션을 적용하여 Jetpack Compose 애플리케이션을 최적화할 수 있습니다. 리컴포지션을 최소화하기 위해 완전히 불변으로 간주되어야 하는 클래스에는 `@Immutable`을 사용하고, 예측 가능한 동작을 보장하는 제어된 가변성을 가진 클래스에는 `@Stable`을 활용하세요. 이러한 어노테이션을 효과적으로 이해하고 사용하면 앱의 성능과 유지보수성을 크게 향상시킬 수 있습니다.

-----

## 💡 프로 팁: 특정 클래스에 @Immutable 대신 @Stable을 잘못 사용하면 어떻게 되나요?

비록 `@Stable`과 `@Immutable`이 Jetpack Compose에서 별개의 목적을 수행하지만, **현재로서는 Compose 컴파일러가 이를 처리하는 방식에 기능적인 차이가 없습니다.** 이는 특정 클래스에 `@Immutable` 대신 `@Stable`을 (또는 그 반대로) 실수로 사용하더라도 즉각적인 문제가 발생하지 않음을 의미합니다. 그렇다면 애초에 왜 이런 구별이 존재하는 걸까요?

한 가지 가능한 이유는 Compose 팀이 **미래의 최적화나 행동 변경을 허용하기 위해 의도적으로 이러한 분리를 도입**했다는 것입니다. 오늘날 두 어노테이션이 유사하게 작동할지라도, Compose 메커니즘이 발전함에 따라 내부 처리 방식이 달라질 수 있습니다. 의도된 사용법을 존중하면 나중에 컴파일러 동작이 변경될 경우 코드의 미래 호환성을 보장하고 잠재적인 마이그레이션 과제를 최소화할 수 있습니다.

-----

## Q. Compose 컴파일러는 파라미터가 안정적인지 불안정한지 어떻게 결정하며, 이것이 리컴포지션에 왜 중요한가요?

Jetpack Compose에서 컴포저블(Composable) 함수의 파라미터가 **안정적인지(stable) 불안정한지(unstable)** 여부는 리컴포지션(recomposition) 최적화에 직접적인 영향을 미치는 매우 중요한 요소입니다. Compose 컴파일러는 특정 규칙에 따라 타입을 분류하며, 이 분류 결과는 앱의 성능을 좌우합니다.

---
### 1. Compose 컴파일러의 파라미터 안정성 결정 방식

컴파일러는 컴파일 시점에 각 파라미터의 타입을 분석하여 그 안정성을 추론합니다. 안정성의 핵심 개념은 **예측 가능성**과 **불변성**입니다. 즉, 특정 타입의 두 인스턴스가 `equals()` 비교 시 `true`라면, 두 인스턴스는 동일한 결과를 보장해야 하며, 인스턴스가 생성된 후에는 그 결과에 영향을 미치는 public 프로퍼티가 변경되지 않아야 합니다.

#### 1.1. 안정적(Stable)으로 간주되는 타입 🟢
컴파일러는 다음과 같은 타입들을 안정적인 것으로 간주하여 리컴포지션 최적화 대상으로 삼습니다.

* **모든 기본(Primitive) 타입:** `Int`, `Float`, `Boolean`, `Char` 등과 `String`은 불변(immutable)이므로 본질적으로 안정적입니다.
* **함수 타입 (람다):** 컴포저블에 전달되는 람다 표현식은 일반적으로 안정적입니다.
* **`@Immutable` 또는 `@Stable` 어노테이션이 붙은 클래스:** 개발자가 명시적으로 안정성을 보장한 타입입니다. 컴파일러는 이 선언을 신뢰합니다.
* **안정적인 타입으로만 구성된 클래스:** 클래스의 모든 public 프로퍼티(`val` 또는 `var`)가 안정적인 타입으로만 구성되어 있다면, 해당 클래스도 안정적인 것으로 추론될 수 있습니다.
    * **예시:** 모든 프로퍼티가 `val`이고 타입이 `Int`, `String` 등 안정적인 타입으로만 이루어진 `data class`는 안정적으로 간주됩니다.

#### 1.2. 불안정(Unstable)으로 간주되는 타입 🔴
컴파일러는 다음과 같은 경우 타입을 불안정한 것으로 간주하고, 리컴포지션 건너뛰기 최적화를 적용하지 않습니다.

* **인터페이스 (예: `List<T>`, `Set<T>`, `Map<K, V>`):**
    * `List`와 같은 타입은 인터페이스입니다. 컴파일러는 런타임에 전달될 실제 구현체가 무엇인지(예: 변경 가능한 `ArrayList`인지, 불변 리스트인지) 알 수 없습니다. 구현체에 따라 내용이 변경될 수 있으므로, 인터페이스 타입은 불안정한 것으로 간주됩니다.
* **변경 가능한(`var`) 프로퍼티를 가진 클래스:**
    * 클래스가 `public`으로 노출된 `var` 프로퍼티를 가지고 있다면, 해당 객체의 참조는 동일하더라도 내부 값이 언제든지 변경될 수 있습니다. 컴파일러는 이러한 변경을 추적할 수 없으므로 해당 클래스를 불안정한 것으로 취급합니다.
* **불안정한 타입을 프로퍼티로 가진 클래스:**
    * 클래스의 프로퍼티 중 하나라도 불안정한 타입을 포함하고 있다면, 해당 클래스 전체가 불안정한 것으로 간주됩니다.

---
### 2. 안정성이 리컴포지션에 중요한 이유

컴포저블 파라미터의 안정성은 **"스마트 리컴포지션(Smart Recomposition)"** 이라는 Compose의 핵심 성능 최적화 메커니즘을 작동시키는 전제 조건이기 때문에 매우 중요합니다.

#### 2.1. 스마트 리컴포지션의 전제 조건
Compose 런타임의 목표는 상태가 변경되었을 때 **꼭 필요한 컴포저블만 다시 실행**하고 나머지는 건너뛰어(skip) 불필요한 작업을 최소화하는 것입니다. 이 "건너뛰기"를 할지 말지 결정하는 기준이 바로 파라미터의 안정성입니다.

#### 2.2. 안정적인 파라미터의 경우: 효율적인 건너뛰기(Skipping) ✅
* 컴포저블 함수의 모든 파라미터가 **안정적(Stable)** 이라면, 리컴포지션이 트리거될 때 Compose 런타임은 새로운 파라미터 값과 이전 파라미터 값을 `equals()`로 비교합니다.
* 만약 모든 파라미터가 이전과 동일하다면(`equals()` 결과가 `true`), 런타임은 **"입력이 변경되지 않았으므로 결과도 동일할 것이다"** 라고 확신할 수 있습니다.
* 결과적으로, 해당 컴포저블 함수의 실행을 **안전하게 건너뛰고** 이전 컴포지션 결과를 재사용합니다. 이는 막대한 양의 계산과 UI 렌더링 작업을 절약해 줍니다.

#### 2.3. 불안정한 파라미터의 경우: 불필요한 리컴포지션 유발 ⚠️
* 만약 파라미터 중 하나라도 **불안정(Unstable)** 하다면, Compose 런타임은 `equals()` 비교 결과를 신뢰할 수 없습니다. 설령 `equals()`가 `true`를 반환하더라도, 객체 내부의 어떤 값이 변경되었을 가능성을 배제할 수 없기 때문입니다.
* 런타임은 이러한 불확실성 하에서 UI가 갱신되지 않는 버그를 피하기 위해 안전한 길을 택합니다. 즉, 파라미터가 **항상 변경되었다고 가정하고 해당 컴포저블을 무조건 다시 실행**합니다.
* 결과적으로, 불안정한 파라미터를 받는 컴포저블은 **스마트 리컴포지션의 이점을 전혀 누리지 못하게 됩니다.** 이는 실제 데이터 변경이 없었음에도 불구하고 불필요한 리컴포지션을 유발하여 UI 버벅임, CPU 사용량 증가, 배터리 소모 증가 등 성능 저하의 직접적인 원인이 됩니다.

---
### 3. 결론

Compose 컴파일러가 파라미터의 **안정성**을 결정하는 것은 단순한 타입 체크가 아니라, 런타임에 **리컴포지션을 건너뛸 수 있는지 여부를 판단하는 근거**를 마련하는 과정입니다. 개발자는 컴포저블에 전달하는 데이터 타입을 안정적으로 유지함으로써(예: 기본 타입 사용, 불변 컬렉션 사용, `@Immutable` 어노테이션 활용 등) Compose의 가장 강력한 성능 최적화 기능인 **스마트 리컴포지션**을 최대한 활용할 수 있습니다. 따라서 안정성에 대한 이해는 고성능 Compose UI를 구축하는 데 있어 필수적입니다.


## Q. Jetpack Compose에서 @Stable 및 @Immutable 어노테이션은 무엇이며, 언제 사용해야 하나요?

`@Stable`과 `@Immutable` 어노테이션은 Jetpack Compose에서 **리컴포지션(recomposition) 성능을 최적화**하기 위해 개발자가 컴파일러에게 특정 타입의 **안정성(Stability)** 에 대한 정보를 명시적으로 제공하는 강력한 도구입니다. 컴파일러는 이 정보를 바탕으로 불필요한 리컴포지션을 안전하게 건너뛸 수 있습니다.

-----

### 1. 안정성 어노테이션의 목적

Compose 컴파일러는 기본 타입, `String`, 안정적인 프로퍼티만으로 구성된 데이터 클래스 등 일부 타입의 안정성을 자동으로 추론할 수 있습니다. 하지만 `List`와 같은 인터페이스 타입을 포함하거나, 직접 제어할 수 없는 외부 라이브러리 클래스를 사용하는 경우, 컴파일러는 해당 타입을 **불안정(unstable)** 하다고 가정하고 리컴포지션 건너뛰기 최적화를 수행하지 않습니다.

`@Stable`과 `@Immutable` 어노테이션은 이러한 상황에서 개발자가 **"이 타입은 안정적이니 믿고 최적화해도 된다"** 고 컴파일러에게 약속하는 역할을 합니다.

-----

### 2. `@Immutable` 어노테이션

#### 2.1. 정의 및 의미

`@Immutable`은 해당 타입이 **완전하고 깊은 불변(immutable)** 임을 나타내는 가장 강력한 보증입니다.

  * 이 어노테이션이 붙은 클래스의 인스턴스는 일단 생성된 후에는 **그 어떤 public 프로퍼티의 값도 절대 변경되지 않는다**는 것을 의미합니다.
  * 클래스 내 모든 프로퍼티들도 불변이거나 안정적인 타입이어야 합니다.

#### 2.2. 사용 시나리오

  * **API 응답 모델 또는 데이터베이스 엔티티:** 네트워크나 데이터베이스로부터 가져온 후, 앱 내에서는 읽기 전용으로만 사용되는 데이터 모델 클래스에 매우 적합합니다.
  * **불변성이 보장되는 데이터 클래스:** 비록 `List`와 같이 컴파일러가 불안정하다고 추론하는 타입을 프로퍼티로 가지고 있더라도, 개발자가 해당 `List`를 앱 로직 내에서 절대 수정하지 않을 것임을 보장할 수 있을 때 사용할 수 있습니다.

#### 2.3. 예시 코드

```kotlin
// List<String>은 인터페이스 타입이라 컴파일러는 불안정하다고 추론하지만,
// @Immutable을 붙여 개발자가 안정성을 보장합니다.
@Immutable
data class Article(
    val id: Int,
    val title: String,
    val tags: List<String> // List는 인터페이스라 불안정하지만, 불변으로 취급할 것을 약속
)
```

이제 `Article` 타입의 파라미터는 안정적인 것으로 간주되어, `Article` 객체가 변경되지 않았다면 이를 사용하는 컴포저블의 리컴포지션이 건너뛰어질 수 있습니다.

-----

### 3. `@Stable` 어노테이션

#### 3.1. 정의 및 의미

`@Stable`은 `@Immutable`보다 약간 덜 엄격한 약속으로, 다음과 같은 두 가지를 보장합니다.

1.  두 인스턴스에 대한 `equals()` 비교 결과는 항상 동일한 결과를 반환합니다.
2.  만약 클래스의 public 프로퍼티 값이 변경된다면, **컴포지션 시스템에 그 변경 사실을 반드시 알립니다(notify).**

즉, `@Stable`은 객체의 프로퍼티가 변경될 수는 있지만, 그 변경이 Compose의 상태 시스템(예: `MutableState`)을 통해 이루어져 **예측 가능하고 제어된 가변성**을 가짐을 의미합니다.

#### 3.2. 사용 시나리오

  * **상태 홀더(State Holder) 클래스:** `MutableState`를 사용하여 내부적으로 상태를 관리하는 UI 상태 홀더 클래스에 적합합니다. `MutableState` 자체가 `@Stable`로 선언되어 있습니다. 값이 변경될 수 있지만, 그 변경이 Compose 런타임에 의해 추적되기 때문입니다.
  * **인터페이스:** 특정 인터페이스의 모든 구현체가 안정성 계약을 따를 것이라고 보장하고 싶을 때 인터페이스 자체에 붙일 수 있습니다.
  * **완전한 불변성이 실용적이지 않은 경우:** 일부 상태 변경이 필요하지만, 그 변경이 제어 가능하고 예측 가능할 때 사용합니다.

#### 2.3. 예시 코드

```kotlin
// State와 MutableState 인터페이스는 Compose 런타임 라이브러리에 @Stable로 정의되어 있습니다.
@Stable
interface State<out T> {
    val value: T
}

@Stable
interface MutableState<T> : State<T> {
    override var value: T
    // ...
}

// 사용자 정의 상태 홀더 예시
@Stable
class SearchUiState(
    query: MutableState<String>,
    searchResults: MutableState<List<String>>
) {
    var query by query
    var searchResults by searchResults
}
```

위 `SearchUiState`는 변경 가능한 `MutableState`를 포함하지만, 이 변경이 Compose에 의해 추적되므로 클래스 전체를 `@Stable`로 간주하여 최적화 이점을 얻을 수 있습니다.

-----

### 4. @Immutable과 @Stable의 주요 차이점 및 선택 가이드

| 구분 | `@Immutable` | `@Stable` |
| --- | --- | --- |
| **불변성 요구사항** | 클래스의 모든 public 프로퍼티가 **완전히 불변**이어야 함을 의미. 생성 후 상태 변경 불가. | 일부 프로퍼티는 변경 가능하나, 그 변경이 **제어 가능하고 Compose에 통지**됨을 의미. |
| **주 사용 사례** | 네트워크 응답 모델, 데이터베이스 엔티티 등 **읽기 전용 데이터 객체.** | UI 상태를 관리하는 상태 홀더, 내부적으로 `MutableState`를 사용하는 클래스 등. |
| **컴파일러에 대한 약속** | "이 객체의 값은 절대 변하지 않습니다." | "이 객체의 값이 변하면, 제가 반드시 알려드리겠습니다. `equals()` 결과는 신뢰하셔도 됩니다." |

#### 선택 가이드

  * 객체가 생성된 후 **절대로 그 내용이 변경되지 않을 데이터 모델**이라면 **`@Immutable`** 을 사용하세요.
  * 객체의 상태가 **변경될 수 있지만, 그 변경이 `MutableState`와 같이 Compose가 추적할 수 있는 방식으로 제어**된다면 **`@Stable`** 을 사용하세요.

-----

### 5. (참고) 잘못 사용했을 경우의 영향

현재 Compose 컴파일러의 구현상으로는 `@Immutable`과 `@Stable`을 처리하는 방식에 기능적인 차이가 크지 않습니다. 즉, `@Immutable`을 붙여야 할 곳에 `@Stable`을 붙여도 당장 문제가 발생하지는 않을 수 있습니다.

하지만 이 둘을 구분하는 이유는 **의미론적 명확성**과 **미래 호환성** 때문입니다. Compose 팀은 향후 컴파일러 최적화 과정에서 `@Immutable`에 대해 더 강력한 가정을 하여 추가적인 최적화를 수행할 가능성이 있습니다. 따라서 각 어노테이션의 의도에 맞게 사용하는 것이 장기적으로 코드의 안정성과 유지보수성을 위해 바람직합니다.

-----

### 6. 결론

`@Stable`과 `@Immutable` 어노테이션은 개발자가 **Compose 컴파일러에게 타입의 안정성에 대한 신뢰할 수 있는 정보를 제공**하여, 불필요한 리컴포지션을 건너뛰는 **스마트 리컴포지션 최적화를 극대화**하기 위한 중요한 도구입니다. 컴파일러가 안정성을 자동으로 추론할 수 없는 경우(예: `List`와 같은 인터페이스 타입 포함 시), 이 어노테이션들을 적절히 활용하여 앱의 성능을 크게 향상시킬 수 있습니다.


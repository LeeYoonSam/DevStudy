# 왜 항상 릴리스 모드에서 Compose 성능을 테스트해야 하나요?

Jetpack Compose 성능을 테스트할 때는 항상 [**R8이 활성화된 릴리스 모드(release mode)**](https://developer.android.com/topic/performance/app-optimization/enable-app-optimization#enable) 에서 앱을 실행하는 것을 우선시해야 합니다. 디버그 모드(Debug mode)는 인터프리테이션(interpretation, 해석), **JIT(Just-in-Time) 컴파일**, 그리고 라이브 편집 리터럴(Live Edit Literals)과 같은 개발자 도구 기능으로 인한 추가적인 오버헤드를 발생시킵니다. 이 모든 요소들은 성능에 영향을 미치며 최종 사용자 경험을 제대로 반영하지 못하게 합니다.

-----

## 디버그 모드가 Compose 성능에 미치는 영향

### 번들되지 않은 라이브러리로서의 Compose

Compose는 **"번들되지 않은(unbundled)" 라이브러리**로 제공됩니다. 이는 디버그 가능한 앱을 실행할 때 런타임에 코드가 해석되고 컴파일됨을 의미합니다. 안드로이드 OS와 함께 번들로 제공되어 미리 컴파일된 뷰(View) 시스템과 달리, 디버그 모드의 Compose 코드는 추가적인 인터프리테이션 및 JIT 컴파일 오버헤드를 발생시킵니다. 이는 최적화된 릴리스 빌드와 비교하여 상당한 성능 격차를 만들 수 있습니다.

> **안드로이드 팀에 따르면:**
> 뷰 라이브러리들은 빠르게 사전 컴파일되고, 릴리스 빌드되며, 최적화된 프레임워크 코드로 돌아갑니다. 반면에 Compose 버전은 레이지 리스트 관리의 작은 일부만이 아닌 전체 UI 스택을 디버그 가능한 코드로 실행하고 있습니다.

### 라이브 편집 리터럴 및 개발자 도구

디버그 빌드는 [라이브 편집 리터럴](https://developer.android.com/develop/ui/compose/tooling#live-edit-literals)과 같은 개발자 기능을 활성화하며, 이는 런타임 업데이트를 지원하기 위해 상수를 getter 함수로 대체합니다. 이는 추가적인 연산을 유발하고 최적화를 방해하여, 디버그 모드에서 더 느린 리컴포지션과 렌더링을 초래합니다.

-----

## 릴리스 모드에서의 R8 최적화

**R8**은 람다 그룹화, 소스 정보 생략, 상수 폴딩, 그리고 인터페이스 호출을 더 빠른 정적 호출로 변환하는 것과 같은 최적화를 통해 릴리스 빌드의 성능을 크게 향상시킵니다. 이러한 최적화는 시작 시간을 줄이고, 메모리 사용량을 낮추며, 런타임 실행을 간소화합니다.

> **안드로이드 팀에 따르면:**
> Compose는 또한 R8 최적화로부터 엄청난 이점을 얻습니다. 위에서 본 바와 같이, 기본 설정의 R8을 추가하는 것만으로도 시작 성능에서 **75%**, 프레임 렌더링 성능에서 **60%** 의 이득이 있습니다. R8은 많은 최적화를 수행하지만, 아래는 Compose 코드에 가장 큰 영향을 미치는 일부 세부 사항입니다.

  * **람다 그룹화 (Lambda grouping):** 유사한 람다 구현을 그룹화하여 메서드 오버헤드를 줄여 람다 표현식을 최적화합니다.
  * **소스 정보 생략 (Omitting source information):** 디버그 및 소스 메타데이터를 제거하여 APK 크기를 최소화합니다.
  * **상수 폴딩 (Constant folding):** 컴파일 타임에 상수 표현식을 단순화하여 런타임 효율성을 향상시킵니다.
  * **인터페이스 호출을 정적 호출로 변환 (Converting interface calls to static invocations):** 동적 인터페이스 호출을 더 빠른 정적 메서드 호출로 대체하여 실행 속도를 크게 향상시킵니다.

-----

## 베이스라인 프로필의 중요성

Compose는 릴리스 모드에서 성능을 더욱 향상시키기 위해 [**베이스라인 프로필(Baseline Profiles)**](https://developer.android.com/topic/performance/baselineprofiles/overview) 에 의존합니다. 이 프로필은 중요한 Compose 메서드를 미리 컴파일하여, 앱 시작 중 런타임 인터프리테이션 및 JIT 컴파일의 필요성을 피하게 합니다. 디버그 빌드는 베이스라인 프로필을 사용하지 않으므로, 실제 앱 성능을 덜 반영하게 됩니다. 더 자세한 정보는 [베이스라인 프로필로 Android 앱 성능 개선](https://proandroiddev.com/improve-your-android-app-performance-with-baseline-profiles-297f388082e6)(영문)을 읽어보세요.

-----

## 실용적인 테스트 권장 사항

성능을 정확하게 평가하려면, 항상 **R8과 베이스라인 프로필이 활성화된 릴리스 모드**에서 Compose 앱을 테스트해야 합니다. [**Macrobenchmark**](https://developer.android.com/topic/performance/benchmarking/macrobenchmark-overview)와 같은 도구를 활용하여 시작 및 런타임 성능을 측정하세요. 이 접근 방식은 실제 성능 병목 현상을 식별하고 최종 사용자에게 부드러운 경험을 제공하도록 보장합니다.

-----

## 요약

디버그 모드는 Jetpack Compose의 실제 성능을 왜곡하는 상당한 오버헤드를 발생시키므로, 릴리스 모드 테스트가 필수적입니다. R8 최적화와 베이스라인 프로필은 Compose 앱이 효율적으로 실행되도록 보장하며, 이는 현실적인 성능 벤치마킹의 중요성을 강조합니다. 더 깊은 통찰력을 원한다면 [안드로이드 개발자 블로그: 왜 항상 릴리스 모드에서 Compose 성능을 테스트해야 하는가?](https://medium.com/androiddevelopers/why-should-you-always-test-compose-performance-in-release-4168dd0f2c71)(영문)를 참조하세요.

-----

## Q. R8은 Jetpack Compose 성능 최적화에서 어떤 역할을 하며, 릴리스 빌드에서 어떤 구체적인 개선점을 제공하나요?

**R8**은 Jetpack Compose로 빌드된 애플리케이션의 **릴리스 빌드(release build)에서 성능을 최적화하고 파일 크기를 줄이는 데 핵심적인 역할**을 수행합니다. 이는 단순한 코드 축소를 넘어, Compose의 특성에 맞는 다양한 최적화 기법을 적용하여 최종 사용자에게 더 빠르고 효율적인 앱 경험을 제공합니다.

---
### 1. R8의 역할: Compose 코드 변환 및 최적화

R8은 안드로이드 그래들 플러그인(AGP) 3.4.0부터 기본으로 사용되는 코드 최적화 도구입니다. 릴리스 빌드 과정에서 R8은 다음과 같은 세 가지 주요 작업을 수행합니다.

1.  **코드 축소 (Shrinking):** 앱에서 실제로 사용되지 않는 코드(클래스, 메서드, 필드 등)를 제거합니다.
2.  **최적화 (Optimization):** 코드를 분석하고 재작성하여 앱이 더 효율적으로 실행되도록 합니다.
3.  **난독화 (Obfuscation):** 클래스, 메서드, 필드의 이름을 짧고 의미 없는 이름으로 변경하여 리버스 엔지니어링을 어렵게 만듭니다.

특히 Compose는 OS에 내장된 뷰(View) 시스템과 달리 **라이브러리 형태**로 앱에 포함되므로, 사용하지 않는 수많은 Compose 라이브러리 코드를 제거하는 R8의 **코드 축소** 역할이 매우 중요합니다.

---
### 2. 릴리스 빌드에서의 구체적인 개선점

R8은 릴리스 빌드에서 다음과 같은 구체적인 개선점을 통해 Compose 앱의 성능과 크기를 최적화합니다.

#### 2.1. 획기적인 크기 감소 (코드 및 리소스 축소) 📉
* **사용되지 않는 코드 제거 (Dead Code Elimination):**
    앱에서 호출되지 않는 `@Composable` 함수, 사용되지 않는 `Modifier`, 그리고 Compose 런타임의 내부 함수 등 방대한 양의 코드를 식별하고 제거합니다. 이는 APK/AAB 파일 크기를 크게 줄이는 가장 직접적인 방법입니다.
* **리소스 축소 효율 증대:**
    R8이 사용되지 않는 코드를 제거하면, 해당 코드에서만 참조되던 드로어블(drawable), 문자열(string) 등의 리소스도 식별 가능해집니다. 이를 통해 안드로이드 빌드 시스템의 리소스 축소 기능이 더 효과적으로 작동하여 불필요한 리소스를 제거할 수 있습니다.
* **난독화를 통한 크기 감소:**
    클래스, 메서드 등의 이름을 `a`, `b`, `c` 와 같이 짧게 변경하면, `.dex` 파일 내 문자열 풀(string pool)이 차지하는 공간이 줄어들어 파일 크기가 미미하게나마 감소하는 부가적인 효과가 있습니다.

#### 2.2. 런타임 성능 향상 (코드 최적화) 🚀
안드로이드 팀이 강조하는 것처럼, R8은 Compose 코드에 대해 매우 효과적인 성능 최적화를 수행합니다.

> **안드로이드 팀에 따르면:**
> 기본 설정의 R8을 추가하는 것만으로도 시작 성능에서 **75%**, 프레임 렌더링 성능에서 **60%** 의 이득이 있습니다.

주요 최적화 기법은 다음과 같습니다.

* **람다 그룹화 (Lambda Grouping):**
    Compose는 람다를 매우 광범위하게 사용합니다. R8은 구조적으로 유사한 람다들을 하나의 클래스로 그룹화하여, 생성되는 클래스의 수를 줄이고 메서드 호출 오버헤드를 감소시켜 성능을 향상시킵니다.
* **인터페이스 호출을 정적 호출로 변환 (Converting interface calls to static invocations):**
    컴파일 시점에 특정 인터페이스의 구현체가 무엇인지 파악할 수 있는 경우, 더 느린 동적 디스패치(dynamic dispatch) 방식의 인터페이스 호출을 더 빠른 직접적인 정적 메서드 호출로 변환합니다. 이는 실행 속도를 크게 향상시키는 강력한 최적화입니다.
* **상수 폴딩 (Constant Folding):**
    컴파일 시점에 계산 가능한 상수 표현식을 미리 계산하여 결과값으로 대체합니다. 이는 런타임에 수행되어야 할 연산을 줄여줍니다.
* **기타 최적화:**
    이 외에도 메서드 인라이닝(inlining), 클래스 병합(class merging) 등 다양한 고급 최적화 기법을 적용하여 Compose 런타임의 효율성을 극대화합니다.

#### 2.3. 향상된 보안 🛡️
* **난독화(Obfuscation):** 코드의 원래 구조와 이름을 알기 어렵게 만들어, 공격자가 앱의 로직을 분석하거나 리버스 엔지니어링하는 것을 훨씬 더 어렵게 만듭니다. 이는 앱의 지적 재산을 보호하는 데 도움이 됩니다.

---
### 3. 결론: 릴리스 모드 최적화의 필수 요소

R8은 단순히 파일 크기를 줄이는 도구를 넘어, **Jetpack Compose의 성능을 최대한으로 이끌어내는 필수적인 최적화 파트너**입니다. R8이 없는 디버그 빌드는 수많은 디버깅용 메타데이터와 최적화되지 않은 라이브러리 코드를 포함하고 있어 실제 사용자가 경험하는 성능을 제대로 반영하지 못합니다.

따라서 Compose 앱의 진정한 성능을 측정하고 최적화하려면, 반드시 **R8이 활성화된 릴리스 빌드**를 기준으로 삼아야 합니다. R8은 불필요한 코드를 제거하고, 런타임 실행을 최적화하며, 앱의 보안을 강화하여, 개발자가 최종 사용자에게 작고 빠르며 안정적인 애플리케이션을 제공할 수 있도록 하는 핵심적인 역할을 수행합니다.
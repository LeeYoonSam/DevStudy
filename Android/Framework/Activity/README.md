# 액티비티 생명주기 설명

안드로이드 **액티비티(Activity) 라이프사이클**은 액티비티가 생성부터 소멸까지 거치는 여러 다른 상태를 설명합니다. 이러한 상태를 이해하는 것은 리소스를 효과적으로 관리하고, 사용자 입력을 처리하며, 원활한 사용자 경험을 보장하는 데 매우 중요합니다. 액티비티 라이프사이클의 주요 단계는 다음과 같습니다.

* **`onCreate()`**: 액티비티가 생성될 때 가장 먼저 호출되는 메서드입니다. 여기에서 액티비티를 초기화하고, UI 구성요소를 설정하며, 저장된 인스턴스 상태(saved instance state)가 있다면 복원합니다. 액티비티가 소멸되었다가 다시 생성되지 않는 한, 라이프사이클 동안 단 한 번만 호출됩니다.

* **`onStart()`**: 액티비티가 사용자에게 보이기 시작하지만 아직 상호작용은 불가능한 상태입니다. `onCreate()` 이후, `onResume()` 이전에 호출됩니다.

* **`onRestart()`**: 액티비티가 중지(stopped)되었다가 다시 시작될 때 (예: 사용자가 뒤로가기 등으로 다시 돌아올 때) `onStart()` 전에 호출됩니다.

* **`onResume()`**: 액티비티가 포그라운드(foreground) 상태에 있으며 사용자와 상호작용할 수 있습니다. 일시 중지되었던 UI 업데이트, 애니메이션, 입력 리스너 등을 다시 시작하는 곳입니다.

* **`onPause()`**: 다른 액티비티(예: 다이얼로그)에 의해 액티비티가 부분적으로 가려질 때 호출됩니다. 액티비티는 여전히 보이지만 포커스(focus)는 잃은 상태입니다. 애니메이션, 센서 업데이트 같은 작업을 일시 중지하거나 데이터를 저장하는 데 자주 사용됩니다.

* **`onStop()`**: 액티비티가 사용자에게 더 이상 보이지 않을 때 (예: 다른 액티비티가 포그라운드로 올라올 때) 호출됩니다. 액티비티가 중지된 동안 필요 없는 리소스(백그라운드 작업, 무거운 객체 등)를 해제해야 합니다.

* **`onDestroy()`**: 액티비티가 완전히 소멸되어 메모리에서 제거되기 전에 호출됩니다. 남아있는 모든 리소스를 해제하는 최종 정리 메서드입니다.

---

## Q. `onPause()`와 `onStop()`의 차이점은 무엇이며, 각각 리소스 집약적인 작업을 처리하기 위해 어떤 시나리오에서 사용해야 하나요?

`onPause()`와 `onStop()`은 액티비티(Activity) 라이프사이클에서 중요한 두 상태이지만, 호출되는 시점과 그 의미, 그리고 처리해야 할 작업의 종류에서 차이가 있습니다.

**1. `onPause()`와 `onStop()`의 차이점**

* **`onPause()`**:
  * **호출 시점**: 액티비티가 포커스를 잃었지만 **부분적으로 사용자에게 보일 때** 호출됩니다. 예를 들어, 투명하거나 다이얼로그 형태의 다른 액티비티가 위에 표시될 때입니다. 또한, 현재 액티비티를 떠나 다른 액티비티로 전환될 때, 새 액티비티가 시작되기 *직전*에 항상 호출됩니다. 사용자가 액티비티를 떠나기 시작했다는 첫 신호이지만, 반드시 `onStop()`이나 `onDestroy()`로 이어지는 것은 아닙니다.
  * **상태**: 액티비티가 부분적으로 보이지만 사용자와 상호작용은 불가능한 상태입니다.
  * **특징**: `onPause()`에서의 작업은 **매우 빠르게 완료되어야 합니다**. 이 메서드가 완료될 때까지 다음 액티비티의 시작이나 다른 상태 전환이 지연되기 때문입니다.

* **`onStop()`**:
  * **호출 시점**: 액티비티가 **사용자에게 완전히 보이지 않게 되었을 때** 호출됩니다. 예를 들어, 다른 액티비티가 현재 액티비티를 완전히 덮거나 사용자가 홈 버튼을 눌러 홈 화면으로 나갔을 때입니다. `onPause()`는 항상 `onStop()`보다 먼저 호출됩니다.
  * **상태**: 액티비티가 보이지 않고 백그라운드 상태에 있습니다.
  * **특징**: `onPause()`보다는 비교적 시간이 더 걸리는 작업을 수행할 수 있습니다. 하지만 여전히 시스템이 메모리 확보 등을 위해 언제든지 프로세스를 종료할 수 있으므로 무한정 긴 작업을 수행해서는 안 됩니다.

**2. 리소스 집약적인 작업 처리 시나리오**

리소스 집약적인(CPU 사용량이 많거나 시간이 오래 걸리는) 작업은 UI 스레드를 차단하여 사용자 경험을 해치므로, `onPause()`나 `onStop()`에서 직접 처리하는 것은 일반적으로 권장되지 않습니다. 하지만 각 콜백에서 처리하기에 적합한 작업 수준은 다음과 같습니다.

* **`onPause()`에서 처리할 작업**:
  * **목적**: 액티비티가 포커스를 잃었지만 여전히 보일 수 있는 상황에 맞춰, 가볍고 빠르게 상태를 저장하거나 실행 중인 작업을 조정하는 데 사용됩니다.
  * **적합한 작업**:
      * 애니메이션, UI 업데이트 등 포그라운드 상태에서만 의미 있는 작업 **일시 중지**.
      * 카메라 미리보기, 센서 리스너 등 액티비티가 활성 상태(및 보일 때)에만 필요한 시스템 리소스 **해제** (가벼운 해제 작업).
      * 작성 중이던 이메일 초안 등 사용자가 잃으면 안 되는 **작지만 중요한 데이터의 영구 저장** (단, 디스크 I/O나 네트워크 요청은 매우 빨라야 함. 일반적으로 `ViewModel`이나 `onSaveInstanceState`로 처리 후 다른 메커니즘으로 저장하는 것이 좋음).
  * **피해야 할 작업**: CPU를 많이 사용하는 계산, 대용량 파일 저장, 네트워크 요청 등 **시간이 걸리는 작업**.

* **`onStop()`에서 처리할 작업**:
  * **목적**: 액티비티가 사용자에게 보이지 않을 때 필요 없는 리소스를 해제하고, `onPause()`에서 하기에는 부담스러웠던 정리 작업을 수행하는 데 사용됩니다.
  * **적합한 작업**:
      * 액티비티가 화면에 보일 때만 필요한 대부분의 리소스 **해제** (예: 정밀한 위치 업데이트 리스너 해제).
      * `onPause()`보다 **상대적으로 무거운 데이터 저장 작업** 수행 (예: 설정 값 저장, 중간 크기의 데이터베이스 업데이트). 하지만 여기서도 매우 긴 작업(예: 대용량 파일 다운로드/업로드)은 백그라운드 스레드나 `Service`, `WorkManager` 등으로 처리해야 합니다. `onStop()` 이후 `onDestroy()`가 호출되지 않고 프로세스가 종료될 수 있기 때문입니다.
      * UI가 보일 때만 관련된 브로드캐스트 리시버 등 **등록 해제**.
  * **고려사항**: `onStop()`은 프로세스가 종료되기 전 마지막으로 호출될 수 있는 라이프사이클 콜백일 수 있으므로 (`onDestroy()` 호출은 보장되지 않음), UI 가시성과 직접 관련된 리소스는 이때 확실히 정리하는 것이 좋습니다.

**결론적으로**, `onPause()`는 매우 신속하게 처리되어야 하는 필수적인 일시 중지 및 가벼운 저장 작업에 사용하고, `onStop()`은 액티비티가 완전히 보이지 않을 때 수행해도 되는 더 무거운 리소스 해제 및 저장 작업에 사용합니다. 진정한 의미의 리소스 집약적이고 시간이 오래 걸리는 작업은 두 콜백 모두에서 직접 수행하기보다는 `ViewModel`, `Service`, `WorkManager` 등을 활용하여 백그라운드에서 처리하는 것이 올바른 접근 방식입니다.

---

### 💡 프로 팁: 여러 액티비티 간의 라이프사이클 변화

액티비티 라이프사이클에 대한 일반적인 후속 질문은 다음과 같을 수 있습니다: "액티비티 A를 시작하고, 그 다음 액티비티 B를 시작한 후, 마지막으로 순차적으로 액티비티 A로 돌아올 때 발생하는 라이프사이클 전환을 설명해 주시겠습니까?" 이 시나리오는 안드로이드 시스템이 여러 액티비티 상태를 어떻게 관리하는지에 대한 이해도를 테스트하는 데 도움이 됩니다.

두 액티비티 A와 B 사이를 이동할 때, 각 액티비티의 안드로이드 라이프사이클 콜백은 특정 순서로 호출됩니다. 이 시나리오에 대한 라이프사이클 전환 단계를 자세히 살펴보겠습니다.

**액티비티 A와 B의 완전한 순차적 라이프사이클 흐름:**

1.  **액티비티 A의 초기 시작:**
    * 액티비티 A: `onCreate()` -> `onStart()` -> `onResume()` 순서로 처음 시작됩니다. 사용자는 액티비티 A와 상호작용합니다.

2.  **액티비티 A에서 액티비티 B로 이동:**
    * 액티비티 A: `onPause()` 호출됨 (UI를 일시 중지하고 보이는 상태와 관련된 리소스 해제).
    * 액티비티 B: `onCreate()` -> `onStart()` -> `onResume()` 호출됨 (포커스를 얻고 포그라운드 액티비티가 됨).
    * 액티비티 A: `onStop()` 호출됨 (액티비티 B가 액티비티 A를 완전히 덮는 경우).

3.  **액티비티 B에서 액티비티 A로 돌아오기:**
    * 액티비티 B: `onPause()` 호출됨.
    * 액티비티 A: `onRestart()` -> `onStart()` -> `onResume()` 호출됨 (포커스를 다시 얻고 포그라운드로 돌아옴).
    * 액티비티 B: `onStop()` -> `onDestroy()` 호출됨.

**요약**
두 액티비티 사이를 전환할 때, 포그라운드에 있던 액티비티는 항상 백그라운드로 이동하기 전에 `onPause()` 라이프사이클을 거칩니다. 새로 시작되는 액티비티는 `onCreate()`부터 시작하는 라이프사이클을 통해 포커스를 가져옵니다. 이전 액티비티로 돌아올 때는 `onRestart()` 또는 `onResume()`을 사용하여 일시 중지된 상태에서 재개되며, 나가는 액티비티는 수행된 작업에 따라 중지(`onStop`)되거나 소멸(`onDestroy`)됩니다. 이러한 라이프사이클 전환을 이해하면 적절한 리소스 관리와 원활한 사용자 경험을 보장할 수 있습니다.

---

### 💡 프로 팁: 액티비티의 라이프사이클 인스턴스란 무엇인가요?

모든 **액티비티(Activity)** 는 **`Lifecycle` 인스턴스**와 연관되어 있으며, 이는 액티비티의 라이프사이클 이벤트를 관찰하고 이에 반응하는 방법을 제공합니다. `Lifecycle` 인스턴스는 Jetpack 라이프사이클 라이브러리의 일부이며, 개발자가 액티비티의 라이프사이클 변화에 대응하여 코드를 깔끔하고 구조적인 방식으로 관리할 수 있게 해줍니다.

`lifecycle` 속성은 `ComponentActivity` 하위 클래스 모두에서 노출되는 `Lifecycle` 클래스의 인스턴스입니다. 이는 액티비티의 현재 라이프사이클 상태를 나타내며, `onCreate`, `onStart`, `onResume` 등의 라이프사이클 이벤트를 해당 메서드를 직접 오버라이드하지 않고도 관찰할 수 있는 방법을 제공합니다. 이는 특히 UI 업데이트, 리소스 정리 또는 `LiveData`를 라이프사이클 인식 방식으로 관찰하는 데 유용합니다.

**Lifecycle 인스턴스 사용 방법**

`Lifecycle` 인스턴스를 사용하면 특정 라이프사이클 이벤트에 응답하는 `LifecycleObserver` 또는 `DefaultLifecycleObserver` 객체를 추가할 수 있습니다. 예를 들어, `onStart`와 `onStop`을 수신하려면 다음과 같이 옵저버를 등록할 수 있습니다:

*(역자 주: 원문에는 코드 예시가 없었지만, 일반적인 사용 패턴은 액티비티의 `onCreate` 등에서 `lifecycle.addObserver(MyObserver())`와 같이 옵저버를 등록하는 것입니다. `MyObserver` 클래스는 `@OnLifecycleEvent(Lifecycle.Event.ON_START)` 같은 어노테이션이 붙은 메서드를 포함하거나 `DefaultLifecycleObserver`를 구현하여 `onStart()`, `onStop()` 등의 메서드를 오버라이드합니다.)*

```kotlin
class MyObserver : DefaultLifecycleObserver {

  override fun onStart(owner: LifecycleOwner) {
    super.onStart(owner)
  }

  override fun onStop(owner: LifecycleOwner) {
    super.onStop(owner)
  }
}

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(MyObserver())
    }
}
```

이 예시에서 `MyObserver` 클래스는 `MainActivity` 인스턴스의 라이프사이클 변화를 관찰합니다. 액티비티가 `STARTED` 또는 `STOPPED` 상태에 들어가면 해당 메서드가 호출됩니다.

**Lifecycle 인스턴스 사용의 이점**

* **라이프사이클 인식(Lifecycle Awareness):** `Lifecycle` 인스턴스를 사용하면 컴포넌트가 액티비티의 라이프사이클 상태를 인식하게 되어, 액티비티가 원하지 않는 상태일 때 불필요하거나 잘못된 작업을 방지할 수 있습니다.
* **관심사 분리(Separation of Concerns):** 라이프사이클에 의존하는 로직을 액티비티 클래스 밖으로 이동시켜 가독성과 유지보수성을 향상시킬 수 있습니다.
* **Jetpack 라이브러리와의 통합:** `LiveData`, `ViewModel`과 같은 라이브러리는 `Lifecycle` 인스턴스와 원활하게 작동하도록 설계되어, 반응형 프로그래밍과 효율적인 리소스 관리를 가능하게 합니다.

**요약**

액티비티의 `Lifecycle` 인스턴스는 안드로이드의 현대 아키텍처의 핵심 구성 요소로, 개발자가 라이프사이클 이벤트를 구조적이고 재사용 가능한 방식으로 처리할 수 있게 해줍니다. `LifecycleObserver` 및 기타 Jetpack 구성 요소를 활용하여 더 견고하고 유지보수하기 쉬운 애플리케이션을 만들 수 있습니다.

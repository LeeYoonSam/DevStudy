# 안드로이드는 메모리 관리를 어떻게 처리하며, 메모리 누수를 어떻게 피할 수 있나요?

안드로이드는 **가비지 컬렉션(garbage collection)** 메커니즘을 통해 **메모리**를 관리합니다. 이 메커니즘은 사용되지 않는 메모리를 자동으로 회수하여 활성 애플리케이션과 서비스에 효율적인 할당을 보장합니다. 이는 **관리형 메모리 환경(managed memory environment)** 에 의존하는데, 이는 개발자가 C++과 같은 언어에서처럼 수동으로 메모리를 할당하고 해제할 필요가 없다는 것을 의미합니다. Dalvik 또는 ART 런타임(이 장 뒷부분에서 배우게 됩니다)은 메모리 사용량을 모니터링하고, 더 이상 참조되지 않는 객체를 정리하며, 과도한 메모리 소비를 방지합니다.

안드로이드는 시스템 메모리가 부족할 때 백그라운드 프로세스를 종료하기 위해 **로우 메모리 킬러(low-memory killer)** 를 사용하며, 포그라운드 애플리케이션의 원활한 작동을 우선시합니다. 개발자는 시스템 성능에 미치는 영향을 최소화하기 위해 앱이 리소스를 효율적으로 활용하도록 해야 합니다.

**안드로이드에서 메모리 누수를 피하는 방법**

**메모리 누수(Memory leak)** 는 애플리케이션이 더 이상 필요하지 않은 객체에 대한 참조를 계속 보유하여 가비지 컬렉터가 메모리를 회수하지 못하게 할 때 발생합니다. 일반적인 원인으로는 부적절한 라이프사이클 관리, 정적 참조(static references) 또는 컨텍스트(Context)에 대한 오래 지속되는 참조 유지가 있습니다.

**메모리 누수를 피하기 위한 모범 사례**

1. **라이프사이클 인식 컴포넌트 사용 (Use Lifecycle-Aware Components):** `ViewModel`, [`collectAsStateWithLifecycle`](https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#extension-functions)과 함께 사용하는 `Flow` 또는 `LiveData`와 같은 라이프사이클 인식 컴포넌트를 활용하면 해당 라이프사이클이 종료될 때 리소스가 적절하게 해제되도록 보장합니다. 이러한 컴포넌트들은 연관된 라이프사이클이 더 이상 활성 상태가 아니거나 특정 상태로 전환될 때 자동으로 정리를 관리합니다.

2. **컨텍스트(Context) 참조 보유 피하기 (Avoid Holding References to Context):** 정적 필드나 싱글톤과 같은 오래 지속되는 객체에서 액티비티(Activity)나 컨텍스트(Context)에 대한 참조를 유지하지 마세요. 대신, 가능하면 `ApplicationContext`를 사용하세요. 이는 액티비티나 프래그먼트(Fragment)의 라이프사이클에 묶여 있지 않기 때문입니다.

3. **리스너 및 콜백 등록 해제 (Unregister Listeners and Callbacks):** 적절한 라이프사이클 메서드에서 항상 리스너, 옵저버 또는 콜백을 등록 해제하세요. 예를 들어, `onPause()` 또는 `onStop()`에서 `BroadcastReceiver`를 등록 해제합니다.

4. **중요하지 않은 객체에 WeakReference 사용 (WeakReferences for Non-Critical Objects):** 강한 참조(strong references)가 필요하지 않은 객체에는 `WeakReference`(약한 참조)를 사용하세요. 이는 메모리가 필요할 때 가비지 컬렉터가 해당 객체를 회수할 수 있도록 합니다.

5. **누수 탐지 도구 사용 (Use Tools to Detect Leaks):** 개발 중에 메모리 누수를 식별하고 수정하기 위해 `LeakCanary`와 같은 도구를 활용하세요. 이 도구는 어떤 객체가 메모리 누수를 일으키는지, 그리고 어떻게 해결할 수 있는지에 대한 통찰력을 제공합니다. 또한, Android Studio의 **Memory Profiler(메모리 프로파일러)** 를 사용하여 메모리 누수 및 버벅거림, 멈춤, 심지어 앱 비정상 종료로 이어질 수 있는 메모리 변동(memory churn)을 식별할 수 있습니다.

6. **뷰(View)에 대한 정적 참조 피하기 (Avoid Static References to Views):** 뷰는 정적 필드에 저장되어서는 안 됩니다. 이는 액티비티 컨텍스트에 대한 참조를 유지하여 메모리 누수를 유발할 수 있습니다.

7. **리소스 닫기 (Close Resources):** 파일 스트림, 커서 또는 데이터베이스 연결과 같은 리소스는 더 이상 필요하지 않을 때 항상 명시적으로 해제(닫기)하세요. 예를 들어, 데이터베이스 쿼리 후에는 `Cursor`를 닫습니다.

8. **프래그먼트와 액티비티 현명하게 사용 (Use Fragments and Activities Wisely):** 프래그먼트를 과도하게 사용하거나 프래그먼트 간의 참조를 부적절하게 유지하지 마세요. `onDestroyView()` 또는 `onDetach()`에서 프래그먼트 참조를 정리하세요.

**요약**

안드로이드의 메모리 관리는 효율적이지만, 개발자는 메모리 누수를 방지하기 위해 모범 사례를 따라야 합니다. 라이프사이클 인식 컴포넌트를 사용하고, 컨텍스트나 뷰에 대한 정적 참조를 피하며, `LeakCanary`와 같은 도구를 활용하면 누수 가능성을 크게 줄일 수 있습니다. 적절한 라이프사이클 이벤트에서 리소스를 올바르게 관리하고 정리하면 더 부드러운 앱 성능과 사용자 경험을 보장할 수 있습니다.

---

## Q. 애플리케이션에서 메모리 누수의 일반적인 원인은 무엇이며, 개발자는 이를 어떻게 예방할 수 있나요?

애플리케이션에서 메모리 누수(Memory Leak)는 더 이상 사용되지 않는 객체가 메모리에서 해제되지 못하고 남아 시스템 리소스를 불필요하게 점유하는 현상을 말합니다. 이는 앱 성능 저하, 버벅거림, 심하면 `OutOfMemoryError`를 발생시켜 앱이 비정상 종료되는 원인이 됩니다.

**메모리 누수의 일반적인 원인**

1.  **컨텍스트(Context) 누수:**
    * **원인:** 액티비티(Activity)나 프래그먼트(Fragment)의 컨텍스트를 정적(static) 변수, 싱글톤 객체, 백그라운드 스레드 등 생명주기가 더 긴 객체에서 직접 참조하고 해제하지 않는 경우 발생합니다. 액티비티가 종료되어도 가비지 컬렉션(GC) 대상이 되지 못하고 메모리에 남게 됩니다.
    * **예:** `static` 변수에 액티비티 컨텍스트 저장, 싱글톤 내부에서 액티비티 컨텍스트 참조 유지.

2.  **등록 해제되지 않은 리스너/콜백/리시버:**
    * **원인:** 센서 리스너, 위치 리스너, 각종 콜백, `BroadcastReceiver` 등을 등록한 후, 해당 컴포넌트(주로 액티비티/프래그먼트)의 생명주기에 맞춰 `unregister` 또는 `remove`를 호출하여 해제하지 않는 경우 발생합니다. 리스너/리시버는 내부적으로 액티비티 등을 참조하고 있으므로 메모리 누수로 이어집니다.

3.  **정적(Static) 뷰 또는 액티비티 참조:**
    * **원인:** 뷰(View) 객체나 액티비티 객체를 `static` 변수에 직접 할당하는 경우입니다. `static` 변수는 앱 프로세스가 살아있는 동안 계속 유지되므로, 참조된 뷰나 액티비티(및 이와 연결된 컨텍스트)가 절대 해제되지 않습니다.

4.  **비정적(Non-Static) 내부 클래스 및 익명 클래스:**
    * **원인:** 비정적 내부 클래스(inner class)나 익명 클래스(anonymous class)는 자동으로 외부 클래스의 인스턴스에 대한 암묵적인 참조를 갖습니다. 만약 이 내부 클래스의 인스턴스가 외부 클래스(예: 액티비티)보다 오래 살아남게 되면(예: 백그라운드 스레드로 전달되어 계속 실행될 때), 외부 클래스 인스턴스의 메모리 누수를 유발합니다. `Handler`를 비정적 내부 클래스로 사용할 때 흔히 발생합니다.

5.  **백그라운드 스레드/작업:**
    * **원인:** `Thread`, `AsyncTask` (현재는 deprecated), `Coroutine` 등이 액티비티나 뷰를 참조하는 상태에서 액티비티가 종료되어도 백그라운드 작업이 계속 실행될 경우, 해당 액티비티/뷰에 대한 참조가 남아 누수가 발생할 수 있습니다.

6.  **닫히지 않은 리소스:**
    * **원인:** `Cursor`, `InputStream`/`OutputStream`, `File`, 네트워크 소켓, `SQLiteDatabase` 객체 등을 사용한 후 명시적으로 `close()` 메서드를 호출하여 닫지 않으면 관련 메모리뿐만 아니라 시스템 리소스 자체의 누수가 발생할 수 있습니다.

7.  **비트맵(Bitmap) 관리:**
    * **원인:** 크기가 큰 비트맵 객체를 필요 이상으로 오래 참조하거나, 더 이상 사용하지 않을 때 명확하게 해제하지 않으면 쉽게 메모리 부족 문제를 일으킬 수 있습니다.

**메모리 누수 예방 방법**

1.  **Application Context 사용:** 액티비티 생명주기와 무관하게 컨텍스트가 필요하다면, 액티비티 컨텍스트 대신 `getApplicationContext()`를 사용합니다. 단, UI 관련 작업에는 액티비티 컨텍스트가 필요하므로 주의해야 합니다.
2.  **리스너/콜백/리시버 등록 해제 철저히:** 해당 컴포넌트의 생명주기에 맞춰 `onPause()`, `onStop()`, `onDestroy()`, `onDestroyView()` 등 적절한 시점에 반드시 등록 해제(`unregister`, `remove`)합니다.
3.  **정적(Static) 참조 최소화:** 뷰나 액티비티 컨텍스트를 정적 변수에 저장하지 않습니다. 꼭 필요하다면 `WeakReference` 사용을 고려하거나, 생명주기 관리에 각별히 주의합니다.
4.  **내부 클래스는 가급적 정적(Static)으로:** 내부 클래스가 외부 클래스의 멤버에 접근할 필요가 없다면 `static`으로 선언하여 외부 참조를 없앱니다. 접근이 필요하다면 `WeakReference`를 사용하여 외부 클래스를 참조하도록 합니다.
5.  **라이프사이클 인식 컴포넌트 활용:** `ViewModel`, `LiveData`, `LifecycleOwner`, `LifecycleObserver`, `Coroutine`의 `lifecycleScope` 또는 `viewModelScope` 등 Jetpack 라이브러리의 컴포넌트를 사용하면 생명주기를 안전하게 관리하고 관련 리소스를 자동으로 정리하는 데 도움이 됩니다.
6.  **백그라운드 작업 관리:** `Coroutine` 사용 시 적절한 Scope(범위)를 지정합니다. `AsyncTask`나 `Thread` 사용 시 액티비티/프래그먼트 소멸 시 작업을 취소하거나, UI 참조 시 `WeakReference`를 사용하고 null 체크를 합니다. 장기 실행 작업은 `WorkManager` 사용을 고려합니다.
7.  **리소스 명시적 해제:** `Cursor`, 스트림, 데이터베이스 객체 등은 사용 후 반드시 `finally` 블록이나 Kotlin의 `use` 확장 함수 등을 사용하여 `close()` 메서드를 호출해 닫아줍니다.
8.  **메모리 누수 탐지 도구 활용:** 개발 단계에서 `LeakCanary` 라이브러리를 적용하여 메모리 누수를 자동으로 감지하고 리포트를 받아 수정합니다. Android Studio의 `Memory Profiler`를 사용하여 메모리 사용량 변화를 분석하고 누수 지점을 찾는 것도 중요합니다.
9.  **WeakReference 활용:** 반드시 필요하지 않은 참조에 대해서는 `WeakReference`(약한 참조)를 사용하여, GC가 메모리가 필요할 때 해당 객체를 수거해 갈 수 있도록 허용합니다.

이러한 원인들을 이해하고 예방 방법을 꾸준히 실천하면 메모리 누수를 크게 줄여 안정적이고 성능 좋은 애플리케이션을 만들 수 있습니다.

## Q. 안드로이드의 가비지 컬렉션 메커니즘은 어떻게 작동하며, 개발자는 애플리케이션의 메모리 누수를 탐지하고 수정하기 위해 어떤 도구를 사용할 수 있나요?

**1. 안드로이드 가비지 컬렉션(GC) 메커니즘 작동 방식**

안드로이드는 ART(과거 Dalvik) 런타임 환경에서 앱을 실행하며, 메모리 관리를 위해 **가비지 컬렉션(Garbage Collection, GC)** 메커니즘을 사용합니다. 주요 작동 방식은 다음과 같습니다.

* **관리형 힙(Managed Heap):** 앱에서 생성되는 객체들은 관리형 힙이라는 메모리 영역에 할당됩니다.
* **자동 메모리 관리:** 개발자가 C/C++처럼 수동으로 메모리를 해제하지 않아도, GC가 자동으로 더 이상 사용되지 않는 객체를 찾아 메모리를 회수합니다.
* **도달 가능성(Reachability) 기반:** GC는 '루트(Root)'에서 시작하여 객체 참조 그래프를 탐색합니다. 루트는 현재 실행 중인 스레드의 스택, 정적 변수 등을 포함합니다. 루트로부터 직간접적으로 참조될 수 있는 객체는 '살아있는(reachable)' 객체로 간주됩니다.
* **마크 앤 스윕(Mark and Sweep) (개념적):**
    * **Mark(표시) 단계:** 루트에서 시작하여 도달 가능한 모든 객체를 찾아 '살아있음'으로 표시합니다.
    * **Sweep(수거) 단계:** 힙 전체를 스캔하여 '살아있음'으로 표시되지 않은 객체(즉, 도달 불가능한 객체)를 '가비지(garbage)'로 간주하고 해당 메모리를 회수하여 다른 객체가 사용할 수 있도록 합니다.
* **세대별 GC (Generational GC - 일반적인 최적화):** 성능 향상을 위해 힙을 여러 '세대(generation)'(예: Young Generation, Old Generation)로 나누어 관리합니다.
    * 새 객체는 Young Generation에 할당됩니다. 대부분의 객체는 금방 사용되지 않게 되므로, Young Generation에서 더 자주 GC(Minor GC)가 발생합니다.
    * 여러 번의 Minor GC에서 살아남은 객체는 Old Generation으로 이동(승격)됩니다. Old Generation에서는 GC(Major GC)가 덜 자주 발생하지만, 한 번 실행될 때 더 많은 시간이 소요될 수 있습니다.
* **동시성 GC (Concurrent GC):** 앱 실행 중 GC로 인한 멈춤(Stop-the-world) 시간을 최소화하기 위해, ART는 GC 작업의 일부를 애플리케이션 스레드와 동시에(concurrently) 실행하려고 시도합니다. 하지만 여전히 짧은 멈춤은 발생할 수 있습니다.
* **GC 트리거:** GC는 메모리가 부족하여 새로운 객체를 할당할 수 없거나, 시스템이 정한 특정 메모리 임계점에 도달했을 때 자동으로 실행됩니다. 개발자가 `System.gc()`를 호출하여 GC 실행을 *요청*할 수는 있지만, 실제 실행 여부와 시점은 시스템이 결정하므로 의존해서는 안 됩니다.

**2. 메모리 누수 탐지 및 수정 도구**

개발자는 다음과 같은 도구를 사용하여 애플리케이션의 메모리 누수를 탐지하고 원인을 파악하여 수정할 수 있습니다.

* **Android Studio Memory Profiler (메모리 프로파일러):**
    * **기능:** 앱의 메모리 사용량(자바 힙, 네이티브 힙 등)을 실시간 그래프로 보여줍니다. 특정 시점의 힙 상태를 스냅샷(힙 덤프)으로 캡처하여 분석할 수 있습니다. 어떤 객체가 메모리를 많이 차지하는지, 어떤 코드에서 메모리가 할당되는지 추적하고, GC 이후에도 남아 있는 객체(잠재적 누수)를 식별하는 데 도움을 줍니다. 메모리 변동(churn) 패턴도 파악할 수 있습니다.
    * **사용법:** 앱 실행 시 프로파일러를 연결하고, 누수가 의심되는 시나리오(예: 화면 회전, 특정 화면 반복 진입/이탈)를 수행합니다. 필요시 프로파일러에서 수동으로 GC를 실행시키고, 전후의 힙 덤프를 캡처하여 비교 분석합니다. 힙 덤프 분석기를 통해 GC 루트까지의 참조 경로(shortest path to GC roots) 등을 확인하여 객체가 왜 해제되지 않는지 파악합니다.

* **LeakCanary (라이브러리):**
    * **기능:** Square에서 만든 오픈소스 라이브러리로, 앱의 디버그 빌드에 쉽게 통합할 수 있습니다. 런타임 중에 액티비티, 프래그먼트 등의 누수를 자동으로 감지합니다. 누수가 감지되면 힙 분석을 수행하고, 해당 객체가 GC되지 못하게 막고 있는 참조 경로(Leak Trace)를 명확하게 보여주는 알림을 띄웁니다.
    * **사용법:** `build.gradle` 파일에 디버그용 의존성을 추가합니다. (최신 버전은 별도 초기화 코드 없이 자동으로 작동할 수 있습니다.) 앱을 디버그 모드로 실행하고 평소처럼 사용합니다. 누수가 발생하면 LeakCanary 알림이 표시되며, 이를 클릭하면 누수를 유발하는 참조 경로를 상세히 확인할 수 있습니다. 이 정보를 바탕으로 코드를 수정합니다.

* **수동 힙 덤프 분석 (Android Studio 또는 MAT 사용):**
    * **기능:** Memory Profiler나 코드 상에서 힙 덤프(`.hprof` 파일)를 직접 생성한 후, Android Studio의 내장 뷰어나 독립 실행형 도구인 MAT(Eclipse Memory Analyzer Tool)를 사용하여 상세하게 분석합니다. 이를 통해 힙 내의 모든 객체, 객체 간의 참조 관계, 특정 클래스의 인스턴스 목록, 메모리를 많이 차지하는 객체(Dominator Tree) 등을 심층적으로 조사할 수 있습니다.
    * **사용법:** 전략적인 지점(예: 특정 작업 전후)에서 힙 덤프를 생성합니다. 분석 도구로 파일을 열어, 해제되었어야 하지만 여전히 존재하는 객체를 찾습니다. 해당 객체가 GC되지 못하는 이유를 'GC 루트까지의 경로' 분석 등을 통해 파악합니다. 여러 힙 덤프를 비교하여 메모리 증가 패턴을 분석할 수도 있습니다.

* **코드 검토 및 정적 분석:**
    * **기능:** 코드 상에서 메모리 누수를 유발할 수 있는 흔한 패턴(예: 잘못된 컨텍스트 사용, 리스너 등록 해제 누락, 내부 클래스 문제 등)을 직접 검토합니다. Android Studio에 내장된 Lint와 같은 정적 분석 도구는 일부 잠재적인 누수 시나리오(예: 비정적 내부 핸들러)에 대해 경고를 표시해 줄 수 있습니다.
    * **사용법:** 주기적으로 코드 리뷰를 수행하며 생명주기 관리, 컨텍스트 사용, 백그라운드 작업, 리소스 처리 부분을 중점적으로 확인합니다. Lint 경고를 주의 깊게 살펴보고 수정합니다.

이러한 도구들과 기법을 적절히 활용하면 메모리 누수의 원인을 효과적으로 찾아내고 수정하여 더 안정적이고 성능 좋은 앱을 만들 수 있습니다.
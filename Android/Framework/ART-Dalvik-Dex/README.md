# 안드로이드 런타임(ART), 달빅(Dalvik), Dex 컴파일러란 무엇인가요?

안드로이드 애플리케이션은 기기에서 실행되기 위해 고유한 런타임 환경과 컴파일 과정에 의존합니다. [**안드로이드 런타임(ART)**, **달빅(Dalvik)**, 그리고 **Dex 컴파일러**](https://source.android.com/docs/core/runtime)는 이 과정에서 중요한 역할을 수행하며, 앱이 성능, 메모리 효율성 및 안드로이드 기기와의 호환성에 최적화되도록 보장합니다.

### 안드로이드 런타임 (ART, Android Runtime)

안드로이드 런타임(ART)은 안드로이드 4.4 (킷캣)에서 도입되어 안드로이드 5.0 (롤리팝)부터 기본 런타임이 된 **관리형 런타임 환경**입니다. 이는 안드로이드 앱 실행을 위한 런타임으로 달빅을 대체하며 여러 개선 사항을 도입했습니다.

ART는 **AOT(Ahead-of-Time) 컴파일**을 사용하여 애플리케이션을 컴파일하며, 앱 설치 중에 바이트코드를 머신 코드로 변환합니다. 이를 통해 런타임 시 JIT(Just-in-Time) 컴파일의 필요성을 없애고, 결과적으로 **더 빠른 앱 시작 시간**과 실행 중 **CPU 사용량 감소**를 가져옵니다.

ART의 주요 특징은 다음과 같습니다:

* **향상된 성능:** AOT 컴파일은 최적화된 머신 코드를 생성하여 런타임 오버헤드를 줄입니다.
* **가비지 컬렉션:** ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술을 도입했습니다.
* **디버깅 및 프로파일링 지원:** ART는 상세한 스택 트레이스와 메모리 사용량 분석과 같이 개발자를 위한 향상된 도구를 제공합니다.

### 달빅 (Dalvik)

달빅은 ART 이전에 안드로이드에서 사용되던 원래의 런타임입니다. 제한된 메모리와 처리 능력을 위해 최적화된 가상 머신 환경에서 애플리케이션을 실행하도록 설계되었습니다.

달빅은 **JIT(Just-in-Time) 컴파일**을 사용하며, 런타임에 바이트코드를 머신 코드로 변환합니다. 이 방식은 앱 설치에 필요한 시간을 줄이지만, 즉석 컴파일로 인해 런타임 오버헤드가 증가합니다.

달빅의 주요 특징은 다음과 같습니다:

* **압축된 바이트코드:** 달빅은 `.dex` (Dalvik Executable) 파일을 사용하며, 이는 낮은 메모리 사용량과 빠른 실행을 위해 최적화되어 있습니다.
* **레지스터 기반 VM:** 달빅은 (자바 가상 머신과 같은) 스택 기반이 아닌 레지스터 기반으로, 명령어 효율성을 향상시킵니다.

달빅의 한계점인 느린 앱 시작 시간과 높은 CPU 사용량으로 인해 최신 안드로이드 버전에서는 ART로 대체되었습니다.

### Dex 컴파일러 (Dex Compiler)

Dex 컴파일러는 (자바/코틀린 컴파일러에 의해 생성된) 자바 바이트코드를 `.dex` (Dalvik Executable) 파일로 변환합니다. 이 `.dex` 파일들은 달빅 및 ART 런타임 환경에 맞게 압축되고 최적화됩니다.

Dex 컴파일러는 안드로이드 애플리케이션이 기기에서 효율적으로 실행되도록 보장하는 데 중요한 역할을 합니다. Dex 컴파일러의 주요 측면은 다음과 같습니다:

* **멀티덱스(Multi-dex) 지원:** 64K 메서드 제한을 초과하는 애플리케이션의 경우, Dex 컴파일러는 바이트코드를 여러 `.dex` 파일로 분할하는 것을 지원합니다.
* **바이트코드 최적화:** 컴파일러는 안드로이드 기기에서의 더 나은 메모리 사용량과 실행 성능을 위해 바이트코드를 최적화합니다.

Dex 컴파일 과정은 안드로이드 빌드 시스템에 통합되어 있으며, 앱 개발의 빌드 단계 중에 발생합니다.

### 달빅에서 ART로의 전환

달빅에서 ART로의 전환은 안드로이드 런타임 환경에 상당한 개선을 가져왔습니다. ART의 AOT 컴파일, 향상된 가비지 컬렉션 및 프로파일링 기능은 더 나은 개발자 및 사용자 경험을 제공합니다. 달빅용으로 설계된 앱은 `.dex` 파일을 사용하기 때문에 ART와 완벽하게 호환되어 개발자에게 원활한 마이그레이션을 보장합니다.

### 요약

안드로이드 런타임(ART), 달빅, Dex 컴파일러는 안드로이드에서 앱 실행의 기반을 형성합니다. AOT 컴파일과 향상된 성능을 갖춘 ART는 JIT 컴파일에 의존했던 달빅을 대체했습니다. Dex 컴파일러는 자바 바이트코드를 두 런타임 환경 모두에 최적화된 `.dex` 파일로 변환하여 그 간극을 메웁니다. 이 구성 요소들은 함께 안드로이드 기기에서 효율적이고 빠르며 안정적인 앱 실행을 보장합니다.

---

## Q. ART의 AOT(Ahead-of-Time) 컴파일은 달빅의 JIT(Just-in-Time) 컴파일과 어떻게 다르며, 이것이 앱 시작 시간과 CPU 사용량에 어떤 영향을 미치나요?

안드로이드 런타임(ART)의 **AOT(Ahead-of-Time, 사전 컴파일)** 방식과 이전 달빅(Dalvik) 런타임의 **JIT(Just-in-Time, 실시간 컴파일)** 방식은 애플리케이션 코드의 컴파일 시점과 방식에서 주요한 차이가 있으며, 이는 앱 시작 시간 및 CPU 사용량에 직접적인 영향을 미칩니다.

### 1. JIT (Just-in-Time) 컴파일 - 달빅(Dalvik) 방식

* **컴파일 시점:** 애플리케이션이 **실행되는 동안 (런타임에)** 필요에 따라 코드가 컴파일됩니다.
* **작동 방식:**
    1.  앱이 시작되면 달빅 가상 머신(VM)은 `.dex` 파일 형태의 바이트코드를 해석(interpret)하거나, 자주 사용되거나 성능에 중요한 부분(hotspot)을 감지하면 해당 부분의 바이트코드를 그 즉시(just-in-time) 네이티브 머신 코드로 컴파일합니다.
    2.  컴파일된 머신 코드는 메모리에 캐시되어 다음 호출 시에는 더 빠르게 실행될 수 있습니다.
    3.  앱이 종료되면 캐시된 머신 코드는 사라지거나, 다음 실행 시 다시 JIT 컴파일 과정을 거칠 수 있습니다 (일부 캐싱 전략이 있지만 기본적으로는 런타임 중심).
* **앱 시작 시간 및 CPU 사용량에 미치는 영향:**
    * **앱 시작 시간:** 앱이 시작되거나 새로운 코드 경로가 실행될 때마다 해당 부분의 JIT 컴파일 과정이 필요하므로, 이 컴파일 오버헤드로 인해 **앱 시작 시간이 상대적으로 느립니다.**
    * **CPU 사용량:** 앱 실행 중, 특히 초기 실행 단계나 새로운 기능 사용 시, JIT 컴파일러가 동작해야 하므로 **CPU 사용량이 일시적으로 높아집니다.** 이는 배터리 소모 증가로 이어질 수도 있습니다.

### 2. AOT (Ahead-of-Time) 컴파일 - ART 방식

* **컴파일 시점:** 애플리케이션이 기기에 **설치될 때** (또는 기기가 유휴 상태일 때 시스템 앱이나 업데이트의 경우) 미리 코드가 컴파일됩니다.
* **작동 방식:**
    1.  앱 설치 과정에서 `.dex` 파일의 바이트코드 대부분 또는 전체가 대상 기기에 최적화된 네이티브 머신 코드로 변환되어 OAT 파일 형태로 저장됩니다.
    2.  앱이 실행될 때는 이미 컴파일된 네이티브 머신 코드를 직접 실행하므로, 런타임에 별도의 컴파일 과정이 거의 필요 없습니다.
* **앱 시작 시간 및 CPU 사용량에 미치는 영향:**
    * **앱 시작 시간:** 앱 실행 시점에 이미 코드가 네이티브 머신 코드로 준비되어 있으므로, JIT 컴파일의 오버헤드가 없어 **앱 시작 시간이 훨씬 빠릅니다.**
    * **CPU 사용량:** 런타임에 컴파일 작업을 수행할 필요가 없거나 매우 적으므로, 앱 실행 중 **CPU 사용량이 전반적으로 낮아지고** 더 부드러운 성능을 제공합니다. 이는 배터리 효율성 향상에도 기여합니다.

### 3. AOT와 JIT의 주요 차이점 및 영향 요약

| 특징 | JIT 컴파일 (달빅) | AOT 컴파일 (ART) |
| :--- | :--- | :--- |
| **컴파일 시점** | 앱 실행 중 (런타임) | 앱 설치 시 (사전) |
| **앱 시작 시간** | 느림 (런타임 컴파일 오버헤드) | 빠름 (미리 컴파일된 코드 실행) |
| **CPU 사용량 (실행 중)** | 높음 (특히 초기/웜업 시 컴파일 작업으로 인해) | 낮음 (런타임 컴파일 거의 불필요) |
| **앱 설치 시간** | 빠름 (사전 컴파일 단계 없음) | 김 (AOT 컴파일 시간 소요)  |
| **설치 후 앱 용량** | 작음 (`.dex` 바이트코드 위주)  | 큼 (컴파일된 네이티브 머신 코드 추가 저장) |
| **최적화 수준** | 제한적 (런타임 정보 활용 가능성) | 더 광범위한 최적화 가능 (설치 시 시간적 여유) |

### 4. 현대 ART의 하이브리드 접근 방식 (추가 정보)

최신 안드로이드 버전의 ART는 순수한 AOT 방식만을 고집하지 않고, JIT 컴파일과 프로파일 기반 컴파일(Profile-Guided Compilation, PGC)을 함께 사용하는 **하이브리드 방식**을 채택하여 장점들을 결합합니다.

* 앱 설치 시에는 AOT 컴파일을 통해 기본적인 성능을 확보합니다.
* 앱 실행 중에는 JIT 컴파일러가 일부 코드를 처리하거나, 어떤 코드가 자주 사용되는지에 대한 프로파일링 정보를 수집합니다.
* 기기가 유휴 상태이고 충전 중일 때, ART는 수집된 프로파일링 정보를 바탕으로 자주 사용되는 "핫(hot)" 코드 경로를 더욱 최적화된 네이티브 코드로 다시 AOT 컴파일합니다.

이러한 하이브리드 접근 방식을 통해 ART는 앱 설치 시간, 저장 공간 사용, 런타임 성능, 배터리 효율성 사이의 균형을 맞추려고 노력합니다.

**결론적으로, ART의 AOT (및 하이브리드) 컴파일 방식은 달빅의 JIT 컴파일 방식에 비해 앱 시작 시간을 크게 단축시키고, 앱 실행 중 CPU 사용량을 낮춰 전반적인 애플리케이션 성능과 사용자 경험을 향상시키는 데 기여합니다.**
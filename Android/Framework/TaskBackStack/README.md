# 태스크(Task)와 백 스택(Back Stack)이란 무엇인가요?
태스크(Task) 는 사용자가 특정 목표를 달성하기 위해 상호작용하는 액티비티(Activity)들의 모음입니다. 
태스크는 백 스택(Back Stack) 으로 구성되는데, 이는 액티비티가 시작될 때 추가되고 사용자가 뒤로 이동하거나 시스템이 리소스를 회수할 때 제거되는 후입선출(LIFO, Last-In, First-Out) 구조입니다.

## 태스크 (Tasks)
태스크는 일반적으로 런처(홈 화면)나 인텐트(Intent)를 통해 액티비티가 시작될 때 개시됩니다. 
태스크는 인텐트와 액티비티 실행 모드(launch mode)가 어떻게 설정되느냐에 따라 여러 애플리케이션과 그 액티비티들에 걸쳐 있을 수 있습니다. 
예를 들어, 이메일 앱에서 링크를 클릭하면 동일한 태스크의 일부로 브라우저가 열릴 수 있습니다. 
태스크는 연관된 액티비티들이 소멸(destroy)될 때까지 활성 상태로 유지됩니다.

## 백 스택 (Back Stack)
백 스택은 태스크 내 액티비티들의 기록(history)을 유지합니다. 
사용자가 새 액티비티로 이동하면, 현재 액티비티는 스택에 푸시(push, 추가)됩니다. 
뒤로 가기 버튼을 누르면 스택의 최상위 액티비티가 팝(pop, 제거)되고, 그 아래에 있던 액티비티가 다시 시작(resume)됩니다. 
이 메커니즘은 직관적인 내비게이션과 사용자 작업 흐름의 연속성을 보장합니다.

태스크와 백 스택은 액티비티 실행 모드(launch modes) 와 인텐트 플래그(intent flags) 에 의해 영향을 받습니다. 
실행 모드와 인텐트 플래그는 태스크와 백 스택 내에서 액티비티의 동작을 제어하는 데 사용되는 메커니즘입니다. 
이러한 설정을 통해 개발자는 액티비티가 어떻게 시작되고 다른 액티비티와 어떻게 상호작용하는지를 정의할 수 있습니다.

# 실행 모드 (Launch Modes)
실행 모드는 액티비티가 어떻게 인스턴스화되고 백 스택에서 처리되는지를 결정합니다. 안드로이드에는 네 가지 주요 실행 모드가 있습니다.
 * standard: 기본 실행 모드입니다. 액티비티가 시작될 때마다, 설령 인스턴스가 이미 존재하더라도, 액티비티의 새 인스턴스가 생성되어 백 스택에 추가됩니다.
 * singleTop: 만약 액티비티의 인스턴스가 이미 백 스택의 최상단에 존재한다면, 새 인스턴스가 생성되지 않습니다. 대신, 기존 인스턴스가 onNewIntent() 메서드에서 인텐트를 처리합니다.
 * singleTask: 태스크 내에는 해당 액티비티의 인스턴스가 단 하나만 존재합니다. 만약 인스턴스가 이미 존재한다면, 해당 태스크가 맨 앞으로 오고 기존 인스턴스의 onNewIntent()가 호출됩니다. 앱의 진입점(entry point) 역할을 하는 액티비티에 유용합니다.
 * singleInstance: singleTask와 유사하지만, 해당 액티비티는 다른 액티비티들과 분리되어 자체 태스크에 배치됩니다. 이는 다른 어떤 액티비티도 같은 태스크의 일부가 될 수 없음을 보장합니다.

## 인텐트 플래그 (Intent Flags)
인텐트 플래그는 인텐트가 전송될 때 액티비티가 시작되는 방식이나 백 스택의 동작을 수정하는 데 사용됩니다. 일반적으로 사용되는 플래그는 다음과 같습니다.
 * FLAG_ACTIVITY_NEW_TASK: 액티비티를 새 태스크에서 시작하거나, 해당 태스크가 이미 존재하면 그 태스크를 맨 앞으로 가져옵니다.
 * FLAG_ACTIVITY_CLEAR_TOP: 만약 액티비티가 백 스택에 이미 존재한다면, 그 위에 있는 모든 액티비티를 제거하고 기존 인스턴스가 인텐트를 처리합니다. (singleTop과 함께 사용될 때 동작이 약간 다를 수 있습니다.)
 * FLAG_ACTIVITY_SINGLE_TOP: 액티비티가 백 스택의 최상단에 있다면 새 인스턴스를 생성하지 않도록 합니다. 종종 다른 플래그와 함께 사용됩니다.
 * FLAG_ACTIVITY_NO_HISTORY: 액티비티가 백 스택에 추가되는 것을 막습니다. 즉, 해당 액티비티를 벗어나면 유지되지 않습니다.

## 사용 사례
 * 실행 모드는 주로 AndroidManifest.xml 파일의 <activity> 태그 아래에 선언되어, 개발자가 액티비티의 기본 동작을 설정할 수 있게 합니다.
 * 인텐트 플래그는 인텐트를 생성할 때 프로그래밍 방식으로 적용되어, 특정 시나리오에 대해 더 많은 유연성을 제공합니다.

### 예시
```kotlin
val intent = Intent(this, SecondActivity::class.java).apply {
    // 액티비티를 새 태스크에서 시작하거나 기존 태스크를 앞으로 가져옴
    // 만약 SecondActivity가 이미 스택에 있다면 그 위의 액티비티들을 제거
    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
}
startActivity(intent)
```
이 예시에서는 SecondActivity가 아직 존재하지 않으면 새 태스크에서 시작됩니다. 만약 이미 존재한다면, 그 위에 있는 모든 액티비티가 제거됩니다.

## 요약
- 태스크와 백 스택은 안드로이드 내비게이션 모델의 핵심으로, 액티비티의 생명주기와 내비게이션 기록을 관리하여 사용자 친화적인 작업 흐름을 가능하게 합니다. 
- 실행 모드는 액티비티가 태스크 내에서 어떻게 시작되고 관리되는지에 대한 기본 동작을 정의하는 반면, 인텐트 플래그는 유사한 동작에 대해 런타임 제어를 제공합니다. 
- 이 둘을 함께 사용하여 액티비티 생명주기와 백 스택 내비게이션을 정밀하게 관리할 수 있습니다. 자세한 정보는 태스크 및 백 스택 공식 문서를 확인하세요.


## Q. singleTask와 singleInstance 실행 모드의 차이점은 무엇이며, 각각 어떤 시나리오에서 사용하나요?
singleTask와 singleInstance는 안드로이드 액티비티 실행 모드 중 인스턴스가 하나만 존재하도록 강제하는 점에서 유사하지만, 태스크(Task) 관리 방식에서 중요한 차이가 있습니다.

1. singleTask 실행 모드
 * 동작 방식:
   * 액티비티를 시작할 때, 시스템은 해당 액티비티와 동일한 taskAffinity (태스크 선호도)를 가진 태스크가 있는지 확인합니다.
   * 동일한 taskAffinity의 태스크가 있으면: 해당 태스크 내에서 액티비티 인스턴스를 찾습니다.
     * 인스턴스가 이미 존재하면: 시스템은 새 인스턴스를 만들지 않고, 기존 태스크를 포그라운드(foreground)로 가져오면서 해당 액티비티 위의 모든 액티비티를 스택에서 제거(clear top)합니다. 그리고 기존 인스턴스의 onNewIntent() 메서드를 호출하여 새 인텐트를 전달합니다.
     * 인스턴스가 없으면: 해당 태스크의 스택 최상단에 새 인스턴스를 생성합니다.
   * 동일한 taskAffinity의 태스크가 없으면: 새 태스크를 생성하고, 그 태스크의 루트(root)에 액티비티의 새 인스턴스를 생성합니다.
   * 중요 특징: singleTask 액티비티가 속한 태스크에는 다른 액티비티들(같은 앱 또는 다른 앱의 액티비티)이 함께 존재할 수 있습니다.
 * 사용 시나리오:
   * 애플리케이션의 주요 진입점(Entry Point): 앱의 홈 화면이나 메인 화면처럼 사용자가 앱을 시작할 때 가장 먼저 보게 되는 액티비티에 적합합니다. 사용자가 여러 과정을 거쳐 다른 화면으로 이동했다가 다시 홈 버튼 등으로 앱을 실행하면, 중간 과정의 액티비티들을 제거하고 기존의 메인 화면을 보여주기를 원할 때 사용합니다.
   * 알림 등에서 특정 화면으로 바로 이동: 알림을 클릭했을 때 앱의 특정 기능 화면(예: 설정 화면)으로 이동하되, 해당 화면이 이미 스택에 있다면 그 위의 화면들은 제거하고 기존 화면을 재사용하고 싶을 때 유용합니다.
2. singleInstance 실행 모드
 * 동작 방식:
   * singleTask와 유사하게 시스템 전체에서 단 하나의 인스턴스만 존재합니다.
   * 항상 새 태스크를 생성하고, 그 태스크의 루트에 액티비티의 새 인스턴스를 위치시킵니다.
   * 가장 큰 차이점: 이 액티비티가 속한 태스크에는 오직 이 singleInstance 액티비티 인스턴스 하나만 존재합니다. 다른 어떤 액티비티도 이 태스크에 포함될 수 없습니다.
   * 만약 singleInstance 액티비티에서 다른 액티비티를 호출하면, 그 호출된 액티비티는 singleInstance 액티비티의 태스크가 아닌 별도의 태스크(보통 이전에 사용하던 태스크)에서 시작됩니다.
   * 이미 singleInstance 액티비티가 존재할 때 다시 시작 요청이 오면, 새 인스턴스를 만들지 않고 기존 인스턴스가 있는 태스크를 포그라운드로 가져오며 onNewIntent()를 호출합니다.
 * 사용 시나리오:
   * 완전히 독립적인 기능: 앱 내의 다른 흐름과 완전히 분리되어야 하는 특별한 액티비티에 사용됩니다. 예를 들어, 여러 앱에서 호출될 수 있는 공유 다이얼로그나, 시스템의 알림 화면처럼 완전히 독립적인 UI 흐름을 가질 때 고려될 수 있습니다. (예: 구 버전 안드로이드의 브라우저 앱 등)
   * 주의: 이 모드는 안드로이드의 일반적인 태스크/내비게이션 모델과 다르기 때문에 사용자 경험에 혼란을 줄 수 있습니다. 매우 드물게 사용되며, 대부분의 애플리케이션에서는 사용하지 않는 것이 좋습니다. 공식 문서에서도 특별한 경우가 아니면 사용을 권장하지 않습니다.

### 요약: singleTask vs singleInstance

| 특징 | singleTask | singleInstance |
|---|---|---|
| 인스턴스 개수 | 시스템 전체에서 하나 (동일 taskAffinity 내) | 시스템 전체에서 하나 |
| 태스크 생성 | 필요 시 새 태스크 생성 (기존 태스크 재사용 가능) | 항상 새 태스크 생성 |
| 태스크 멤버 | 다른 액티비티와 태스크 공유 가능 | 자신만의 독립적인 태스크 가짐 (다른 액티비티 포함 불가) |
| 호출된 액티비티 | 일반적으로 같은 태스크 내에서 시작됨 | 항상 다른 태스크에서 시작됨 |
| 주 사용처 | 앱의 메인 화면, 주요 진입점 | 매우 독립적인 기능 (사용 시 주의 필요, 드물게 사용) |

결론적으로, singleTask는 앱 내의 주요 흐름을 관리하고 싶을 때 사용하며 다른 액티비티와 공존할 수 있는 반면, singleInstance는 완전히 독립적인 실행 단위처럼 동작해야 하는 매우 특수한 경우에만 사용됩니다.


## Q. 다양한 액티비티 실행 모드는 무엇이며, 태스크 및 백 스택 동작에 어떻게 영향을 미치나요?

안드로이드에는 네 가지 주요 액티비티 실행 모드(Launch Mode)가 있으며, 각각 액티비티 인스턴스가 생성되는 방식과 태스크(Task) 및 백 스택(Back Stack)의 동작 방식에 다르게 영향을 미칩니다.

1. standard (기본값)
 * 동작 방식: 액티비티를 시작하는 인텐트(Intent)가 호출될 때마다 항상 새로운 액티비티 인스턴스를 생성합니다.
 * 태스크 및 백 스택 영향:
   * 새로 생성된 인스턴스는 인텐트를 호출한 액티비티가 속한 태스크의 백 스택 **최상단에 추가(push)** 됩니다.
   * 하나의 태스크 내에 동일한 액티비티의 여러 인스턴스가 존재할 수 있으며, 서로 다른 태스크에도 존재할 수 있습니다.
   * 뒤로 가기 버튼을 누르면 스택의 가장 위에 있는 인스턴스가 제거(pop)되고 이전 액티비티가 나타납니다. 가장 일반적인 방식입니다.
2. singleTop
 * 동작 방식: 액티비티를 시작하려고 할 때, 해당 액티비티의 인스턴스가 현재 태스크의 백 스택 최상단에 이미 존재하는지 확인합니다.
   * 최상단에 존재하면: 새로운 인스턴스를 생성하지 않고, 기존 인스턴스의 onNewIntent() 메서드를 호출하여 새 인텐트를 전달합니다. 스택에는 변화가 없습니다.
   * 최상단에 존재하지 않으면: standard 모드와 동일하게 새로운 인스턴스를 생성하여 스택의 최상단에 추가합니다.
 * 태스크 및 백 스택 영향:
   * 백 스택 최상단에 동일한 액티비티가 중복으로 쌓이는 것을 방지합니다.
   * 예를 들어, 알림을 여러 번 클릭하여 동일한 액티비티를 계속해서 실행하는 경우, 이미 해당 액티비티가 화면에 보이고 있다면 새 인스턴스를 만들지 않고 기존 것을 재활용합니다.
3. singleTask
 * 동작 방식: 액티비티를 시작할 때, 시스템은 동일한 taskAffinity를 가진 태스크 내에 해당 액티비티의 인스턴스가 이미 존재하는지 확인합니다.
   * 인스턴스가 이미 존재하면: 시스템은 새 인스턴스를 생성하지 않습니다. 대신, 해당 인스턴스가 포함된 태스크를 포그라운드로 가져오고, 그 인스턴스 위에 쌓여 있던 모든 액티비티를 백 스택에서 제거합니다(Clear Top). 그리고 기존 인스턴스의 onNewIntent()를 호출합니다.
   * 인스턴스가 존재하지 않으면:
     * 동일한 taskAffinity의 태스크가 있으면 그 태스크의 스택에 새 인스턴스를 추가합니다.
     * 동일한 taskAffinity의 태스크가 없으면 새 태스크를 만들고 그 루트에 새 인스턴스를 추가합니다.
 * 태스크 및 백 스택 영향:
   * 특정 태스크 내에서 해당 액티비티의 인스턴스가 단 하나만 존재하도록 보장합니다. (엄밀히는 taskAffinity 기준)
   * 기존 인스턴스를 재사용할 때 그 위의 스택을 정리하므로, 해당 액티비티를 특정 작업 흐름의 시작점처럼 동작하게 만들 수 있습니다.
   * 필요에 따라 새 태스크를 시작할 수 있습니다.
4. singleInstance
 * 동작 방식: singleTask와 유사하게 시스템 전체에서 단 하나의 인스턴스만 존재하도록 보장합니다.
   * 하지만 singleTask와 달리, 이 액티비티는 항상 새로운, 자신만을 위한 별도의 태스크에서 시작됩니다.
   * 해당 태스크에는 오직 이 singleInstance 액티비티 인스턴스만 존재하며, 다른 어떤 액티비티도 포함될 수 없습니다.
 * 태스크 및 백 스택 영향:
   * 액티비티를 완전히 독립적인 태스크로 분리시킵니다.
   * 이 액티비티에서 다른 액티비티를 시작하면, 그 새 액티비티는 singleInstance 액티비티의 태스크가 아닌 다른 태스크(보통 이전에 사용 중이던 태스크)에서 시작됩니다.
   * 매우 특수한 경우(예: 시스템 전체에서 공유되어야 하는 독립적 기능)에 사용되며, 일반적인 앱에서는 거의 사용하지 않습니다. 사용자 경험에 혼란을 줄 수 있어 사용에 주의가 필요합니다.

### 요약:
각 실행 모드는 액티비티 인스턴스 관리 방식과 태스크/백 스택 상호작용을 정의하여 앱의 내비게이션 흐름과 리소스 사용을 제어합니다.
 * standard: 항상 새 인스턴스 생성, 현재 태스크에 쌓임.
 * singleTop: 현재 태스크 최상단에 있으면 재사용, 아니면 새로 생성.
 * singleTask: 특정 태스크 내 유일한 인스턴스 보장, 재사용 시 상위 스택 정리, 새 태스크 시작 가능.
 * singleInstance: 항상 새 태스크에서 유일한 인스턴스로 존재, 완전 독립적.

개발자는 이러한 실행 모드를 적절히 사용하여 의도한 대로 사용자의 내비게이션 경험을 설계하고 액티비티 인스턴스를 효율적으로 관리할 수 있습니다.

# Android Framework

- [안드이드란?](#안드이드란)
    - [Q. 안드로이드 플랫폼 아키텍처는 리눅스 커널, 안드로이드 런타임 (ART), 하드웨어 추상화 계층 (HAL)을 포함한 여러 계층으로 구성됩니다. 이 구성 요소들이 애플리케이션 실행과 하드웨어 상호작용을 보장하기 위해 어떻게 함께 작동하는지 설명해주세요.](#q-안드로이드-플랫폼-아키텍처는-리눅스-커널-안드로이드-런타임-art-하드웨어-추상화-계층-hal을-포함한-여러-계층으로-구성됩니다-이-구성-요소들이-애플리케이션-실행과-하드웨어-상호작용을-보장하기-위해-어떻게-함께-작동하는지-설명해주세요)
- [인텐트란](#인텐트란)
    - [Q. 명시적 인텐트와 암시적 인텐트의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 사용하시겠습니까?](#q-명시적-인텐트와-암시적-인텐트의-주요-차이점은-무엇이며-어떤-시나리오에서-각각을-사용하시겠습니까)
    - [Q. 안드로이드 시스템은 어떤 앱이 암시적 인텐트를 처리해야 하는지 어떻게 결정하며, 적합한 애플리케이션이 발견되지 않으면 어떻게 됩니까?](#q-안드로이드-시스템은-어떤-앱이-암시적-인텐트를-처리해야-하는지-어떻게-결정하며-적합한-애플리케이션이-발견되지-않으면-어떻게-됩니까)
- [Pending Intent 의 목적은 무엇인가요?](#pending-intent-의-목적은-무엇인가요)
    - [Q. PendingIntent란 무엇이며 일반 Intent와 어떻게 다릅니까? PendingIntent를 사용해야 하는 시나리오를 제시해 주시겠습니까?](#q-pendingintent란-무엇이며-일반-intent와-어떻게-다릅니까-pendingintent를-사용해야-하는-시나리오를-제시해-주시겠습니까)
- [Serializable 과 Parcelable 의 차이점은 무엇인가요?](#serializable-과-parcelable-의-차이점은-무엇인가요)
    - [Q. Android에서 Serializable과 Parcelable의 주요 차이점은 무엇이며, Parcelable이 일반적으로 구성 요소 간에 데이터를 전달하는 데 선호되는 이유는 무엇입니까?](#q-android에서-serializable과-parcelable의-주요-차이점은-무엇이며-parcelable이-일반적으로-구성-요소-간에-데이터를-전달하는-데-선호되는-이유는-무엇입니까)

---

## 안드이드란?

안드로이드는 주로 스마트폰과 태블릿과 같은 모바일 기기를 위해 설계된 오픈 소스 운영 체제입니다. 
구글에 의해 개발되고 유지되고 있으며 리눅스 커널을 기반으로 합니다. 
안드로이드는 다양한 하드웨어 구성과 장치를 지원하는 강력하고 유연한 플랫폼을 제공합니다.

### **Key Features of Android OS**

- Open Source and Customizable
- Application Development with SDK
- Rich Ecosystem of Apps
- Multitasking and Resource Management
- Diverse Hardware Support
- Linux Kernel
- Hardware abstraction layer (HAL)
- Android Runtime (ART) and Core Libraries
- Native C/C++ Libraries
- Android Framework (APIs)
- Applications

### 요약

- 안드로이드는 전 세계적으로 가장 널리 사용되는 모바일 운영 체제이며, 지배적인 시장 점유율을 차지하고 있습니다. 
- 혁신을 촉진하고 개발자가 수십억 명의 사용자를 위한 응용 프로그램을 만들 수 있는 기회를 제공합니다. 
- 적응력과 오픈 소스 특성으로 인해 안드로이드는 다양한 시장에서 번창할 수 있었고 스마트폰을 넘어 수많은 기기의 기반을 형성했습니다.


### Q. 안드로이드 플랫폼 아키텍처는 리눅스 커널, 안드로이드 런타임 (ART), 하드웨어 추상화 계층 (HAL)을 포함한 여러 계층으로 구성됩니다. 이 구성 요소들이 애플리케이션 실행과 하드웨어 상호작용을 보장하기 위해 어떻게 함께 작동하는지 설명해주세요.

안드로이드 플랫폼 아키텍처의 주요 구성 요소인 리눅스 커널, 하드웨어 추상화 계층(HAL), 안드로이드 런타임(ART)이 어떻게 상호작용하여 애플리케이션 실행과 하드웨어 제어를 가능하게 하는지 설명드리겠습니다. 이들은 각기 다른 역할을 수행하며 유기적으로 연결되어 안드로이드 시스템 전체를 구동합니다.

1.  **리눅스 커널 (Linux Kernel):**
    * **역할:** 안드로이드 아키텍처의 가장 기반이 되는 계층입니다. 하드웨어와 나머지 소프트웨어 스택 사이의 핵심적인 다리 역할을 합니다.
    * **주요 기능:**
        * **프로세스 관리:** 앱 및 시스템 프로세스의 생성, 스케줄링, 종료를 관리합니다.
        * **메모리 관리:** 앱과 시스템이 사용할 RAM을 할당하고 관리합니다.
        * **기본 디바이스 드라이버:** 디스플레이, 키보드, 와이파이, 오디오, 카메라 등 기본적인 하드웨어 장치를 제어하는 드라이버를 포함합니다. (단, 모든 하드웨어 제어를 커널 드라이버만으로 하지는 않습니다.)
        * **보안:** 파일 시스템 권한, 프로세스 격리 등 시스템 보안의 기초를 제공합니다.
        * **네트워킹:** TCP/IP 스택 등을 통해 네트워크 통신을 관리합니다.
    * **상호작용:** HAL과 ART(및 상위 프레임워크)는 직접 또는 간접적으로 커널이 제공하는 시스템 콜(System Call)을 통해 하드웨어 접근, 프로세스/메모리 관리 등의 서비스를 요청합니다.

2.  **하드웨어 추상화 계층 (Hardware Abstraction Layer - HAL):**
    * **역할:** 리눅스 커널의 디바이스 드라이버와 상위 레벨의 안드로이드 프레임워크/런타임 사이의 중요한 '번역가' 또는 '인터페이스' 역할을 합니다. 하드웨어 제조사마다 다른 하드웨어 구현 방식을 '표준화된 인터페이스' 뒤에 숨겨줍니다.
    * **주요 기능:**
        * **표준 인터페이스 제공:** 카메라, 블루투스, 센서, 오디오 등 다양한 하드웨어 기능에 대해 안드로이드 프레임워크가 호출할 수 있는 표준화된 API(인터페이스)를 정의합니다. 예를 들어, 모든 카메라 앱은 안드로이드 프레임워크의 카메라 API를 호출하고, 이 API는 표준 Camera HAL 인터페이스를 호출합니다.
        * **하드웨어 종속성 분리:** 각 하드웨어 제조사(예: 삼성, LG, 퀄컴)는 자신들의 하드웨어에 맞게 이 표준 HAL 인터페이스를 구현합니다. 이 구현체는 내부적으로 해당 하드웨어를 제어하는 리눅스 커널 드라이버와 통신합니다. 덕분에 안드로이드 OS 자체나 앱 개발자들은 특정 하드웨어의 상세 구현을 몰라도 됩니다.
    * **상호작용:** 안드로이드 프레임워크의 시스템 서비스(예: CameraService, AudioFlinger)는 하드웨어 기능을 사용해야 할 때 해당 HAL 인터페이스를 호출합니다. HAL 구현체는 이 호출을 받아 커널 드라이버와 통신하여 실제 하드웨어를 제어하고 결과를 다시 프레임워크로 반환합니다.

3.  **안드로이드 런타임 (Android Runtime - ART):**
    * **역할:** 안드로이드 애플리케이션(.apk 파일 내의 .dex 코드)이 실행되는 환경입니다. 이전 버전의 Dalvik 가상 머신을 대체했습니다.
    * **주요 기능:**
        * **앱 코드 실행:** 앱 개발자가 Java 또는 Kotlin으로 작성한 코드를 컴파일한 Dalvik 바이트코드(.dex)를 기기의 네이티브 기계어 코드로 변환하여 실행합니다. ART는 주로 AOT(Ahead-Of-Time) 컴파일을 사용하여 앱 설치 시 또는 기기 유휴 상태일 때 코드를 미리 컴파일하여 실행 성능을 향상시킵니다. (프로파일 기반 JIT 컴파일도 병행)
        * **핵심 라이브러리:** 앱 개발에 사용되는 표준 Java API 및 안드로이드 고유 API를 제공하는 핵심 라이브러리 세트를 포함합니다.
        * **메모리 관리 (GC):** 가비지 컬렉션(Garbage Collection)을 통해 앱이 사용한 메모리 중 더 이상 필요 없는 부분을 자동으로 회수하여 관리합니다.
    * **상호작용:**
        * **애플리케이션 실행:** 앱 코드를 직접 실행하고 관리합니다.
        * **프레임워크 API 호출:** 앱 코드가 카메라, 센서, 네트워크 등 하드웨어 기능이나 시스템 서비스가 필요한 API를 호출하면, ART는 이 호출을 안드로이드 프레임워크의 해당 API로 전달합니다.
        * **하드웨어 접근 (간접적):** ART 자체는 하드웨어나 HAL과 직접 통신하지 않습니다. 앱이 하드웨어 관련 API를 호출하면, 그 요청은 안드로이드 프레임워크 -> 시스템 서비스 -> HAL -> 커널 드라이버 순서로 전달되어 처리됩니다. ART는 이 과정에서 앱 코드의 실행 흐름을 관리합니다.

**종합적인 작동 방식 (예시: 카메라 앱 실행):**

1.  사용자가 카메라 앱을 실행하면, **ART**가 앱의 코드를 로드하고 실행합니다.
2.  사용자가 사진 촬영 버튼을 누르면, 앱 코드는 안드로이드 프레임워크의 Camera API를 호출합니다.
3.  **ART**는 이 API 호출을 안드로이드 프레임워크로 전달합니다.
4.  안드로이드 프레임워크 내의 Camera 관련 코드는 CameraService와 같은 시스템 서비스를 통해 **Camera HAL**의 표준 인터페이스 (예: `takePicture()`)를 호출합니다.
5.  해당 기기 제조사가 구현한 **Camera HAL** 구현체는 이 호출을 받아, **리눅스 커널**의 실제 카메라 드라이버와 통신하여 카메라 하드웨어를 제어하고 사진을 찍습니다.
6.  결과(사진 데이터)는 다시 커널 드라이버 -> HAL -> 프레임워크 -> ART를 거쳐 앱으로 전달됩니다.
7.  이 모든 과정 동안 **리눅스 커널**은 프로세스 스케줄링, 메모리 할당 등을 지속적으로 관리합니다.

이처럼 리눅스 커널은 저수준 하드웨어 제어와 핵심 시스템 서비스를, HAL은 하드웨어 구현의 다양성을 표준 인터페이스 뒤로 추상화하여 호환성을 보장하고, ART는 애플리케이션 코드를 효율적으로 실행하는 역할을 나누어 맡음으로써 안드로이드 시스템이 다양한 하드웨어에서 안정적으로 작동하고 앱을 실행할 수 있도록 보장합니다.

---

## 인텐트란?
Intent는 수행될 작업에 대한 추상적인 설명이다. **Activity, Service, Brodcast Receiver** 가 통신할 수 있도록 하는 메시징 객체 역할을 합니다. 인텐트는 일반적으로 Activity 를 시작하거나, 브로드캐스트를 보내거나, 서비스를 시작하는 데 사용됩니다. 또한 구성 요소 간에 데이터를 전달할 수 있어 Android의 구성 요소 기반 아키텍처의 기본 부분이 됩니다.

안드로이드에는 명시적 인텐트와 암시적 인텐트 두 가지 주요 유형이 있습니다.

### 명시적 인텐트

- 정의: 명시적 인텐트는 직접 이름을 지정하여 호출할 정확한 구성 요소(액티비티 또는 서비스)를 지정합니다.
- 사용 사례: 명시적 인텐트는 대상 구성 요소를 알고 있을 때 사용됩니다(예: 앱 내에서 특정 액티비티을 시작하는 경우).
- 시나리오: 동일한 앱 내에서 한 액티비티에서 다른 액티비티으로 전환하는 경우 명시적 인텐트를 사용합니다.'

### 암시적 인텐트

- 정의: 암시적 인텐트는 특정 구성 요소를 지정하지 않지만 수행할 일반적인 작업을 선언합니다. 시스템은 작업, 카테고리 및 데이터를 기반으로 인텐트를 처리할 수 있는 구성 요소를 해결합니다.
- 사용 사례: 암시적 인텐트는 다른 앱이나 시스템 구성 요소가 처리할 수 있는 작업(예: URL 열기 또는 콘텐츠 공유)을 수행하려는 경우에 유용합니다.
- 시나리오: 브라우저에서 웹 페이지를 열거나 다른 앱과 콘텐츠를 공유하는 경우 암시적 인텐트를 사용합니다. 시스템이 인텐트를 처리할 앱을 결정할 것입니다.

### 요약

- 명시적 인텐트는 대상 구성 요소를 알고 있는 내부 앱 탐색에 사용됩니다. 
- 반면에 암시적 인텐트는 대상을 직접 지정하지 않고 외부 앱이나 다른 구성 요소에 의해 처리될 수 있는 작업에 사용됩니다.
- 안드로이드 생태계를 더 유연하게 만들고 앱이 원활하게 상호 작용할 수 있게 해줍니다.

### Q. 명시적 인텐트와 암시적 인텐트의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 사용하시겠습니까?

**1. 명시적 인텐트 (Explicit Intent)**

* **정의:** 시작할 대상 컴포넌트(Activity, Service 등)의 정확한 클래스 이름을 지정합니다.
* **주요 특징:** 어떤 애플리케이션의 어떤 컴포넌트를 실행할지 명확하게 알고 있을 때 사용합니다. 주로 앱 내부의 컴포넌트를 호출할 때 사용됩니다.
* **사용 시나리오:**
    * 같은 앱 내에서 특정 액티비티(예: 설정 화면, 상세 정보 화면)를 시작할 때.
    * 같은 앱 내에서 특정 서비스(예: 백그라운드 음악 재생 서비스)를 시작할 때.

**2. 암시적 인텐트 (Implicit Intent)**

* **정의:** 수행할 구체적인 액션(예: 웹페이지 보기, 전화 걸기, 지도 보기)을 지정하지만, 특정 컴포넌트의 이름은 지정하지 않습니다.
* **주요 특징:** 해당 액션을 처리할 수 있는 컴포넌트가 설치된 앱 중에서 안드로이드 시스템이 적절한 것을 찾아 실행하거나 사용자에게 선택권을 줍니다. 다른 앱의 기능을 사용하거나 연동할 때 유용합니다.
* **사용 시나리오:**
    * 웹 브라우저를 열어 특정 URL을 보여줄 때 (`ACTION_VIEW`).
    * 지도 앱을 열어 특정 위치를 보여줄 때 (`ACTION_VIEW`).
    * 전화 앱을 열어 전화번호를 다이얼하도록 할 때 (`ACTION_DIAL`).
    * 다른 앱으로 콘텐츠를 공유할 때 (`ACTION_SEND`).
    * 카메라 앱을 열어 사진을 찍도록 요청할 때 (`ACTION_IMAGE_CAPTURE`).

**핵심 차이 요약:**

* **명시적 인텐트:** "앱 A의 B 액티비티를 실행해줘" 와 같이 **대상을 직접 지정**합니다.
* **암시적 인텐트:** "이 웹 주소를 보여줄 수 있는 앱을 실행해줘" 와 같이 **수행할 액션만 지정**하고, 시스템이 처리할 앱을 결정합니다.


### Q. 안드로이드 시스템은 어떤 앱이 암시적 인텐트를 처리해야 하는지 어떻게 결정하며, 적합한 애플리케이션이 발견되지 않으면 어떻게 됩니까?

**1. 앱 결정 과정 (인텐트 확인 - Intent Resolution)**

안드로이드 시스템은 다음 단계를 통해 암시적 인텐트를 처리할 앱을 찾습니다.

* **인텐트 필터(Intent Filter) 검색:** 시스템은 설치된 모든 앱의 `AndroidManifest.xml` 파일에 선언된 인텐트 필터들을 검색합니다. 인텐트 필터는 해당 앱 컴포넌트(주로 액티비티)가 어떤 종류의 인텐트를 처리할 수 있는지 명시합니다.
* **인텐트 정보 비교:** 시스템은 수신한 암시적 인텐트의 다음 세 가지 정보를 각 앱의 인텐트 필터와 비교합니다.
    * **액션(Action):** 인텐트에 지정된 액션(예: `ACTION_VIEW`)이 인텐트 필터의 `<action>` 태그 중 하나와 일치해야 합니다.
    * **데이터(Data):** 인텐트에 포함된 데이터(URI 및/또는 MIME 타입)가 인텐트 필터의 `<data>` 태그 명세(스키마, 호스트, 경로, MIME 타입 등)와 일치해야 합니다.
    * **카테고리(Category):** 인텐트에 포함된 모든 카테고리(예: `CATEGORY_DEFAULT`, `CATEGORY_BROWSABLE`)가 인텐트 필터의 `<category>` 태그에 포함되어 있어야 합니다. (`startActivity()`로 액티비티를 시작하려면 `CATEGORY_DEFAULT`가 필요합니다.)
* **앱 선택:**
    * **일치하는 앱이 하나일 경우:** 시스템은 즉시 해당 앱의 컴포넌트를 시작합니다.
    * **일치하는 앱이 여러 개일 경우:** 시스템은 사용자에게 앱 선택 대화상자(Chooser)를 표시하여 어떤 앱을 사용할지 선택하도록 합니다.
    * **일치하는 앱이 없을 경우:** 아래 2번 항목을 참조하십시오.

**2. 적합한 애플리케이션이 발견되지 않으면 어떻게 되는가?**

* 시스템이 암시적 인텐트와 일치하는 인텐트 필터를 가진 앱 컴포넌트를 찾지 못하면, 해당 인텐트를 시작하려는 호출(예: `startActivity()`)이 실패합니다.
* 이 경우, 시스템은 일반적으로 `ActivityNotFoundException` 예외를 발생시킵니다.
* **개발자의 대응:** 앱이 비정상 종료되는 것을 막으려면, `startActivity()` 호출을 `try-catch` 블록으로 감싸서 `ActivityNotFoundException`을 처리해야 합니다. 또는, `startActivity()`를 호출하기 전에 `Intent` 객체의 `resolveActivity()` 메서드를 호출하여 처리할 수 있는 앱이 있는지 미리 확인할 수 있습니다. `resolveActivity()`는 적합한 앱이 없으면 `null`을 반환하므로, 이를 통해 예외 발생 없이 안전하게 인텐트 호출 여부를 결정할 수 있습니다. (예: 처리할 앱이 없으면 해당 기능을 비활성화하거나 사용자에게 알림).

### 💡 **프로 팁: 인텐트 필터란 무엇인가?**

- 안드로이드의 인텐트 필터는 앱 구성 요소가 링크 열기 또는 브로드캐스트 처리와 같은 특정 인텐트에 응답할 수 있는 방법을 정의합니다. 
- AndroidManifest.xml 파일에 지정된 액티비티, 서비스 또는 브로드캐스트 수신자가 처리할 수 있는 인텐트 유형을 선언하는 필터 역할을 합니다. 
- 각 인텐트 필터는 들어오는 인텐트와 정확하게 일치하도록 동작, 카테고리 및 데이터 유형을 포함할 수 있습니다. 
- 인텐트 필터를 적절하게 정의하면 앱이 다른 앱 및 시스템 구성 요소와 원활하게 상호 작용하여 기능이 향상됩니다.

```
암시적 인텐트가 전송되면 Android 시스템은 설치된 앱의 매니페스트 파일에 정의된 인텐트 필터에 대한 인텐트의 속성을 일치시켜 실행할 적절한 구성 요소를 결정합니다. 
일치하는 항목이 발견되면 시스템은 해당 구성 요소를 시작하고 Intent 객체를 전달합니다. 
여러 구성 요소가 인텐트와 일치하는 경우 시스템은 사용자에게 선택 대화 상자를 제공하여 작업을 처리하기 위해 선호하는 앱을 선택할 수 있습니다.
```

---

## Pending Intent 의 목적은 무엇인가요?

Pending Intent는 다른 애플리케이션 또는 시스템 구성 요소에 애플리케이션을 대신하여 나중에 미리 정의된 인텐트를 실행할 수 있는 기능을 부여하는 특별한 종류의 인텐트입니다. 이는 알림이나 서비스와의 상호 작용과 같이 앱의 수명 외에 트리거되어야 하는 작업에 특히 유용합니다.

### PendingIntent의 주요 특징

- PendingIntent는 일반 Intent의 래퍼 역할을 하여 앱의 수명 주기 이후에도 지속되도록 합니다. 
- Intent의 실행을 앱과 동일한 권한을 가진 다른 앱 또는 시스템 서비스에 위임합니다. 
- PendingIntent는 액티비티, 서비스 또는 브로드캐스트 수신기에 대해 생성될 수 있습니다.

**사용 사례**

- 알림: 사용자가 알림을 탭할 때 액티비티를 여는 것과 같은 작업을 허용합니다.
- 알람: AlarmManager를 사용하여 작업을 예약합니다.
- 서비스: 백그라운드 작업을 위해 ForegroundService 또는 BroadcastReceiver에 작업을 위임합니다.

### **보안 고려 사항**

항상 PendingIntents에 대해 FLAG_IMMUTABLE을 설정하여 악성 앱이 기본 Intent를 수정하는 것을 방지하십시오. 이는 특정 시나리오에서 FLAG_IMMUTABLE이 필수인 Android 12(API 레벨 31) 이후부터 특히 중요합니다.

### **요약**

- PendingIntent는 앱이 활발하게 실행되지 않을 때에도 앱과 시스템 구성 요소 또는 다른 앱 간의 원활한 통신을 가능하게 하는 Android의 핵심 메커니즘입니다. 
- 플래그와 권한을 신중하게 관리함으로써 지연된 작업의 안전하고 효율적인 실행을 보장할 수 있습니다.

### Q. PendingIntent란 무엇이며 일반 Intent와 어떻게 다릅니까? PendingIntent를 사용해야 하는 시나리오를 제시해 주시겠습니까?
`PendingIntent` (펜딩인텐트)는 일반 `Intent` (인텐트)와 다른 특별한 목적을 가진 인텐트입니다.

**1. PendingIntent란 무엇인가?**

`PendingIntent`는 `Intent` 객체를 감싸는(wrapping) 토큰 또는 참조입니다. 핵심 기능은 **미래의 특정 시점**에 **다른 애플리케이션**이 마치 **원래 앱의 권한**으로 감싸진 `Intent`를 실행할 수 있도록 허가하는 것입니다. 즉, `Intent` 실행을 즉시 하지 않고 '보류(pending)' 시켰다가 나중에 다른 주체(예: 시스템 서비스)에 의해 실행되도록 위임하는 객체입니다.

**2. 일반 Intent와의 차이점**

| 특징          | 일반 Intent (인텐트)                                 | PendingIntent (펜딩인텐트)                                                                 |
|---------------|---------------------------------------------------|--------------------------------------------------------------------------------------------|
| **실행 주체** | `Intent`를 생성한 앱 (자기 자신)                     | `PendingIntent`를 전달받은 다른 앱 또는 시스템 서비스 (예: NotificationManager, AlarmManager) |
| **실행 시점** | 생성 직후 즉시 실행 (`startActivity` 등 호출 시)   | 미래의 특정 시점 (예: 알람 시간 도달, 알림 클릭 시)                                          |
| **권한** | 실행하는 앱 자체의 권한으로 실행                      | **`PendingIntent`를 생성한 앱의 권한**으로 실행 (중요!)                                  |
| **목적** | 앱 내부 컴포넌트 호출, 다른 앱 기능 즉시 사용 등        | 다른 앱/서비스에게 미래의 `Intent` 실행 권한 위임                                               |
| **생존** | `Intent`를 보낸 앱 프로세스가 종료되면 의미 없음       | `PendingIntent`를 생성한 앱 프로세스가 종료되어도 시스템에 의해 유지되고 실행될 수 있음            |

**3. PendingIntent 사용 시나리오**

`PendingIntent`는 주로 내 앱이 아닌 다른 앱이나 시스템 서비스가 내 앱의 컴포넌트를 안전하게 실행해야 할 때 사용됩니다.

* **알림 (Notifications):** 사용자가 알림을 탭했을 때, NotificationManager 서비스가 `PendingIntent`를 사용하여 내 앱의 특정 액티비티(Activity)를 시작하거나 브로드캐스트를 보냅니다. 알림을 생성하는 시점에는 어떤 액티비티를 실행할지만 정의해두고, 실제 실행은 사용자가 탭하는 미래 시점에 NotificationManager가 대신 수행합니다.
* **알람 (AlarmManager):** 특정 시간에 또는 주기적으로 작업을 수행하도록 예약할 때 사용됩니다. AlarmManager 서비스는 예약된 시간이 되면 `PendingIntent`를 사용하여 내 앱의 서비스(Service)를 시작하거나 브로드캐스트를 보냅니다. 앱이 꺼져 있어도 알람 시간에 맞춰 동작을 실행할 수 있습니다.
* **앱 위젯 (App Widgets):** 홈 화면 위젯의 버튼 등을 클릭했을 때, 홈 화면 앱(런처)이 위젯을 제공한 앱이 미리 설정해 둔 `PendingIntent`를 실행하여 특정 액티비티를 시작하거나 서비스를 실행합니다.
* **지오펜싱 (Geofencing) / 액티비티 감지 (Activity Recognition):** 사용자의 위치 변경이나 액티비티 상태 변경(걷기, 운전 등)을 감지했을 때, 시스템의 위치 또는 액티비티 감지 서비스가 `PendingIntent`를 실행하여 앱에 해당 이벤트를 알립니다.

요약하자면, `PendingIntent`는 **미래 시점**에 **다른 애플리케이션**이 **내 애플리케이션의 권한**으로 특정 `Intent`를 실행하도록 위임해야 할 때 필수적으로 사용됩니다.

---

## Serializable 과 Parcelable 의 차이점은 무엇인가요?
Android에서 Serializable과 Parcelable은 모두 서로 다른 구성 요소(예: Activity 또는 Fragment) 간에 데이터를 전달하는 데 사용되는 메커니즘이지만 성능과 구현 측면에서 다르게 작동합니다.

### Serializable

- **Java Standard Interface**: Serializable은 객체를 바이트 스트림으로 변환하는 데 사용되는 표준 Java 인터페이스이므로 액티비티 간에 전달되거나 디스크에 쓸 수 있습니다.
- **리플렉션 기반**: 자바 리플렉션을 통해 작동합니다. 즉, 시스템이 런타임에 클래스와 필드를 동적으로 검사하여 객체를 직렬화합니다.
- **성능**: Serializable은 리플렉션 프로세스가 느리기 때문에 Parcelable에 비해 느립니다. 또한 직렬화 중에 많은 임시 개체를 생성하여 메모리 오버헤드를 증가시킵니다.
- **사용 사례**: Serializable은 성능이 중요하지 않은 시나리오나 Android와 관련되지 않은 코드베이스를 다룰 때 유용합니다.

### Parcelable

- **안드로이드 전용 인터페이스**: Parcelable은 안드로이드 구성 요소 내에서 고성능 프로세스 간 통신(IPC)을 위해 특별히 설계된 안드로이드 전용 인터페이스입니다.
- **성능**: Parcelable은 Android에 최적화되어 있고 리플렉션에 의존하지 않기 때문에 Serializable보다 빠릅니다. 많은 임시 개체를 생성하지 않음으로써 가비지 수집을 최소화합니다.
- **사용 사례**: Parcelable은 성능이 중요할 때, 특히 IPC 또는 액티비티 또는 서비스 간에 데이터를 전달할 때 Android에서 데이터를 전달하는 데 선호됩니다.

현대 안드로이드 개발에서 kotlin-parcelize 플러그인은 구현을 자동으로 생성하여 Parcelable 객체를 생성하는 과정을 단순화합니다. 이 접근법은 이전의 수동 메커니즘에 비해 더 효율적이다. 단순히 @Parcelize로 클래스에 주석을 달면 플러그인은 필요한 Parcelable 구현을 생성합니다. 작동 방식을 보여주는 예는 다음과 같습니다.

```kotlin
import kotlinx.parcelize.Parcelize
import android.os.Parcelable
 
@Parcelize
class User(val firstName: String, val lastName: String, val age: Int) : Parcelable
```

### 요약

- 일반적으로 안드로이드 애플리케이션의 경우, Parcelable은 대부분의 사용 사례에서 더 나은 성능으로 인해 권장되는 접근 방식입니다.
- 더 간단한 경우나 성능에 중요하지 않은 작업을 처리하거나 안드로이드와 관련되지 않은 코드로 작업할 때 Serializable을 사용하십시오.
- Android의 IPC 메커니즘에 대해 훨씬 더 효율적이기 때문에 성능이 중요한 Android 전용 구성 요소로 작업할 때 Parcelable을 사용하십시오.


### Q. Android에서 Serializable과 Parcelable의 주요 차이점은 무엇이며, Parcelable이 일반적으로 구성 요소 간에 데이터를 전달하는 데 선호되는 이유는 무엇입니까?

Android에서 `Serializable`과 `Parcelable`은 객체를 다른 컴포넌트나 프로세스로 전달하기 위해 직렬화(Serialization)하는 두 가지 주요 메커니즘입니다. 둘 사이의 주요 차이점과 `Parcelable`이 선호되는 이유는 다음과 같습니다.

**1. Serializable과 Parcelable의 주요 차이점**

| 특징             | Serializable (`java.io.Serializable`)                     | Parcelable (`android.os.Parcelable`)                         |
|------------------|-----------------------------------------------------------|--------------------------------------------------------------|
| **기원** | 표준 자바(Java) 인터페이스                                 | 안드로이드(Android) SDK 인터페이스                           |
| **구현 방식** | 인터페이스 구현만 하면 자바 리플렉션(Reflection)을 통해 자동 처리 | `writeToParcel()`, `describeContents()`, `CREATOR` 객체 등 직접 구현 필요 |
| **처리 메커니즘** | 리플렉션을 사용 (느리고, 임시 객체 생성 많음)                | 직접 데이터를 Parcel 객체에 쓰고 읽음 (빠르고, 효율적)             |
| **성능** | 상대적으로 느리고 메모리 사용량 많음                        | **훨씬 빠르고 메모리 효율적** |
| **구현 복잡도** | 간단 (주로 인터페이스 선언만 필요)                           | 상대적으로 복잡 (보일러플레이트 코드 필요)                      |
| **용도** | 일반적인 자바 객체 직렬화 (파일 저장, 네트워크 전송 등)        | **안드로이드의 IPC(프로세스 간 통신)** 및 컴포넌트 간 데이터 전달에 최적화 |

**2. Parcelable이 선호되는 이유**

안드로이드에서 액티비티(Activity), 프래그먼트(Fragment), 서비스(Service) 등 컴포넌트 간에 데이터를 인텐트(Intent)나 번들(Bundle)을 통해 전달할 때 `Parcelable`이 일반적으로 선호되는 주된 이유는 **성능** 때문입니다.

* **속도와 효율성:** `Parcelable`은 안드로이드의 프로세스 간 통신(IPC) 메커니즘인 Binder 통신에 맞게 특별히 설계되었습니다. 리플렉션을 사용하는 `Serializable`과 달리, `Parcelable`은 개발자가 명시적으로 데이터를 `Parcel` 객체에 쓰고 읽는 코드를 작성하므로 훨씬 빠릅니다. 리플렉션은 실행 시간에 객체의 구조를 분석해야 하므로 오버헤드가 크고, 이로 인해 UI 끊김(Jank)이나 성능 저하를 유발할 수 있습니다.
* **메모리 사용:** `Serializable`은 직렬화 과정에서 많은 임시 객체를 생성하여 가비지 컬렉션(GC) 부담을 증가시킬 수 있습니다. 반면, `Parcelable`은 이러한 오버헤드가 훨씬 적어 메모리 사용에 더 효율적입니다. 이는 메모리가 제한적인 모바일 환경에서 중요한 장점입니다.
* **안드로이드 플랫폼 표준:** 안드로이드 프레임워크 자체의 많은 객체들이 컴포넌트 간 데이터 전달을 위해 `Parcelable`을 사용합니다. 따라서 안드로이드 개발 시 `Parcelable`을 사용하는 것이 플랫폼의 설계 철학과 더 잘 부합합니다.

**결론:**

`Serializable`은 구현이 매우 간편하다는 장점이 있지만, 성능 오버헤드가 커서 안드로이드 앱의 성능에 부정적인 영향을 줄 수 있습니다. 반면, `Parcelable`은 구현에 더 많은 노력이 필요하지만, 월등한 성능과 효율성 덕분에 안드로이드 컴포넌트 간 데이터 전달(특히 IPC가 포함될 수 있는 경우)에 강력히 권장되는 방식입니다.


### 💡 프로 팁: Parcel and Parcelable

- Parcel은 애플리케이션의 서로 다른 구성 요소(예: ,액티비티 서비스 또는 브로드캐스트 수신기) 간에 고성능 프로세스 간 통신(IPC)을 가능하게 하는 Android의 컨테이너 클래스입니다. 그것은 주로 마샬링(평탄화) 및 언마샬링(객체화) 데이터에 사용되어 안드로이드의 IPC 경계를 넘어 전달될 수 있습니다.
- Parcel은 프로세스 간 통신(IPC) 메커니즘을 통해 플랫화된 데이터와 참조를 라이브 IBinder 객체로 보내는 데 사용되는 컨테이너입니다. 고성능 IPC 전송을 위해 설계되어 개체(Parcelable 인터페이스 사용)를 직렬화하고 구성 요소 간에 효율적으로 전달할 수 있습니다. Parcel은 범용 직렬화 도구가 아니며 기본 구현이 변경되어 이전 데이터를 읽을 수 없게 만들 수 있으므로 영구 저장에 사용해서는 안 됩니다.
- API에는 원시 데이터 유형, 배열 및 Parcelable 객체를 읽고 쓰기 위한 다양한 방법이 포함되어 있어 객체가 필요할 때 직렬화하고 재구성할 수 있습니다. 또한, 쓰기 클래스 정보를 생략하는 Parcelables로 작업하기 위한 최적화된 방법이 있으며, 독자가 유형을 알아야 합니다.
- Parcelable은 Parcel을 통해 전달할 수 있도록 개체를 직렬화하는 데 사용되는 Android 전용 인터페이스입니다. Parcelable을 구현하는 개체는 Parcel에 기록되고 Parcel에서 복원될 수 있어 Android 구성 요소 간에 복잡한 데이터를 전달하는 데 적합합니다.

### 요약

Parcel은 다양한 데이터 유형을 지원하는 IPC를 사용하여 구성 요소 간에 데이터를 전송하는 컨테이너입니다. Parcelable은 효율적인 전송을 위해 개체를 Parcel으로 평평하게 할 수 있는 인터페이스입니다. Parcel의 실제 구현과 작동 메커니즘에 대해 자세히 알아보기 위해 [AOSP - Parcel.java](https://android.googlesource.com/platform/frameworks/base/+/27f592d/core/java/android/os/Parcel.java)에서 소스 코드를 탐색할 수 있습니다.

---

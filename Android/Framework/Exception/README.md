# 예외(Exception)는 어떻게 추적하나요?

안드로이드에서 예외를 추적하는 것은 문제를 효과적으로 진단하고 해결하는 데 매우 중요합니다. 안드로이드는 문제를 식별하고 디버깅하는 데 도움이 되는 여러 도구와 기법을 제공합니다.

### Logcat을 이용한 예외 로깅

Android Studio에서 사용할 수 있는 **Logcat(로그캣)** 은 로그를 보고 예외를 추적하는 기본적인 도구입니다. 예외가 발생하면 시스템은 예외 유형, 메시지, 그리고 예외가 발생한 코드 줄을 포함한 상세한 **스택 트레이스(stack trace)** 를 Logcat에 기록합니다. `E/AndroidRuntime`과 같은 키워드를 사용하여 Logcat 로그를 필터링하면 예외에 집중할 수 있습니다.

### try-catch를 이용한 예외 처리

`try-catch` 블록을 사용하면 코드의 중요한 부분에서 예외를 제어된 방식으로 처리하고 앱의 비정상 종료를 방지할 수 있습니다. 예를 들어:

```kotlin
try {
    // 예외가 발생할 수 있는 코드
    val result = 10 / 0
} catch (e: ArithmeticException) {
    // 예외 로깅 또는 처리
    Log.e("MyApp", "산술 연산 오류 발생", e)
    // 사용자에게 오류 메시지 표시 또는 복구 로직 실행
}
```

이는 예외가 기록되도록 보장하여 추적 및 해결을 더 쉽게 만듭니다.

### 전역 예외 처리기(Global Exception Handler) 사용

`Thread.setDefaultUncaughtExceptionHandler`를 사용하여 전역 예외 처리기를 설정하면 앱 전체에서 **처리되지 않은(uncaught) 예외**를 포착하는 데 도움이 됩니다. 이는 중앙 집중식 오류 보고나 로깅에 특히 유용합니다.

```kotlin
// Application 클래스나 초기화 시점에 설정
Thread.setDefaultUncaughtExceptionHandler { thread, throwable ->
    // 처리되지 않은 예외 로깅 또는 원격 서버로 보고
    Log.e("GlobalExceptionHandler", "처리되지 않은 예외 발생", throwable)
    // 필요한 경우, 사용자에게 알림 후 앱 종료 등의 추가 작업 수행 가능
}
```

이 접근 방식은 애플리케이션 전반의 런타임 문제를 디버깅하고 모니터링하는 데 매우 효과적입니다. 또한, 전역 예외 처리기를 디버그 또는 QA 빌드에만 구현할 수도 있습니다. 이를 통해 QA 전문가가 예외를 효율적으로 추적하고 상세 보고서를 개발팀에 전달하여 디버깅 및 문제 해결 프로세스를 간소화할 수 있습니다. 고급 구현을 살펴보고 싶다면, GitHub의 오픈소스 프로젝트인 [snitcher](https://www.google.com/search?q=https://github.com/Omarelabdelhadi/snitcher)를 확인할 수 있습니다.

### Firebase Crashlytics 사용

[**Firebase Crashlytics**](https://firebase.google.com/docs/crashlytics)는 운영 환경(production environments)에서 예외를 추적하는 훌륭한 도구입니다. 처리되지 않은 예외를 자동으로 기록하고 스택 트레이스, 기기 상태, 사용자 정보가 포함된 상세한 충돌 보고서를 제공합니다. 중요하지 않은 문제에 대해서는 사용자 정의 예외를 기록할 수도 있습니다.

```kotlin
try {
    val data = fetchData()
} catch (e: IOException) {
    Crashlytics.logException(e)
}
```

Crashlytics는 Firebase와 통합되어 있어 충돌을 분석하고 해결 과정을 추적하기 쉽습니다.

### 중단점(Breakpoints)을 이용한 디버깅

Android Studio에서 중단점(breakpoint)을 설정하면 코드 실행을 일시 중지하고 앱의 상태를 대화형으로 검사할 수 있습니다. 이는 개발 중 예외의 근본 원인을 식별하는 데 특히 유용합니다. 디버그 모드를 활성화하고, 중단점에 도달했을 때 IDE를 사용하여 변수, 메서드 호출 및 예외 스택 트레이스를 탐색합니다.

### 버그 리포트(Bug Report) 캡처

안드로이드에서 버그 리포트를 캡처하면 기기 로그, 스택 트레이스 및 시스템 정보를 수집하여 문제를 진단하고 수정하는 데 도움이 됩니다. ADB는 기본적으로 제3자 솔루션 없이도 버그 리포트를 캡처하고 생성하는 훌륭한 방법을 제공합니다. 세 가지 방법으로 버그 리포트를 생성할 수 있습니다.

1.  **개발자 옵션:** 개발자 옵션을 활성화하고 설정 \> 개발자 옵션 \> 버그 신고 만들기(Take bug report)로 이동하여 생성된 보고서를 공유합니다.
2.  **안드로이드 에뮬레이터:** 확장 제어(Extended Controls)를 열고 버그 리포트(Bug report)를 선택한 다음 관련 세부 정보와 함께 보고서를 저장합니다.
3.  **ADB (Android Debug Bridge):** 터미널에서 `adb bugreport /저장/경로/bugreport`를 실행하거나, `adb -s <기기_시리얼_번호> bugreport`로 특정 기기를 지정합니다.

생성된 ZIP 파일에는 디버깅에 필수적인 `dumpsys`, `dumpstate`, `logcat`과 같은 로그가 포함됩니다. 버그 리포트는 접근할 때까지 저장되며 성능 및 충돌 진단을 위해 분석될 수 있습니다. 자세한 내용은 공식 문서에서 확인할 수 있습니다.

### 요약

예외 추적은 로컬 도구와 운영 환경 모니터링의 조합을 포함합니다. Logcat은 상세한 런타임 로그를 제공하며, `try-catch` 블록과 전역 예외 처리기는 예외가 효과적으로 기록되고 관리되도록 보장합니다. Firebase Crashlytics는 운영 환경에서의 충돌 보고 및 디버깅을 위한 강력한 도구입니다. Android Studio의 중단점은 개발 중 더 대화형적인 디버깅 경험을 제공합니다. 이러한 방법들을 함께 사용하면 포괄적인 예외 관리 및 문제 해결을 보장할 수 있습니다.

-----

## Q. 개발 환경에서 Logcat을 사용하여 예외를 디버깅하는 것과 운영 환경에서 Firebase Crashlytics와 같은 도구를 사용하여 예외를 처리하는 것의 주요 차이점은 무엇인가요? 각 경우에 해당 예외를 어떻게 해결하나요?

개발 환경에서 **Logcat**을 사용하여 예외를 디버깅하는 것과 운영 환경에서 **Firebase Crashlytics**와 같은 도구를 사용하여 예외를 처리하는 것은 환경, 목적, 접근 방식에서 주요 차이점이 있습니다.

### 1. 주요 차이점

| 특징 | Logcat (개발 환경) | Firebase Crashlytics (운영 환경) |
| :--- | :--- | :--- |
| **사용 환경** | 개발 및 테스트 단계 (개발자 PC에 연결된 기기/에뮬레이터) | 실제 사용자가 사용하는 운영(프로덕션) 환경 |
| **데이터 범위** | 연결된 기기의 **모든 시스템/애플리케이션 로그** (상세, 디버그, 정보, 경고, 오류) 실시간 표시. 개발자가 추가한 커스텀 로그 포함. | 주로 **처리되지 않은 예외(비정상 종료)** 및 개발자가 선택적으로 기록한 비 치명적 예외. 일반 로그(`Log.d` 등)는 포함 안 함. |
| **데이터 형태** | **실시간** 스트리밍. 특정 시점의 원시(raw) 데이터 제공. | 다수 사용자로부터 **집계되고 지연되어** 보고됨. 시간 경과에 따른 추세 및 통계 제공. |
| **컨텍스트 정보** | 예외 발생 시점 전후의 다른 로그들을 통해 개발자가 직접 **맥락 파악** 필요. | 기기 모델, OS 버전, 앱 버전, 메모리/디스크 상태, 사용자 정의 로그/키, **사용자 행동 순서(Breadcrumbs)** 등 자동 수집 및 제공. |
| **디버깅 방식** | Android Studio **디버거와 연동**하여 중단점(breakpoint) 설정, 변수 값 확인, 코드 단계별 실행 등 **대화형(interactive) 디버깅** 가능. | **사후 분석(Post-mortem analysis)**. 실제 사용자 기기에서 발생한 문제이므로 직접 디버깅 불가. 수집된 데이터(스택 트레이스, 컨텍스트)에 의존하여 원인 추론. |
| **주요 목적** | 개발 중 발생하는 **버그 즉시 식별 및 수정**. 저수준 시스템 동작 이해. | **운영 환경 앱 상태 모니터링**. 실제 사용자에게 영향 미치는 비정상 종료 식별, 우선순위 지정, 해결 추적. 앱 안정성 추세 파악. |

### 2. 각 경우 예외 해결 방법

**Logcat을 사용하여 개발 환경에서 예외 해결:**

1.  **문제 재현:** Logcat을 모니터링하면서 (보통 Error 레벨 필터링) 예외를 발생시키는 시나리오를 실행합니다.
2.  **스택 트레이스 분석:** Logcat에 출력된 스택 트레이스를 통해 예외가 발생한 정확한 클래스, 메서드, 코드 라인(`NullPointerException`, `ArrayIndexOutOfBoundsException` 등)을 확인하고 호출 흐름을 파악합니다.
3.  **디버거 사용:** 예외 발생 지점 또는 그 이전에 중단점(breakpoint)을 설정하고 앱을 디버그 모드로 실행합니다.
4.  **상태 검사:** 중단점에서 멈췄을 때 관련된 변수의 값, 객체의 상태, 메서드 파라미터 등을 검사하여 왜 상태가 예상과 다른지(예: 왜 변수가 `null`인지, 왜 인덱스가 범위를 벗어났는지) 이해합니다.
5.  **코드 단계별 실행:** 디버거의 스텝 실행 기능을 사용하여 코드를 한 줄씩 따라가며 로직 오류를 정확히 찾아냅니다.
6.  **코드 수정:** 분석 결과를 바탕으로 코드 로직(예: null 체크 추가, 경계 조건 수정, 예외 처리 추가)을 수정합니다.
7.  **수정 확인:** 수정된 코드로 시나리오를 다시 실행하여 예외가 더 이상 발생하지 않고 기능이 의도대로 작동하는지 확인합니다. 필요한 경우 유닛 테스트나 통합 테스트를 추가합니다.

**Firebase Crashlytics를 사용하여 운영 환경에서 예외 해결:**

1.  **대시보드 모니터링 및 우선순위 지정:** Crashlytics 대시보드를 주기적으로 확인하여 새롭거나 자주 발생하는 비정상 종료 보고서를 확인합니다. 발생 빈도, 영향을 받는 사용자 수, 앱 버전 등을 기준으로 해결할 문제의 우선순위를 정합니다.
2.  **충돌 보고서 분석:** 제공된 스택 트레이스를 주의 깊게 분석하여 예외 발생 지점을 파악합니다. 이것이 가장 중요한 정보입니다.
3.  **컨텍스트 데이터 분석:** 함께 제공되는 기기 모델, OS 버전, 앱 버전, 메모리/디스크 상태, 사용자 정의 로그/키, 사용자 행동 순서(Breadcrumbs) 등의 정보를 확인합니다. 특정 조건(예: 특정 기기, 특정 OS 버전)에서만 발생하는지 패턴을 찾습니다.
4.  **재현 시도 (가능하다면):** 스택 트레이스와 컨텍스트 정보를 바탕으로 개발 또는 테스트 환경에서 동일한 비정상 종료를 재현해 봅니다. 특정 기기/OS 환경을 구성하거나 특정 조건(예: 네트워크 불안정)을 시뮬레이션해야 할 수도 있습니다.
5.  **코드 검사 (재현 어려울 시):** 직접 재현이 어렵다면, 스택 트레이스가 가리키는 코드 주변부를 면밀히 검토합니다. Crashlytics에서 얻은 컨텍스트 정보와 코드 로직을 바탕으로 잠재적인 원인을 추론합니다(예: 보고서에서 확인된 특정 조건 하에서 변수가 null이 될 수 있는가? 경쟁 상태(race condition) 가능성은 없는가?).
6.  **추가 로깅/계측 (필요시):** 원인이 여전히 불분명하다면, 의심되는 코드 영역 주변에 더 상세한 로그(`Crashlytics.log()` 사용)나 커스텀 키를 추가하여 업데이트된 버전을 배포하고, 추후 발생하는 충돌 보고서에서 더 많은 정보를 수집합니다.
7.  **코드 수정:** 분석 결과를 바탕으로 문제의 원인을 해결하는 코드를 구현합니다.
8.  **수정 확인 및 모니터링:** 수정 사항을 충분히 테스트한 후 업데이트된 앱을 배포합니다. 이후 Crashlytics 대시보드를 모니터링하여 해당 이슈의 발생률이 현저히 감소하거나 사라졌는지 확인하고, 이슈 상태를 '해결됨'으로 변경합니다.

### 요약
Logcat은 개발 중 즉각적이고 상세한 디버깅에 사용되는 반면, Crashlytics는 운영 환경에서 발생하는 문제의 전반적인 동향 파악, 우선순위 결정, 그리고 제한된 정보 기반의 원인 추론 및 해결에 중점을 둡니다.
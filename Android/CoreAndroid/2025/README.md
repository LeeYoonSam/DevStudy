## 뷰모델 생명 주기
  `ViewModel`은 UI 관련 데이터를 저장하고 관리하기 위해 설계되었으며, 가장 큰 특징은 **액티비티나 프래그먼트와 같은 UI 컨트롤러의 생명주기보다 더 오래 유지**된다는 점입니다. 특히 화면 회전과 같은 **구성 변경(Configuration Change)**에도 데이터가 소실되지 않고 그대로 유지됩니다.
  
  `ViewModel`의 생명 주기는 다음과 같이 요약할 수 있습니다.
  
  1. **스코프(Scope):** `ViewModel`은 특정 스코프(Scope), 즉 특정 액티비티나 프래그먼트에 **연결(scoped)**됩니다.
  2. **생성 시점:** 해당 스코프 내에서 `ViewModel`이 **처음으로 요청될 때 생성**됩니다. 보통 액티비티의 `onCreate()`나 프래그먼트의 `onCreate()` 또는 `onActivityCreated()` 등에서 `ViewModelProvider`를 통해 `ViewModel` 인스턴스를 얻어올 때 생성됩니다.
  3. **유지:** `ViewModel`은 한 번 생성되면, 해당 스코프가 활성 상태인 동안 **메모리에서 계속 유지**됩니다. 예를 들어, 화면 회전으로 인해 액티비티 인스턴스가 파괴되고 새로 생성되더라도, 해당 스코프에 연결된 `ViewModel` 인스턴스는 파괴되지 않고 **기존 인스턴스가 그대로 재사용**됩니다. 데이터가 유지되는 비결이죠.
  4. **소멸 시점 및 `onCleared()`:** `ViewModel`은 연결된 스코프가 완전히 **종료될 때 함께 소멸**됩니다.
      - **액티비티 스코프:** 해당 액티비티가 `finish()` 메소드 호출이나 사용자의 백 버튼 등으로 완전히 **종료(finished)** 될 때 소멸됩니다.
      - **프래그먼트 스코프:** 해당 프래그먼트가 백스택에서 제거되어 완전히 **소멸(destroyed)** 되거나, 프래그먼트를 호스팅하는 액티비티가 종료될 때 함께 소멸됩니다.
      - `ViewModel`이 소멸되기 직전에, **`onCleared()` 메소드가 호출**됩니다. 이 콜백 메소드는 `ViewModel`이 가지고 있던 리소스(예: 데이터베이스 리스너 해제, 네트워크 요청 취소, RxJava 구독 해지 등)를 정리할 수 있는 마지막 기회를 제공합니다.
  
  요약하자면, `ViewModel`은 액티비티나 프래그먼트 인스턴스의 생성/소멸 주기와는 독립적으로, **스코프의 시작부터 완전한 종료 시점까지 생존하며, 구성 변경에도 살아남는 생명 주기**를 가집니다. `onCleared()`는 이 생명 주기가 끝날 때 호출되는 유일한 콜백 메소드입니다.
    
## 액티비티의 데이터를 복구 하는 방법 및 bundle 은 어디에 저장되고 언제까지 유지되는지?
    
  **1. 액티비티 데이터 복구 방법**
  
  액티비티는 사용자의 상호작용, 시스템 이벤트(예: 전화 수신), 또는 구성 변경(예: 화면 회전) 등에 의해 중단되거나 파괴될 수 있습니다. 시스템이 메모리 확보를 위해 백그라운드의 앱 프로세스를 종료시키는 경우도 있습니다. 이러한 상황에서 데이터를 보존하고 사용자가 보던 상태를 복원하는 주요 방법은 다음과 같습니다.
  
  - **`onSaveInstanceState()` 와 `onRestoreInstanceState()` (또는 `onCreate()`):**
      - **목적:** 주로 **구성 변경**이나 시스템에 의한 **임시 프로세스 종료(Process Death)** 시, 사용자가 보고 있던 **일시적인 UI 상태**(예: EditText에 입력한 텍스트, 스크롤 위치, 체크박스 상태 등)를 저장하고 복구하기 위한 메커니즘입니다.
      - **동작:** 액티비티가 예기치 않게 파괴될 가능성이 있을 때 시스템이 `onSaveInstanceState(Bundle outState)`를 호출합니다. 여기에 `Bundle` 객체를 통해 상태 데이터를 저장합니다. 액티비티가 다시 생성될 때, 시스템은 저장했던 `Bundle` 객체를 `onCreate(Bundle savedInstanceState)` 와 `onRestoreInstanceState(Bundle savedInstanceState)`의 파라미터로 전달해줍니다. 개발자는 이 `savedInstanceState`가 `null`이 아닌지 확인하고 데이터를 복원하여 UI 상태를 이전과 같이 설정할 수 있습니다. `onRestoreInstanceState`는 `onStart()` 이후에 호출되므로 뷰가 생성된 후 상태를 복원하기 좋습니다.
  - **Jetpack `ViewModel`:**
      - **목적:** **구성 변경** 시 데이터를 유지하기 위해 특별히 설계되었습니다. UI와 관련된 데이터를 저장하고 관리하는 역할을 합니다.
      - **동작:** `ViewModel`은 액티비티나 프래그먼트의 생명주기보다 더 오래 지속됩니다. 화면 회전 등으로 액티비티 인스턴스가 파괴되고 새로 생성되더라도, 연결된 `ViewModel` 인스턴스는 파괴되지 않고 **기존 인스턴스가 그대로 유지**됩니다. 따라서 구성 변경 시에는 별도의 저장/복구 로직 없이 `ViewModel`에 저장된 데이터를 즉시 사용할 수 있습니다. (단, 기본적인 `ViewModel`은 프로세스 종료 시에는 데이터를 잃습니다.)
  - **영구 저장소 (Persistent Storage):**
      - **목적:** 앱이 완전히 종료되거나 기기가 재부팅되어도 **영구적으로 보존되어야 하는 데이터**(예: 사용자 설정, 로그인 정보, 애플리케이션 데이터베이스 등)를 저장합니다.
      - **종류:** `SharedPreferences`(간단한 Key-Value 데이터), Room 데이터베이스(구조화된 데이터), `DataStore`(개선된 데이터 저장 솔루션), 내부/외부 저장소 파일 등이 있습니다. 액티비티가 시작될 때 이 저장소에서 데이터를 읽어와 상태를 복원하거나 초기화합니다.
  - **`ViewModel`의 Saved State 모듈:**
      - **목적:** `ViewModel`이 **구성 변경뿐만 아니라 프로세스 종료 시에도 상태를 쉽게 저장하고 복구**할 수 있도록 지원하는 Jetpack 라이브러리입니다.
      - **동작:** `SavedStateHandle`이라는 객체를 통해 `ViewModel` 내에서 상태 데이터를 관리합니다. 이 데이터는 `onSaveInstanceState`의 `Bundle`과 유사한 메커니즘으로 시스템에 의해 저장되고 복구되므로, 프로세스 종료 후에도 `ViewModel`이 이전 상태를 가질 수 있게 됩니다.
  
  데이터의 성격(일시적 UI 상태 vs 영구 데이터)과 유지되어야 하는 범위(구성 변경 vs 프로세스 종료 vs 영구 보존)에 따라 적절한 방법을 선택하거나 조합하여 사용합니다.
  
  **2. `onSaveInstanceState`의 `Bundle` 저장 위치 및 유지 기간**
  
  - **저장 내용 및 위치:**
      - `onSaveInstanceState`를 통해 저장되는 `Bundle`에는 일반적으로 **작은 크기의 임시적인 UI 상태 데이터**가 포함됩니다.
      - 이 `Bundle` 데이터는 안드로이드 시스템 내부, 구체적으로는 **ActivityManagerService**가 관리하는 액티비티 상태 정보의 일부로서 **메모리 상에 저장되고 관리**됩니다. 시스템이 이 `Bundle`을 자동으로 파일 같은 영구 저장소에 쓰지는 않습니다.
  - **유지 기간 (Persistence):**
      - **구성 변경(Configuration Change) 시:** 액티비티가 파괴되고 새 인스턴스가 생성되는 동안 **유지**되어 새 인스턴스로 전달됩니다.
      - **임시 프로세스 종료(Temporary Process Death) 시:** 시스템이 메모리 확보 등의 이유로 백그라운드에 있는 앱 프로세스를 강제 종료시킨 경우, 사용자가 나중에 다시 해당 앱(액티비티)으로 돌아오면 시스템이 저장해 둔 `Bundle`을 복원해 줄 수 있도록 **유지**됩니다.
      - **명시적 종료(Explicit Finish) 시:** 사용자가 백(Back) 버튼을 눌러 액티비티를 정상적으로 종료시키거나 코드에서 `finish()`를 호출하여 종료하는 경우에는 **유지되지 않고 폐기**됩니다. (사용자가 의도적으로 떠난 것으로 간주)
      - **작업(Task) 제거 시:** 사용자가 최근 앱 목록(Recents Screen)에서 해당 앱의 작업을 스와이프하여 제거하는 경우에도 **유지되지 않습니다.**
      - **기기 재부팅(Device Reboot) 시:** 기기가 재부팅되면 메모리에 있던 모든 정보가 사라지므로 `Bundle` 데이터는 **유지되지 않습니다.**
  
  따라서 `onSaveInstanceState`의 `Bundle`은 **시스템이 관리하는 단기적인 메모리 기반 저장 메커니즘**으로, 주로 예기치 않은 상황(구성 변경, 임시 프로세스 종료)에서 UI 상태를 잠시 보존하기 위한 용도로 사용됩니다. 영구적인 데이터 저장을 위해서는 별도의 영구 저장소를 사용해야 합니다.
    
## Hilt 를 사용할때 어떻게 간단하게 HiltViweModel 어노테이션만 쓰면 주입이 가능한지 대략적인 힐트 동작 설명
    
  `@HiltViewModel` 어노테이션만으로 `ViewModel`에 필요한 의존성이 주입되는 것은 Hilt가 **컴파일 타임(Compile time)에 코드 생성(Code Generation)** 을 통해 많은 보일러플레이트 코드를 자동으로 만들어주기 때문입니다. Hilt의 대략적인 동작 방식을 설명드리겠습니다.
  
  1. **설정 및 어노테이션:**
      - 먼저 Application 클래스에 `@HiltAndroidApp`을 붙여 Hilt 사용을 설정합니다.
      - 의존성을 주입받을 Activity나 Fragment에는 `@AndroidEntryPoint`를 붙입니다.
      - 의존성을 주입받을 `ViewModel` 클래스에는 `@HiltViewModel`을 붙이고, Hilt가 이 `ViewModel`을 어떻게 생성해야 할지 알 수 있도록 생성자에 `@Inject` 어노테이션을 붙여 필요한 의존성(예: Repository, UseCase 등)을 명시합니다.
  2. **코드 생성 (컴파일 시점):**
      - 앱이 컴파일될 때, Hilt의 어노테이션 프로세서(Dagger 기반)가 프로젝트 내의 Hilt 관련 어노테이션들을 스캔합니다.
      - `@HiltViewModel`과 `@Inject` 생성자를 발견하면, Hilt는 해당 `ViewModel`을 생성하는 방법을 아는 **전용 `ViewModelProvider.Factory` 코드를 자동으로 생성**합니다.
      - 이 자동 생성된 팩토리는 `ViewModel`의 `@Inject` 생성자에 선언된 의존성들(예: `MyRepository`)을 Hilt의 의존성 그래프로부터 가져오는 방법을 알고 있습니다. (Hilt는 `@Module`, `@Provides`, `@Binds` 등으로 정의된 의존성 제공 규칙을 통해 `MyRepository` 인스턴스를 제공하는 방법을 알고 있습니다.)
  3. **런타임 시 의존성 주입:**
      - `@AndroidEntryPoint`가 붙은 Activity나 Fragment에서 `ViewModel`을 요청할 때 (예: 코틀린의 `by viewModels()` 델리게이트나 `ViewModelProvider` 사용), Hilt가 이 과정을 내부적으로 처리합니다.
      - Hilt는 안드로이드 프레임워크의 기본 `ViewModelProvider.Factory` 대신, **컴파일 시점에 자동으로 생성했던 Hilt 전용 팩토리를 사용**하도록 합니다.
      - 이 Hilt 전용 팩토리는 현재 `ViewModel` 스코프에 맞는 Hilt 컴포넌트(`ViewModelComponent`)로부터 `@Inject` 생성자에 필요한 의존성 인스턴스들(예: `MyRepository` 인스턴스)을 **가져옵니다(Provided)**.
      - 가져온 의존성 인스턴스들을 `@Inject` 생성자의 파라미터로 **전달하여 `ViewModel` 인스턴스를 생성**하고 반환합니다.
  
  **요약:**
  
  `@HiltViewModel` 어노테이션은 Hilt의 코드 생성 기능을 활성화하는 스위치와 같습니다. 개발자는 이 어노테이션과 `@Inject` 생성자만 정의하면, 컴파일 시점에 Hilt가 복잡한 `ViewModelProvider.Factory` 구현과 의존성 검색 및 생성자 호출 코드를 모두 자동으로 만들어줍니다. 런타임에는 이렇게 미리 생성된 코드가 동작하여, 개발자가 직접 팩토리를 만들거나 의존성을 전달할 필요 없이 `ViewModel`이 필요한 객체들을 주입받을 수 있게 되는 것입니다. 이것이 `@HiltViewModel` 어노테이션만으로 간편하게 의존성 주입이 가능한 이유입니다.
    
## `by viewModels` 를 했을때와 그냥 `SomeViewModel() 을 인스턴스화` 했을때의 차이점
    
  코틀린의 `by viewModels()` 프로퍼티 델리게이트를 사용하는 것과 생성자 `SomeViewModel()`을 직접 호출하여 인스턴스를 만드는 것은 **ViewModel의 생명주기 관리, 스코프, 그리고 프레임워크 및 의존성 주입과의 통합 측면**에서 매우 큰 차이가 있습니다.
  
  **1. `by viewModels()` 사용 시:**
  
  - **동작 방식:** Jetpack에서 제공하는 KTX(Kotlin 확장 기능)입니다. 내부적으로는 `ViewModelProvider`를 사용하여 `ViewModel` 인스턴스를 가져옵니다.
  - **생명주기 및 스코프:** 이 방식으로 얻어지는 `ViewModel`은 해당 **액티비티나 프래그먼트의 생명주기 스코프(`ViewModelStoreOwner`)에 연결**됩니다. 가장 큰 특징은 화면 회전과 같은 **구성 변경(Configuration Change)이 발생해도 `ViewModel` 인스턴스가 파괴되지 않고 살아남는다**는 점입니다. 액티비티/프래그먼트가 재생성된 후에도 `by viewModels()`는 이전에 사용하던 **동일한 `ViewModel` 인스턴스를 반환**합니다.
  - **`ViewModelStore`:** `by viewModels()`로 얻은 `ViewModel`은 프레임워크의 `ViewModelStore`에 의해 관리됩니다. 이 저장소는 스코프가 유지되는 동안 `ViewModel` 인스턴스를 보관합니다.
  - **의존성 주입 (Hilt 연동):** 만약 해당 액티비티/프래그먼트에 `@AndroidEntryPoint`가 있고 `ViewModel`에 `@HiltViewModel`이 있다면, `by viewModels()`는 **자동으로 Hilt가 생성한 팩토리를 사용하여 의존성이 주입된 `ViewModel` 인스턴스를 제공**합니다.
  - **권장 사항:** **표준적이고 권장되는 방식**입니다. Jetpack ViewModel의 핵심 목적인 생명주기 관리 및 상태 유지를 제대로 활용하고, Hilt와 같은 DI 프레임워크와 원활하게 통합하기 위해 사용합니다.
  
  **2. `SomeViewModel()` 직접 생성 시:**
  
  - **동작 방식:** 단순히 클래스의 생성자를 호출하여 **새로운 객체 인스턴스를 직접 생성**하는 것입니다.
  - **생명주기 및 스코프:** 이렇게 생성된 `ViewModel` 인스턴스는 **일반적인 객체와 동일한 생명주기**를 갖습니다. 즉, **그것을 생성한 객체(예: 액티비티 인스턴스)의 생명주기에 종속**됩니다. 만약 액티비티가 구성 변경으로 파괴되면, 이 `ViewModel` 인스턴스도 **함께 파괴**됩니다. 액티비티가 다시 생성될 때는 **완전히 새로운 `SomeViewModel` 인스턴스**가 다시 만들어지므로, 이전의 상태는 모두 사라집니다. 즉, **구성 변경을 견디지 못합니다.**
  - **`ViewModelStore`:** 프레임워크의 `ViewModelStore`에 의해 관리되지 않습니다. 시스템은 이 인스턴스가 'ViewModel'로서 특별한 생명주기를 가져야 한다는 것을 알지 못합니다.
  - **의존성 주입 (Hilt 연동):** Hilt의 자동 의존성 주입 메커니즘(및 `ViewModelProvider.Factory`)을 **완전히 우회**합니다. 만약 `SomeViewModel`이 다른 객체(예: Repository)를 필요로 한다면, 개발자가 직접 해당 의존성 객체를 생성해서 생성자에 전달해주어야 합니다. Hilt로부터 자동으로 주입받을 수 없습니다.
  - **권장 사항:** 구성 변경 시 상태를 유지하거나 프레임워크의 생명주기 관리, 또는 Hilt와 같은 DI 프레임워크의 이점을 활용해야 하는 **일반적인 안드로이드 `ViewModel` 용도로는 절대 권장되지 않습니다.** Jetpack ViewModel을 사용하는 핵심적인 이유(생명주기 인지, 상태 보존)를 활용하지 못하게 됩니다.
  
  **핵심 요약:**
  
  - `by viewModels()`는 **프레임워크가 관리하는, 구성 변경에도 살아남는, DI가 가능한** ViewModel 인스턴스를 제공합니다.
  - `SomeViewModel()`은 **일반 객체 생성과 동일하며, 구성 변경 시 소멸되고, DI가 자동으로 되지 않는** 인스턴스를 만듭니다.
  
  따라서 안드로이드 앱 개발에서 Jetpack ViewModel을 사용하는 본래 목적을 달성하기 위해서는 `by viewModels()` (또는 `ViewModelProvider` 직접 사용) 방식을 사용해야 합니다.
    
## RxJava 와 Kotlin Coroutine 을 사용중인데 2가지의 성능을 느낄수 있을만한 작업과 두가지의 성능적인 차이점을 비교
    
  RxJava와 코루틴(Coroutine) 모두 비동기 처리를 위한 훌륭한 도구이지만, 특정 작업 환경에서는 그 성능 차이를 체감할 수 있습니다. 성능 차이가 두드러질 수 있는 작업과 그 차이점을 비교해보겠습니다.
  
  **1. 매우 높은 동시성(High Concurrency) 작업 (예: 수백/수천 개의 동시 네트워크 요청)**
  
  - **작업 예시:** 리스트에 있는 수백 개의 아이템 각각에 대해 상세 정보를 얻기 위해 동시에 API를 호출하거나, 여러 사용자의 상태를 동시에 업데이트하는 경우.
  - **RxJava:**
      - 보통 `Flowable.fromIterable().flatMap()`과 `Schedulers.io()` 등을 사용합니다. `Schedulers.io()`는 내부적으로 스레드 풀을 사용하는데, 동시에 수백 개의 요청이 몰리면 많은 스레드가 생성되거나 작업이 스레드 풀 큐에서 대기하게 됩니다.
      - 스레드 생성 및 컨텍스트 스위칭에는 상당한 시스템 자원과 오버헤드가 발생하며, 작업량이 임계점을 넘어서면 앱의 반응성이 떨어지거나 전체 시스템에 부담을 줄 수 있습니다.
  - **Coroutine:**
      - `Dispatchers.IO`와 함께 `async`나 `launch` 빌더를 사용합니다. `Dispatchers.IO`도 스레드 풀을 공유하지만, 코루틴 자체가 스레드보다 훨씬 가볍습니다.
      - 따라서 **적은 수의 스레드 위에서 수많은 코루틴을 효율적으로 실행(multiplexing)**할 수 있습니다. 코루틴 간의 스위칭 비용이 스레드 스위칭 비용보다 훨씬 저렴합니다.
  - **성능 차이 체감:** 이 경우, 코루틴이 **더 적은 메모리와 시스템 리소스를 사용하면서도 더 높은 처리량**을 보여줄 가능성이 높습니다. 사용자는 아마 **앱의 UI 스레드가 덜 버벅이고, 작업 완료까지의 시간이 단축되거나, 기기 발열/배터리 소모가 덜하다는 식**으로 성능 차이를 느낄 수 있습니다. 수백 개 이상의 동시 I/O 작업에서는 이 차이가 꽤 명확하게 나타날 수 있습니다.
  
  **2. 다수의 자잘한 백그라운드 작업 (특히 리소스 제한적인 기기에서)**
  
  - **작업 예시:** 갤러리 앱에서 수많은 이미지 썸네일을 백그라운드에서 생성하거나, 로컬 DB의 여러 데이터를 개별적으로 동기화하는 작업 등.
  - **RxJava:**
      - `Schedulers.computation()`이나 `Schedulers.io()`를 사용하면 역시 스레드 풀 기반으로 동작합니다.
      - 자원이 부족한 기기에서는 백그라운드 스레드를 많이 사용하는 것 자체가 부담이 되어 앱의 다른 부분(특히 UI)의 반응성에 영향을 줄 수 있습니다.
  - **Coroutine:**
      - `Dispatchers.Default`나 `Dispatchers.IO`를 사용하면 공유된 스레드 풀 위에서 가벼운 코루틴으로 작업을 처리합니다.
      - 개별 작업의 오버헤드가 적기 때문에 많은 작업을 동시에 또는 빠르게 전환하며 처리해도 시스템에 가해지는 부담이 상대적으로 적습니다.
  - **성능 차이 체감:** 특히 **저사양 기기**에서 코루틴을 사용했을 때, 백그라운드 작업 중에도 **앱의 전반적인 UI 반응성이나 스크롤이 더 부드럽게 유지**되는 것을 느낄 수 있습니다. RxJava는 동일 작업을 수행할 때 시스템 리소스를 더 많이 사용하여 다른 작업에 영향을 줄 수 있습니다.
  
  **성능적 차이점 요약:**
  
  - **메모리:** 코루틴이 일반적으로 더 적은 메모리를 사용합니다. (경량성, 적은 중간 객체 생성)
  - **CPU (오버헤드):** 코루틴의 컨텍스트 스위칭 비용이 스레드 스위칭 비용보다 훨씬 저렴하여, 동시 작업이 많을 때 CPU 오버헤드가 적습니다.
  - **처리량:** 위 두 가지 이유로, 특히 I/O 바운드 작업이 매우 많은 경우 코루틴이 더 높은 처리량을 보일 수 있습니다.
  
  따라서, **동시에 처리해야 하는 작업의 수가 매우 많거나**, **기기의 리소스가 제한적인 경우**에 코루틴의 **낮은 오버헤드와 메모리 효율성** 덕분에 RxJava 대비 체감 성능상의 이점을 느낄 수 있습니다. UI 반응성, 전체 처리 시간, 시스템 리소스 사용량 등에서 차이가 나타날 수 있습니다. 물론, RxJava는 반응형 프로그래밍 자체의 강력함과 풍부한 연산자라는 장점이 여전히 존재합니다.
    
## Glide 와 Coil 의 성능 차이 및 전략 비교
    
  Glide와 Coil은 현재 안드로이드에서 가장 많이 사용되는 이미지 로딩 라이브러리들입니다. 둘 다 성능과 안정성을 중요하게 생각하지만, 설계 철학, 주요 사용 기술, 그리고 성능 최적화 전략에서 차이점을 보입니다.
  
  **1. 핵심 철학 및 전략 비교:**
  
  - **Glide:**
      - **전략:** 매우 **성숙하고 안정적**이며, **풍부한 기능과 높은 확장성**을 제공하는 데 중점을 둡니다. 오랫동안 사용되면서 다양한 엣지 케이스와 요구사항을 처리할 수 있도록 발전해왔습니다. 자바 기반으로 시작했지만 코틀린 지원도 잘 갖추고 있습니다.
      - **특징:** 다양한 종류의 리소스 로드(GIF, 비디오 썸네일 등), 복잡한 캐싱 전략(메모리, 디스크 리소스, 디스크 소스), 상세한 커스터마이징 옵션을 제공합니다.
  - **Coil (Coroutine Image Loader):**
      - **전략:** **코틀린 우선(Kotlin-first)**으로 설계되었으며, **가볍고(Lightweight), 빠르고, 현대적인 안드로이드 개발 방식**과의 통합을 최우선으로 합니다. 코루틴, OkHttp, Okio 등 최신 기술 스택을 적극적으로 활용합니다.
      - **특징:** 코틀린 친화적이고 간결한 API, 코루틴 기반의 비동기 처리, 상대적으로 단순화된 확장 모델(Interceptor 등), Jetpack Compose와의 뛰어난 통합 등을 특징으로 합니다.
  
  **2. 성능 비교:**
  
  - **속도 및 오버헤드:**
      - **Coil**이 일반적으로 **더 빠르고 오버헤드가 적다**고 알려져 있습니다. 이는 코틀린 언어 자체의 최적화, 코루틴 사용으로 인한 경량 동시성 처리(스레드 관리 오버헤드 감소), OkHttp/Okio 라이브러리의 효율성 등을 활용하기 때문입니다.
      - **Glide**도 매우 빠르고 최적화되어 있지만, Coil에 비해 내부적으로 약간 더 많은 작업을 수행하거나 객체 할당이 있을 수 있어 미세한 오버헤드 차이가 발생할 수 있습니다.
  - **메모리 사용량:**
      - 두 라이브러리 모두 **메모리 효율성**을 매우 중요하게 생각하며 비트맵 풀링(Bitmap Pooling), 다운샘플링(Downsampling) 등의 기법을 사용합니다.
      - **Coil**은 코틀린 및 최신 안드로이드 API를 기반으로 구현되어 있어, 특정 상황에서 가비지 컬렉션(GC) 압박을 줄이거나 메모리 캐시를 더 공격적으로 관리하여 **약간 더 나은 메모리 프로파일**을 보일 수 있다는 평가가 있습니다.
      - 하지만 실제 메모리 사용량은 로드하는 이미지의 특성, 캐시 설정, 사용 방식에 따라 크게 달라질 수 있으므로 절대적인 비교는 어렵습니다. 둘 다 OOM(OutOfMemoryError) 방지를 위해 많은 노력을 기울입니다.
  - **디스크 캐시:**
      - **Glide**는 자체적인 디스크 캐시 구현을 사용하며, 리소스 캐시(처리된 이미지)와 데이터 캐시(원본 파일)를 분리하여 관리할 수 있습니다.
      - **Coil**은 기본적으로 OkHttp의 HTTP 캐시를 활용하거나, 자체적인 디스크 캐시(LruDiskCache 기반)를 사용합니다. OkHttp 캐시를 활용하면 네트워크 요청과 이미지 캐시를 통합 관리하는 이점이 있을 수 있습니다.
  
  **3. 주요 차이점 요약:**
  
  | **특징** | **Glide** | **Coil** |
  | --- | --- | --- |
  | **주요 언어** | Java (Kotlin 지원 우수) | Kotlin (Kotlin-first) |
  | **비동기 처리** | 자체 스레딩 모델 (Executor 등) | Kotlin Coroutines |
  | **핵심 철학** | 성숙함, 안정성, 풍부한 기능, 높은 확장성 | 현대적, 경량성, 속도, Kotlin 친화성, 간결함 |
  | **성능 (일반적)** | 우수함 | 매우 우수함 (속도/오버헤드/메모리에서 약간 우위 가능성) |
  | **API 스타일** | 빌더 패턴 | Kotlin 확장 함수, 람다 |
  | **네트워킹 (기본)** | 자체 구현 (HttpUrlConnection), OkHttp 선택 가능 | OkHttp |
  | **확장성** | 강력하지만 다소 복잡할 수 있음 (Modules) | 비교적 단순하고 직관적 (Component Registry, Interceptors) |
  | **Jetpack Compose** | 지원 | 지원 우수 (Compose 네이티브 API 제공) |
  
  **결론:**
  
  성능 면에서는 **Coil이 약간의 우위**를 가지는 경우가 많다고 알려져 있으며, 특히 코틀린과 코루틴을 적극적으로 사용하는 현대적인 안드로이드 프로젝트에서는 Coil의 간결한 API와 우수한 성능이 큰 장점이 될 수 있습니다. 반면, **Glide는 오랜 기간 검증된 안정성과 방대한 기능, 레거시 프로젝트나 자바 기반 프로젝트와의 호환성** 면에서 여전히 강력한 선택지입니다.
  
  결국 어떤 라이브러리가 '더 좋다'기보다는, 프로젝트의 요구사항, 기술 스택, 팀의 선호도 등을 고려하여 더 적합한 것을 선택하는 것이 중요합니다.
    
## viewModelScope 는 기본적으로 어떤 Dispatchers 를 사용하는지?
    
  `androidx.lifecycle.viewModelScope` 확장 속성을 통해 제공되는 `viewModelScope`는 기본적으로 **`Dispatchers.Main.immediate`** 디스패처를 사용합니다.
  
  이는 `viewModelScope.launch { ... }` 와 같이 별도의 디스패처를 지정하지 않고 코루틴을 실행하면, 해당 코루틴의 작업이 **기본적으로 안드로이드의 메인 UI 스레드에서 실행**된다는 것을 의미합니다.
  
  **`Dispatchers.Main.immediate`** 는 `Dispatchers.Main` 과 거의 유사하게 메인 스레드로 작업을 보내지만, 한 가지 차이점이 있습니다. 만약 코루틴이 시작되거나 재개되는 시점에 이미 메인 스레드에서 실행 중이었다면, 이벤트 루프(Looper)를 통해 다음번 실행을 위해 큐에 넣는 대신 즉시 실행하려고 시도합니다. 이는 약간의 지연을 줄일 수 있는 최적화입니다.
  
  **중요한 점**은 기본 디스패처가 메인 스레드이기 때문에, `viewModelScope` 내에서 **네트워크 통신, 데이터베이스 접근, 복잡한 계산 등 시간이 오래 걸리거나 블로킹(blocking)될 수 있는 작업**은 반드시 `withContext(Dispatchers.IO)` 또는 `withContext(Dispatchers.Default)` 등을 사용하여 **백그라운드 스레드로 작업을 전환**해주어야 UI 멈춤(ANR) 현상을 피할 수 있다는 것입니다. `viewModelScope` 자체는 코루틴의 생명주기를 `ViewModel`에 맞춰 관리해주는 편리한 스코프일 뿐, 실행 스레드를 자동으로 백그라운드로 바꿔주지는 않습니다.
    
## Dispatchers.Main 과 Dispatchers.Main.immediate 차이점
    
  `Dispatchers.Main`과 `Dispatchers.Main.immediate`의 차이점에 대해 설명드리겠습니다. 두 디스패처 모두 코루틴 코드가 **안드로이드의 메인 UI 스레드에서 실행되도록 보장**하는 역할을 하지만, **언제 어떻게 메인 스레드로 작업을 보내는지**에 미묘한 차이가 있습니다.
  
  **`Dispatchers.Main`:**
  
  - 이 디스패처는 코루틴이 현재 어떤 스레드에서 실행 중이든 관계없이, 실행해야 할 코루틴 블록(또는 재개 지점)을 **항상 메인 스레드의 이벤트 큐(Looper의 MessageQueue)에 메시지(Runnable)로 보냅니다(dispatch).**
  - 즉, 현재 이미 메인 스레드에서 코루틴 코드가 실행 중이었다고 하더라도, `Dispatchers.Main`을 통해 다음 작업을 예약하면 즉시 실행되지 않고 이벤트 큐를 거쳐 **조금 나중에 실행**됩니다. 이는 현재 실행 흐름을 잠시 중단(yield)시키는 효과가 있습니다.
  
  **`Dispatchers.Main.immediate`:**
  
  - 이 디스패처는 일종의 **최적화**를 수행합니다. 코루틴을 실행해야 할 시점에 **현재 스레드가 이미 메인 스레드인지 확인**합니다.
  - **만약 이미 메인 스레드라면:** 굳이 이벤트 큐에 작업을 보내지 않고, **가능하다면 현재 실행 중인 코드 흐름 내에서 즉시(immediately) 코루틴 코드를 실행**하려고 시도합니다. 이렇게 하면 이벤트 큐를 거치는 약간의 지연 시간을 줄일 수 있습니다.
  - **만약 현재 메인 스레드가 아니라면:** `Dispatchers.Main`과 동일하게 메인 스레드의 이벤트 큐에 작업을 보내 나중에 실행되도록 합니다.
  
  **핵심 차이 요약:**
  
  - **스케줄링 방식:** `Main`은 **항상** 이벤트 큐를 통해 디스패치합니다. `immediate`는 **이미 메인 스레드에 있다면 즉시 실행**을 시도하고, 그렇지 않으면 디스패치합니다.
  - **실행 시점:** `Main`은 항상 약간의 지연(dispatch delay) 후 실행됩니다. `immediate`는 메인 스레드에 이미 있을 경우 지연 없이 즉시 실행될 수 있습니다.
  - **용도:** `immediate`는 메인 스레드에서의 연속적인 작업 간의 불필요한 지연을 줄여 성능상 약간의 이점을 얻을 수 있기 때문에, UI 상태 업데이트 등에 좀 더 유리할 수 있습니다. 실제로 Jetpack의 `viewModelScope`나 `lifecycleScope`의 기본 디스패처로 `Dispatchers.Main.immediate`가 사용되는 이유이기도 합니다.
  
  대부분의 경우 큰 차이를 느끼지 못할 수도 있지만, 메인 스레드 작업의 즉시 실행 여부가 중요한 미세한 성능 최적화나 특정 동작 방식이 필요할 때 이 차이를 이해하고 사용하는 것이 도움이 될 수 있습니다.